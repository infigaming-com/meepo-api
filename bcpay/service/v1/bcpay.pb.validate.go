// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: bcpay/service/v1/bcpay.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateDepositRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDepositRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDepositRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDepositRequestMultiError, or nil if none found.
func (m *CreateDepositRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDepositRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantId

	// no validation rules for UserId

	// no validation rules for UserName

	// no validation rules for Currency

	// no validation rules for Country

	// no validation rules for NotifyUrl

	// no validation rules for Amount

	// no validation rules for BankAccount

	// no validation rules for BankAccountFirstname

	// no validation rules for BankAccountLastname

	// no validation rules for BankIban

	if len(errors) > 0 {
		return CreateDepositRequestMultiError(errors)
	}

	return nil
}

// CreateDepositRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDepositRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDepositRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDepositRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDepositRequestMultiError) AllErrors() []error { return m }

// CreateDepositRequestValidationError is the validation error returned by
// CreateDepositRequest.Validate if the designated constraints aren't met.
type CreateDepositRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDepositRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDepositRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDepositRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDepositRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDepositRequestValidationError) ErrorName() string {
	return "CreateDepositRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDepositRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDepositRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDepositRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDepositRequestValidationError{}

// Validate checks the field values on CreateDepositResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDepositResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDepositResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDepositResponseMultiError, or nil if none found.
func (m *CreateDepositResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDepositResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionID

	// no validation rules for DepositReference

	// no validation rules for BankAccount

	// no validation rules for BankAccountName

	// no validation rules for BankIban

	if len(errors) > 0 {
		return CreateDepositResponseMultiError(errors)
	}

	return nil
}

// CreateDepositResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDepositResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDepositResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDepositResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDepositResponseMultiError) AllErrors() []error { return m }

// CreateDepositResponseValidationError is the validation error returned by
// CreateDepositResponse.Validate if the designated constraints aren't met.
type CreateDepositResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDepositResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDepositResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDepositResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDepositResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDepositResponseValidationError) ErrorName() string {
	return "CreateDepositResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDepositResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDepositResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDepositResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDepositResponseValidationError{}

// Validate checks the field values on CreateWithdrawRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWithdrawRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWithdrawRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWithdrawRequestMultiError, or nil if none found.
func (m *CreateWithdrawRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWithdrawRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OperatorOrderNo

	// no validation rules for MerchantId

	// no validation rules for Amount

	// no validation rules for Currency

	// no validation rules for Country

	// no validation rules for NotifyUrl

	// no validation rules for UserId

	// no validation rules for UserName

	// no validation rules for BankAccount

	// no validation rules for BankAccountFirstname

	// no validation rules for BankAccountLastname

	// no validation rules for BankIban

	if len(errors) > 0 {
		return CreateWithdrawRequestMultiError(errors)
	}

	return nil
}

// CreateWithdrawRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWithdrawRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateWithdrawRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWithdrawRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWithdrawRequestMultiError) AllErrors() []error { return m }

// CreateWithdrawRequestValidationError is the validation error returned by
// CreateWithdrawRequest.Validate if the designated constraints aren't met.
type CreateWithdrawRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWithdrawRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWithdrawRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWithdrawRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWithdrawRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWithdrawRequestValidationError) ErrorName() string {
	return "CreateWithdrawRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWithdrawRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWithdrawRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWithdrawRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWithdrawRequestValidationError{}

// Validate checks the field values on CreateWithdrawResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWithdrawResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWithdrawResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWithdrawResponseMultiError, or nil if none found.
func (m *CreateWithdrawResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWithdrawResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return CreateWithdrawResponseMultiError(errors)
	}

	return nil
}

// CreateWithdrawResponseMultiError is an error wrapping multiple validation
// errors returned by CreateWithdrawResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateWithdrawResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWithdrawResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWithdrawResponseMultiError) AllErrors() []error { return m }

// CreateWithdrawResponseValidationError is the validation error returned by
// CreateWithdrawResponse.Validate if the designated constraints aren't met.
type CreateWithdrawResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWithdrawResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWithdrawResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWithdrawResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWithdrawResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWithdrawResponseValidationError) ErrorName() string {
	return "CreateWithdrawResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWithdrawResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWithdrawResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWithdrawResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWithdrawResponseValidationError{}

// Validate checks the field values on GetMerchantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMerchantRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMerchantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMerchantRequestMultiError, or nil if none found.
func (m *GetMerchantRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMerchantRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMerchantRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMerchantRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMerchantRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMerchantRequestMultiError(errors)
	}

	return nil
}

// GetMerchantRequestMultiError is an error wrapping multiple validation errors
// returned by GetMerchantRequest.ValidateAll() if the designated constraints
// aren't met.
type GetMerchantRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMerchantRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMerchantRequestMultiError) AllErrors() []error { return m }

// GetMerchantRequestValidationError is the validation error returned by
// GetMerchantRequest.Validate if the designated constraints aren't met.
type GetMerchantRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMerchantRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMerchantRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMerchantRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMerchantRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMerchantRequestValidationError) ErrorName() string {
	return "GetMerchantRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMerchantRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMerchantRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMerchantRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMerchantRequestValidationError{}

// Validate checks the field values on GetMerchantResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMerchantResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMerchantResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMerchantResponseMultiError, or nil if none found.
func (m *GetMerchantResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMerchantResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantId

	// no validation rules for ApiKeyPublic

	if len(errors) > 0 {
		return GetMerchantResponseMultiError(errors)
	}

	return nil
}

// GetMerchantResponseMultiError is an error wrapping multiple validation
// errors returned by GetMerchantResponse.ValidateAll() if the designated
// constraints aren't met.
type GetMerchantResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMerchantResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMerchantResponseMultiError) AllErrors() []error { return m }

// GetMerchantResponseValidationError is the validation error returned by
// GetMerchantResponse.Validate if the designated constraints aren't met.
type GetMerchantResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMerchantResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMerchantResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMerchantResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMerchantResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMerchantResponseValidationError) ErrorName() string {
	return "GetMerchantResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMerchantResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMerchantResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMerchantResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMerchantResponseValidationError{}

// Validate checks the field values on CreateMerchantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateMerchantRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMerchantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMerchantRequestMultiError, or nil if none found.
func (m *CreateMerchantRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMerchantRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateMerchantRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateMerchantRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateMerchantRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateMerchantRequestMultiError(errors)
	}

	return nil
}

// CreateMerchantRequestMultiError is an error wrapping multiple validation
// errors returned by CreateMerchantRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateMerchantRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMerchantRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMerchantRequestMultiError) AllErrors() []error { return m }

// CreateMerchantRequestValidationError is the validation error returned by
// CreateMerchantRequest.Validate if the designated constraints aren't met.
type CreateMerchantRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMerchantRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMerchantRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMerchantRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMerchantRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMerchantRequestValidationError) ErrorName() string {
	return "CreateMerchantRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMerchantRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMerchantRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMerchantRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMerchantRequestValidationError{}

// Validate checks the field values on CreateMerchantResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateMerchantResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMerchantResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMerchantResponseMultiError, or nil if none found.
func (m *CreateMerchantResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMerchantResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantId

	// no validation rules for ApiKeyPublic

	if len(errors) > 0 {
		return CreateMerchantResponseMultiError(errors)
	}

	return nil
}

// CreateMerchantResponseMultiError is an error wrapping multiple validation
// errors returned by CreateMerchantResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateMerchantResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMerchantResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMerchantResponseMultiError) AllErrors() []error { return m }

// CreateMerchantResponseValidationError is the validation error returned by
// CreateMerchantResponse.Validate if the designated constraints aren't met.
type CreateMerchantResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMerchantResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMerchantResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMerchantResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMerchantResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMerchantResponseValidationError) ErrorName() string {
	return "CreateMerchantResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMerchantResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMerchantResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMerchantResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMerchantResponseValidationError{}

// Validate checks the field values on GetBankSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBankSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBankSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBankSchemaRequestMultiError, or nil if none found.
func (m *GetBankSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBankSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Country

	if len(errors) > 0 {
		return GetBankSchemaRequestMultiError(errors)
	}

	return nil
}

// GetBankSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by GetBankSchemaRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBankSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBankSchemaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBankSchemaRequestMultiError) AllErrors() []error { return m }

// GetBankSchemaRequestValidationError is the validation error returned by
// GetBankSchemaRequest.Validate if the designated constraints aren't met.
type GetBankSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBankSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBankSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBankSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBankSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBankSchemaRequestValidationError) ErrorName() string {
	return "GetBankSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBankSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBankSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBankSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBankSchemaRequestValidationError{}

// Validate checks the field values on GetBankSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBankSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBankSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBankSchemaResponseMultiError, or nil if none found.
func (m *GetBankSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBankSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBankSchemaResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBankSchemaResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBankSchemaResponseValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBankSchemaResponseMultiError(errors)
	}

	return nil
}

// GetBankSchemaResponseMultiError is an error wrapping multiple validation
// errors returned by GetBankSchemaResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBankSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBankSchemaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBankSchemaResponseMultiError) AllErrors() []error { return m }

// GetBankSchemaResponseValidationError is the validation error returned by
// GetBankSchemaResponse.Validate if the designated constraints aren't met.
type GetBankSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBankSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBankSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBankSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBankSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBankSchemaResponseValidationError) ErrorName() string {
	return "GetBankSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBankSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBankSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBankSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBankSchemaResponseValidationError{}

// Validate checks the field values on DepositBankAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DepositBankAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositBankAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DepositBankAccountMultiError, or nil if none found.
func (m *DepositBankAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositBankAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MerchantId

	// no validation rules for BankAccount

	// no validation rules for BankFirstName

	// no validation rules for BankLastName

	// no validation rules for Iban

	// no validation rules for Currency

	// no validation rules for Country

	// no validation rules for MaxAmount

	// no validation rules for MinAmount

	// no validation rules for MaxAmountPerTrans

	// no validation rules for MaxTransLimit

	// no validation rules for CurrentTransTime

	// no validation rules for Priority

	// no validation rules for Enable

	if len(errors) > 0 {
		return DepositBankAccountMultiError(errors)
	}

	return nil
}

// DepositBankAccountMultiError is an error wrapping multiple validation errors
// returned by DepositBankAccount.ValidateAll() if the designated constraints
// aren't met.
type DepositBankAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositBankAccountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositBankAccountMultiError) AllErrors() []error { return m }

// DepositBankAccountValidationError is the validation error returned by
// DepositBankAccount.Validate if the designated constraints aren't met.
type DepositBankAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositBankAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositBankAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositBankAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositBankAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositBankAccountValidationError) ErrorName() string {
	return "DepositBankAccountValidationError"
}

// Error satisfies the builtin error interface
func (e DepositBankAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositBankAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositBankAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositBankAccountValidationError{}

// Validate checks the field values on BankAccountListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BankAccountListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankAccountListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BankAccountListRequestMultiError, or nil if none found.
func (m *BankAccountListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BankAccountListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Currency

	// no validation rules for BankAccount

	// no validation rules for BankAccountFirstname

	// no validation rules for BankAccountLastname

	// no validation rules for CardId

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BankAccountListRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BankAccountListRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BankAccountListRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BankAccountListRequestMultiError(errors)
	}

	return nil
}

// BankAccountListRequestMultiError is an error wrapping multiple validation
// errors returned by BankAccountListRequest.ValidateAll() if the designated
// constraints aren't met.
type BankAccountListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankAccountListRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankAccountListRequestMultiError) AllErrors() []error { return m }

// BankAccountListRequestValidationError is the validation error returned by
// BankAccountListRequest.Validate if the designated constraints aren't met.
type BankAccountListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankAccountListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankAccountListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankAccountListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankAccountListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankAccountListRequestValidationError) ErrorName() string {
	return "BankAccountListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BankAccountListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankAccountListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankAccountListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankAccountListRequestValidationError{}

// Validate checks the field values on BankAccountListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BankAccountListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankAccountListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BankAccountListResponseMultiError, or nil if none found.
func (m *BankAccountListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BankAccountListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBankAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BankAccountListResponseValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BankAccountListResponseValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BankAccountListResponseValidationError{
					field:  fmt.Sprintf("BankAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for TotalPages

	// no validation rules for TotalEnabled

	// no validation rules for TotalDisabled

	if len(errors) > 0 {
		return BankAccountListResponseMultiError(errors)
	}

	return nil
}

// BankAccountListResponseMultiError is an error wrapping multiple validation
// errors returned by BankAccountListResponse.ValidateAll() if the designated
// constraints aren't met.
type BankAccountListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankAccountListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankAccountListResponseMultiError) AllErrors() []error { return m }

// BankAccountListResponseValidationError is the validation error returned by
// BankAccountListResponse.Validate if the designated constraints aren't met.
type BankAccountListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankAccountListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankAccountListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankAccountListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankAccountListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankAccountListResponseValidationError) ErrorName() string {
	return "BankAccountListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BankAccountListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankAccountListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankAccountListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankAccountListResponseValidationError{}

// Validate checks the field values on AddBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddBankAccountRequestMultiError, or nil if none found.
func (m *AddBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Country

	// no validation rules for MaxAmount

	// no validation rules for MinAmount

	// no validation rules for MaxAmountPerTrans

	// no validation rules for MaxTransLimit

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetBankInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddBankAccountRequestValidationError{
					field:  "BankInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddBankAccountRequestValidationError{
					field:  "BankInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddBankAccountRequestValidationError{
				field:  "BankInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddBankAccountRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddBankAccountRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddBankAccountRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddBankAccountRequestMultiError(errors)
	}

	return nil
}

// AddBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by AddBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type AddBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddBankAccountRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddBankAccountRequestMultiError) AllErrors() []error { return m }

// AddBankAccountRequestValidationError is the validation error returned by
// AddBankAccountRequest.Validate if the designated constraints aren't met.
type AddBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddBankAccountRequestValidationError) ErrorName() string {
	return "AddBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddBankAccountRequestValidationError{}

// Validate checks the field values on AddBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddBankAccountResponseMultiError, or nil if none found.
func (m *AddBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddBankAccountResponseValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddBankAccountResponseMultiError(errors)
	}

	return nil
}

// AddBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by AddBankAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type AddBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddBankAccountResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddBankAccountResponseMultiError) AllErrors() []error { return m }

// AddBankAccountResponseValidationError is the validation error returned by
// AddBankAccountResponse.Validate if the designated constraints aren't met.
type AddBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddBankAccountResponseValidationError) ErrorName() string {
	return "AddBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddBankAccountResponseValidationError{}

// Validate checks the field values on UpdateBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBankAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBankAccountRequestMultiError, or nil if none found.
func (m *UpdateBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Currency

	// no validation rules for Country

	// no validation rules for MaxAmount

	// no validation rules for MinAmount

	// no validation rules for MaxAmountPerTrans

	// no validation rules for MaxTransLimit

	// no validation rules for Priority

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetBankInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBankAccountRequestValidationError{
					field:  "BankInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBankAccountRequestValidationError{
					field:  "BankInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBankAccountRequestValidationError{
				field:  "BankInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBankAccountRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBankAccountRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBankAccountRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBankAccountRequestMultiError(errors)
	}

	return nil
}

// UpdateBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBankAccountRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBankAccountRequestMultiError) AllErrors() []error { return m }

// UpdateBankAccountRequestValidationError is the validation error returned by
// UpdateBankAccountRequest.Validate if the designated constraints aren't met.
type UpdateBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBankAccountRequestValidationError) ErrorName() string {
	return "UpdateBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBankAccountRequestValidationError{}

// Validate checks the field values on UpdateBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBankAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBankAccountResponseMultiError, or nil if none found.
func (m *UpdateBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBankAccountResponseValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBankAccountResponseMultiError(errors)
	}

	return nil
}

// UpdateBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateBankAccountResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBankAccountResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBankAccountResponseMultiError) AllErrors() []error { return m }

// UpdateBankAccountResponseValidationError is the validation error returned by
// UpdateBankAccountResponse.Validate if the designated constraints aren't met.
type UpdateBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBankAccountResponseValidationError) ErrorName() string {
	return "UpdateBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBankAccountResponseValidationError{}

// Validate checks the field values on DeleteBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBankAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBankAccountRequestMultiError, or nil if none found.
func (m *DeleteBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteBankAccountRequestMultiError(errors)
	}

	return nil
}

// DeleteBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBankAccountRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBankAccountRequestMultiError) AllErrors() []error { return m }

// DeleteBankAccountRequestValidationError is the validation error returned by
// DeleteBankAccountRequest.Validate if the designated constraints aren't met.
type DeleteBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBankAccountRequestValidationError) ErrorName() string {
	return "DeleteBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBankAccountRequestValidationError{}

// Validate checks the field values on DeleteBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBankAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBankAccountResponseMultiError, or nil if none found.
func (m *DeleteBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteBankAccountResponseMultiError(errors)
	}

	return nil
}

// DeleteBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteBankAccountResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBankAccountResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBankAccountResponseMultiError) AllErrors() []error { return m }

// DeleteBankAccountResponseValidationError is the validation error returned by
// DeleteBankAccountResponse.Validate if the designated constraints aren't met.
type DeleteBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBankAccountResponseValidationError) ErrorName() string {
	return "DeleteBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBankAccountResponseValidationError{}

// Validate checks the field values on TransactionListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionListRequestMultiError, or nil if none found.
func (m *TransactionListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for TransactionId

	// no validation rules for DepositBankAccountFirstname

	// no validation rules for DepositBankAccountLastname

	// no validation rules for UserId

	// no validation rules for UserName

	// no validation rules for UserBankAccountFirstname

	// no validation rules for UserBankAccountLastname

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionListRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionListRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionListRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionListRequestMultiError(errors)
	}

	return nil
}

// TransactionListRequestMultiError is an error wrapping multiple validation
// errors returned by TransactionListRequest.ValidateAll() if the designated
// constraints aren't met.
type TransactionListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionListRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionListRequestMultiError) AllErrors() []error { return m }

// TransactionListRequestValidationError is the validation error returned by
// TransactionListRequest.Validate if the designated constraints aren't met.
type TransactionListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionListRequestValidationError) ErrorName() string {
	return "TransactionListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionListRequestValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MerchantId

	// no validation rules for UserId

	// no validation rules for UserName

	// no validation rules for DepositBankAccount

	// no validation rules for DepositBankAccountFirstName

	// no validation rules for DepositBankAccountLastName

	// no validation rules for UserBankAccount

	// no validation rules for UserBankAccountFirstName

	// no validation rules for UserBankAccountLastName

	// no validation rules for Type

	// no validation rules for CardId

	// no validation rules for Amount

	// no validation rules for Currency

	// no validation rules for Country

	// no validation rules for Status

	// no validation rules for Auditor

	// no validation rules for AuditTime

	// no validation rules for AuditNote

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on TransactionListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionListResponseMultiError, or nil if none found.
func (m *TransactionListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransaction() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionListResponseValidationError{
						field:  fmt.Sprintf("Transaction[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionListResponseValidationError{
						field:  fmt.Sprintf("Transaction[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionListResponseValidationError{
					field:  fmt.Sprintf("Transaction[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for TotalPages

	// no validation rules for TotalApproved

	// no validation rules for TotalFailed

	// no validation rules for TotalPending

	if len(errors) > 0 {
		return TransactionListResponseMultiError(errors)
	}

	return nil
}

// TransactionListResponseMultiError is an error wrapping multiple validation
// errors returned by TransactionListResponse.ValidateAll() if the designated
// constraints aren't met.
type TransactionListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionListResponseMultiError) AllErrors() []error { return m }

// TransactionListResponseValidationError is the validation error returned by
// TransactionListResponse.Validate if the designated constraints aren't met.
type TransactionListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionListResponseValidationError) ErrorName() string {
	return "TransactionListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionListResponseValidationError{}

// Validate checks the field values on AuditTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuditTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditTransactionRequestMultiError, or nil if none found.
func (m *AuditTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Audit

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuditTransactionRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuditTransactionRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuditTransactionRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuditTransactionRequestMultiError(errors)
	}

	return nil
}

// AuditTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by AuditTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type AuditTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditTransactionRequestMultiError) AllErrors() []error { return m }

// AuditTransactionRequestValidationError is the validation error returned by
// AuditTransactionRequest.Validate if the designated constraints aren't met.
type AuditTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditTransactionRequestValidationError) ErrorName() string {
	return "AuditTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuditTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditTransactionRequestValidationError{}

// Validate checks the field values on AuditTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuditTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditTransactionResponseMultiError, or nil if none found.
func (m *AuditTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuditTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuditTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuditTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuditTransactionResponseMultiError(errors)
	}

	return nil
}

// AuditTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by AuditTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type AuditTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditTransactionResponseMultiError) AllErrors() []error { return m }

// AuditTransactionResponseValidationError is the validation error returned by
// AuditTransactionResponse.Validate if the designated constraints aren't met.
type AuditTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditTransactionResponseValidationError) ErrorName() string {
	return "AuditTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AuditTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditTransactionResponseValidationError{}

// Validate checks the field values on AddNoteToTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddNoteToTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNoteToTransactionRequestMultiError, or nil if none found.
func (m *AddNoteToTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Note

	if len(errors) > 0 {
		return AddNoteToTransactionRequestMultiError(errors)
	}

	return nil
}

// AddNoteToTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by AddNoteToTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type AddNoteToTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToTransactionRequestMultiError) AllErrors() []error { return m }

// AddNoteToTransactionRequestValidationError is the validation error returned
// by AddNoteToTransactionRequest.Validate if the designated constraints
// aren't met.
type AddNoteToTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToTransactionRequestValidationError) ErrorName() string {
	return "AddNoteToTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToTransactionRequestValidationError{}

// Validate checks the field values on AddNoteToTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddNoteToTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNoteToTransactionResponseMultiError, or nil if none found.
func (m *AddNoteToTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToTransactionResponseMultiError(errors)
	}

	return nil
}

// AddNoteToTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by AddNoteToTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type AddNoteToTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToTransactionResponseMultiError) AllErrors() []error { return m }

// AddNoteToTransactionResponseValidationError is the validation error returned
// by AddNoteToTransactionResponse.Validate if the designated constraints
// aren't met.
type AddNoteToTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToTransactionResponseValidationError) ErrorName() string {
	return "AddNoteToTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToTransactionResponseValidationError{}
