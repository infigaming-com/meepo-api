syntax = "proto3";

package api.backoffice.service.v1;

import "google/api/annotations.proto";
import "common/common.proto";
import "push/service/v1/push_otp.proto";

option go_package = "github.com/infigaming-com/meepo-api/backoffice/service/v1;v1";
option java_multiple_files = true;
option java_package = "api.backoffice.service.v1";

// BackofficeOTP service — OTP (One-Time Password) delivery configuration management.
//
// ## What is this service for?
// Meepo is a multi-tenant SaaS gaming platform. When end-users perform sensitive operations
// (registration, login, password reset, withdrawal), the platform sends OTP verification codes.
// OTP can be delivered via SMS, WhatsApp, Voice, or Email.
//
// This service allows backoffice administrators to configure HOW OTPs are delivered
// for each operator (tenant), per country. The configuration consists of two layers:
//
//   Provider  — "Which third-party service sends the OTP?" (e.g., EngageLab, Twilio)
//   Template  — "What message content is sent?" (bound to a provider, per business scenario)
//
// ## Complete setup workflow
//
// Step 1: CreateOTPProvider
//   Register a third-party OTP delivery service for an operator + country.
//   Example: EngageLab for operator 1001, country "BR" (Brazil).
//
// Step 2: CreateOTPTemplate
//   Create message templates bound to the provider, one per business scenario.
//   Example: "email_verification" template using EngageLab template ID "T001" in Portuguese.
//
// Step 3: SyncOTPTemplateStatus
//   Some providers (EngageLab WhatsApp) require template approval. Call this to pull the
//   latest review status from the provider. Only approved templates can be used for sending.
//
// Step 4: (Automatic) SendOTP is called by internal services (e.g., user-service)
//   The push-service automatically routes to the correct provider + template based on
//   the operator, country, and business scenario. No backoffice action needed at this step.
//
// Step 5: ListOTPSendLogs
//   Query delivery history for auditing, debugging, or statistics.
//
// ## Multi-tenant permission model
// All requests include target_operator_context. The backoffice validates that the
// authenticated admin has permission to operate on the target operator (hierarchy check).
// If target_operator_context is omitted, it defaults to the admin's own operator.
service BackofficeOTP {
  // ====== Provider Management ======

  // CreateOTPProvider registers a third-party OTP delivery provider for an operator + country.
  //
  // ## What is an OTP Provider?
  // A Provider is a connection to a third-party service (e.g., EngageLab) that can
  // deliver OTP codes via SMS, WhatsApp, or Voice. Each record stores:
  //   - The provider's API credentials (encrypted at rest, never returned in responses)
  //   - Which delivery channels to use and in what order (send_channel_strategy)
  //   - A priority for fallback routing when multiple providers exist
  //
  // ## When to use this API?
  // Call this when onboarding a new operator or expanding to a new country. For example:
  //   - Operator "BetBrazil" wants to send OTP via WhatsApp in Brazil → create a provider
  //     with country="BR", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
  //     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS
  //   - Same operator wants a global SMS fallback → create another provider with
  //     country="global", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
  //     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_SMS
  //
  // ## How does routing work?
  // When user-service calls SendOTP for a phone number, push-service resolves the provider
  // using this fallback chain (first match wins):
  //   1. (operator_id, user's country, enabled=true) ORDER BY priority ASC
  //   2. (operator_id, "global",       enabled=true) ORDER BY priority ASC
  //   3. (system_operator_id, user's country, enabled=true) ORDER BY priority ASC
  //   4. (system_operator_id, "global",       enabled=true) ORDER BY priority ASC
  // This means: operator-specific config is preferred; "global" is the fallback;
  // system-level config provides a safety net for operators that haven't configured anything.
  //
  // ## Example request body (HTTP POST /v1/backoffice/otp/provider/create)
  //   {
  //     "target_operator_context": { "operator_id": 1001 },
  //     "country": "BR",
  //     "provider_type": "OTP_PROVIDER_TYPE_ENGAGELAB",
  //     "name": "EngageLab Brazil",
  //     "enabled": true,
  //     "priority": 0,
  //     "credentials_json": "{\"dev_key\":\"your_key\",\"dev_secret\":\"your_secret\"}",
  //     "config": "{}",
  //     "send_channel_strategy": "OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS"
  //   }
  //
  // ## Response
  // Returns the created provider info (with has_credentials=true instead of actual credentials).
  //
  // ## Errors
  // - SEND_OTP_NO_PROVIDER: credentials_json is missing or invalid
  // - OTP_PROVIDER_ALREADY_EXISTS (if UNIQUE constraint violated): same operator+country+provider_type
  rpc CreateOTPProvider(CreateOTPProviderRequest) returns (api.push.service.v1.CreateOTPProviderResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/provider/create"
      body: "*"
    };
  }

  // UpdateOTPProvider partially updates an existing OTP provider.
  //
  // Only fields present in the request are updated; omitted fields remain unchanged.
  // After update, the provider routing cache is invalidated so changes take effect immediately.
  //
  // Common use cases:
  //   - Rotate credentials: set credentials_json with new keys
  //   - Disable a provider temporarily: set enabled=false (routing will skip it)
  //   - Change channel strategy: e.g., switch from WhatsApp-first to SMS-only
  //
  // ## Errors
  // - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
  rpc UpdateOTPProvider(UpdateOTPProviderRequest) returns (api.push.service.v1.UpdateOTPProviderResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/provider/update"
      body: "*"
    };
  }

  // DeleteOTPProvider permanently removes an OTP provider.
  //
  // WARNING: Deleting a provider that still has templates bound to it will cause
  // those templates to become orphaned — they will still match during routing but
  // fail at send time because the provider credentials are gone.
  // Best practice: delete all associated templates first, or disable the provider instead.
  //
  // ## Errors
  // - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
  rpc DeleteOTPProvider(DeleteOTPProviderRequest) returns (api.push.service.v1.DeleteOTPProviderResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/provider/delete"
      body: "*"
    };
  }

  // GetOTPProvider retrieves a single OTP provider by ID.
  //
  // Returns all provider fields except credentials (has_credentials=true/false is returned instead).
  //
  // ## Errors
  // - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
  rpc GetOTPProvider(GetOTPProviderRequest) returns (api.push.service.v1.GetOTPProviderResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/provider/get"
      body: "*"
    };
  }

  // ListOTPProviders lists OTP providers with optional filters and pagination.
  //
  // Supports filtering by country, provider_type, and enabled status.
  // Results are scoped to the operator specified in target_operator_context.
  // Returns paginated results with total count.
  rpc ListOTPProviders(ListOTPProvidersRequest) returns (api.push.service.v1.ListOTPProvidersResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/provider/list"
      body: "*"
    };
  }

  // ====== Template Management ======

  // CreateOTPTemplate creates a message template bound to a specific OTP provider.
  //
  // ## What is an OTP Template?
  // A Template defines the message content sent to the end-user. It is bound to a
  // specific OTP Provider (created via CreateOTPProvider). Each template is scoped
  // to a business scenario (template_type) such as login, registration, or withdrawal.
  //
  // ## What is external_template_id?
  // This is the template ID assigned by the third-party provider (e.g., EngageLab).
  // You must first create the template on the provider's platform, then copy the ID here.
  //
  // ### How to get it (EngageLab):
  //   1. Log in to EngageLab console → OTP → Template Management
  //   2. Create a new template (choose SMS or WhatsApp channel)
  //   3. After creation (and approval for WhatsApp), copy the template ID
  //   4. Use that ID as external_template_id when calling this API
  //
  // When SendOTP is triggered, the system passes this ID to the provider's API
  // so the provider knows which pre-approved message template to use.
  //
  // ## How does template routing work?
  // When user-service calls SendOTP, push-service resolves the template using this
  // fallback chain (first match wins, per operator level):
  //   For each level: operator → company → retailer → system (skip if ID=0):
  //     1. (operator_id, country, template_type, language)
  //     2. (operator_id, country, template_type, "en")
  //     3. (operator_id, "global", template_type, language)
  //     4. (operator_id, "global", template_type, "en")
  //
  // ## Example request body (HTTP POST /v1/backoffice/otp/template/create)
  //   {
  //     "target_operator_context": { "operator_id": 1001 },
  //     "country": "BR",
  //     "provider_id": 166153951194906625,
  //     "name": "Brazil Login OTP",
  //     "template_type": "OTP_TEMPLATE_TYPE_LOGIN_OTP",
  //     "external_template_id": "T001",
  //     "language": "pt",
  //     "brand_name": "BetBrazil",
  //     "code_length": 6,
  //     "code_ttl_seconds": 300,
  //     "extra_params": "{}",
  //     "enabled": true
  //   }
  //
  // ## Constraints
  // - UNIQUE(operator_id, country, template_type, language): one template per scenario+language
  // - provider_id must reference an existing OTP provider
  // - external_template_id is required for SMS/WhatsApp providers (the provider needs it to send)
  rpc CreateOTPTemplate(CreateOTPTemplateRequest) returns (api.push.service.v1.CreateOTPTemplateResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/template/create"
      body: "*"
    };
  }

  // UpdateOTPTemplate partially updates an existing OTP template.
  //
  // Only fields present in the request are updated; omitted fields remain unchanged.
  // After update, the template routing cache is invalidated so changes take effect immediately.
  //
  // Common use cases:
  //   - Switch to a new external template: set external_template_id
  //   - Update the brand name displayed in OTP messages: set brand_name
  //   - Disable a template temporarily: set enabled=false
  //
  // ## Errors
  // - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
  rpc UpdateOTPTemplate(UpdateOTPTemplateRequest) returns (api.push.service.v1.UpdateOTPTemplateResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/template/update"
      body: "*"
    };
  }

  // DeleteOTPTemplate permanently removes an OTP template.
  //
  // If the deleted template was the only match for a given operator+country+type+language,
  // the system will fall back to the next level in the routing chain (e.g., company → retailer → system).
  // If no template matches at all, SendOTP will return an OTP_TEMPLATE_NOT_FOUND error.
  //
  // ## Errors
  // - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
  rpc DeleteOTPTemplate(DeleteOTPTemplateRequest) returns (api.push.service.v1.DeleteOTPTemplateResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/template/delete"
      body: "*"
    };
  }

  // GetOTPTemplate retrieves a single OTP template by ID.
  //
  // Returns all template fields including review_status (for providers that require approval).
  //
  // ## Errors
  // - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
  rpc GetOTPTemplate(GetOTPTemplateRequest) returns (api.push.service.v1.GetOTPTemplateResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/template/get"
      body: "*"
    };
  }

  // ListOTPTemplates lists OTP templates with optional filters and pagination.
  //
  // Supports filtering by country, provider_id, template_type, and enabled status.
  // Results are scoped to the operator specified in target_operator_context.
  // Returns paginated results with total count.
  rpc ListOTPTemplates(ListOTPTemplatesRequest) returns (api.push.service.v1.ListOTPTemplatesResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/template/list"
      body: "*"
    };
  }

  // SyncOTPTemplateStatus pulls the latest review status from the external provider.
  //
  // Some providers (e.g., EngageLab WhatsApp) require templates to be reviewed and approved
  // before they can be used. This RPC calls the provider's API to check the current status
  // and updates the local record's review_status field.
  //
  // ## Review status values (provider-specific)
  // EngageLab: 0=pending, 1=approved, 2=rejected
  //
  // ## When to call?
  // After creating a new WhatsApp template on the provider's platform, call this periodically
  // until the status changes to "approved". SMS templates typically don't require review.
  //
  // ## Errors
  // - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
  // - SEND_OTP_FAILED: failed to query the provider's API (credentials invalid, network error, etc.)
  rpc SyncOTPTemplateStatus(SyncOTPTemplateStatusRequest) returns (api.push.service.v1.SyncOTPTemplateStatusResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/template/sync-status"
      body: "*"
    };
  }

  // ====== Send Logs ======

  // ListOTPSendLogs queries OTP delivery history for auditing, debugging, or statistics.
  //
  // Each log records: who sent what, to whom, via which provider/template/channel,
  // and whether it succeeded or failed. Logs are immutable (append-only).
  //
  // ## Filters
  //   - user_id: filter by the end-user who triggered the OTP
  //   - channel_used: filter by delivery channel ("sms", "whatsapp", "voice", "email")
  //   - status: filter by delivery status ("sent", "failed")
  //   - start_time / end_time: time range filter (Unix milliseconds)
  //
  // ## Use cases
  //   - Debug a user's OTP delivery failure: filter by user_id + status="failed"
  //   - Audit all WhatsApp OTPs in the last 24h: filter by channel_used + time range
  //   - Monitor delivery success rate: aggregate by status over a time range
  rpc ListOTPSendLogs(ListOTPSendLogsRequest) returns (api.push.service.v1.ListOTPSendLogsResponse) {
    option (google.api.http) = {
      post: "/v1/backoffice/otp/send-logs/list"
      body: "*"
    };
  }
}

// ============ Provider Management ============

// CreateOTPProviderRequest — see CreateOTPProvider RPC comment above for full documentation.
//
// Constraints:
// - UNIQUE(operator_id, country, provider_type): one provider per type per operator+country.
// - credentials_json is required and must be valid JSON for the chosen provider_type.
message CreateOTPProviderRequest {
  api.common.OperatorContext target_operator_context = 1;
  string country = 2;             // ISO 3166-1 alpha-2, or "global" for default fallback
  api.push.service.v1.OTPProviderType provider_type = 3;             // Third-party provider (e.g., OTP_PROVIDER_TYPE_ENGAGELAB)
  string name = 4;                // Human-readable display name
  bool enabled = 5;               // Whether this provider is active for routing
  int32 priority = 6;             // Routing priority (lower = higher priority, e.g., 0 > 1 > 2)
  string credentials_json = 7;    // Plain JSON with provider-specific credentials (encrypted before storage)
  string config = 8;              // JSON string of non-sensitive config (base_url, timeouts, etc.)
  api.push.service.v1.OTPSendChannelStrategy send_channel_strategy = 9; // Channel delivery order (e.g., OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS)
}

// UpdateOTPProviderRequest partially updates an existing OTP provider.
// Only provided (non-nil) fields are updated; omitted fields remain unchanged.
message UpdateOTPProviderRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;                                                                  // Provider ID to update (from CreateOTPProvider response or ListOTPProviders)
  optional string name = 3;                                                      // New display name
  optional bool enabled = 4;                                                     // Enable/disable for routing
  optional int32 priority = 5;                                                   // New routing priority
  optional string credentials_json = 6;                                          // New credentials (will be re-encrypted before storage)
  optional string config = 7;                                                    // New non-sensitive config JSON. Invalid JSON is silently ignored.
  optional api.push.service.v1.OTPSendChannelStrategy send_channel_strategy = 8; // New channel delivery strategy
}

// DeleteOTPProviderRequest permanently deletes an OTP provider by ID.
// Associated templates are NOT automatically deleted — clean them up first.
message DeleteOTPProviderRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;  // Provider ID to delete
}

// GetOTPProviderRequest retrieves a single OTP provider by ID.
// Credentials are never returned; use has_credentials in the response to check if they are set.
message GetOTPProviderRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;  // Provider ID to retrieve
}

// ListOTPProvidersRequest lists OTP providers with optional filters and pagination.
// Results are scoped to the operator in target_operator_context.
message ListOTPProvidersRequest {
  api.common.OperatorContext target_operator_context = 1;
  optional string country = 2;                              // Filter by country code (e.g., "BR") or "global"
  optional api.push.service.v1.OTPProviderType provider_type = 3; // Filter by provider type
  optional bool enabled = 4;                                // Filter by enabled status
  int32 page = 5;                                           // Page number (1-based)
  int32 page_size = 6;                                      // Items per page (max 100)
}

// ============ Template Management ============

// CreateOTPTemplateRequest — see CreateOTPTemplate RPC comment above for full documentation.
//
// Constraints:
// - UNIQUE(operator_id, country, template_type, language): one template per scenario per language.
// - provider_id must reference an existing OTP provider (created via CreateOTPProvider).
// - external_template_id is required for SMS/WhatsApp providers.
message CreateOTPTemplateRequest {
  api.common.OperatorContext target_operator_context = 1;
  string country = 2;                                      // ISO 3166-1 alpha-2 (e.g., "BR"), or "global" for default fallback
  int64 provider_id = 3;                                    // ID of the OTP provider this template belongs to (from CreateOTPProvider response)
  string name = 4;                                          // Human-readable display name (e.g., "Brazil Login OTP - Portuguese")
  api.push.service.v1.OTPTemplateType template_type = 5;    // Business scenario this template serves
  string external_template_id = 6;                          // Template ID from the third-party provider's platform.
                                                            // For EngageLab: find it in Console → OTP → Template Management after creating/approving the template.
                                                            // This ID is passed to the provider's API at send time to select the correct message content.
  string language = 7;                                      // BCP-47 language code: "en", "pt", "zh", etc. Used for routing and passed to the provider.
  string brand_name = 8;                                    // Brand name injected into the OTP message (e.g., "BetBrazil"). Passed as template variable "brand_name".
  int32 code_length = 9;                                    // OTP code length, informational only (default: 6). The actual code is generated by user-service.
  int32 code_ttl_seconds = 10;                              // OTP code TTL in seconds, informational only (default: 900). The actual TTL is enforced by user-service.
  string extra_params = 11;                                 // Optional. JSON string of additional template variables passed to the provider (e.g., '{"app_name":"Meepo"}').
  bool enabled = 12;                                        // Whether this template is active for routing. Disabled templates are skipped during resolution.
}

// UpdateOTPTemplateRequest partially updates an existing OTP template.
// Only provided (non-nil) fields are updated; omitted fields remain unchanged.
message UpdateOTPTemplateRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;                            // Template ID to update (from CreateOTPTemplate response or ListOTPTemplates)
  optional string name = 3;                // New display name
  optional string external_template_id = 4; // New external template ID (see CreateOTPTemplate docs for how to obtain)
  optional string language = 5;            // New language code (changes routing key — ensure no UNIQUE conflict)
  optional string brand_name = 6;          // New brand name for message content
  optional int32 code_length = 7;          // New code length (informational)
  optional int32 code_ttl_seconds = 8;     // New code TTL (informational)
  optional string extra_params = 9;        // New extra template variables (JSON string)
  optional bool enabled = 10;              // Enable/disable for routing
}

// DeleteOTPTemplateRequest permanently deletes an OTP template by ID.
message DeleteOTPTemplateRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;  // Template ID to delete
}

// GetOTPTemplateRequest retrieves a single OTP template by ID.
message GetOTPTemplateRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;  // Template ID to retrieve
}

// ListOTPTemplatesRequest lists OTP templates with optional filters and pagination.
// Results are scoped to the operator in target_operator_context.
message ListOTPTemplatesRequest {
  api.common.OperatorContext target_operator_context = 1;
  optional string country = 2;                                  // Filter by country code (e.g., "BR") or "global"
  optional int64 provider_id = 3;                                // Filter by associated provider ID
  optional api.push.service.v1.OTPTemplateType template_type = 4; // Filter by business scenario
  optional bool enabled = 5;                                     // Filter by enabled status
  int32 page = 6;                                                // Page number (1-based)
  int32 page_size = 7;                                           // Items per page (max 100)
}

// SyncOTPTemplateStatusRequest pulls the review status for a template from the external provider.
// See SyncOTPTemplateStatus RPC comment for details on review workflow.
message SyncOTPTemplateStatusRequest {
  api.common.OperatorContext target_operator_context = 1;
  int64 id = 2;  // Template ID to sync status for
}

// ============ Send Logs ============

// ListOTPSendLogsRequest queries OTP delivery history with filters and pagination.
// See ListOTPSendLogs RPC comment for supported use cases.
message ListOTPSendLogsRequest {
  api.common.OperatorContext target_operator_context = 1;
  optional int64 user_id = 2;          // Filter by end-user ID who triggered the OTP
  optional string channel_used = 3;    // Filter by delivery channel: "sms", "whatsapp", "voice", "email"
  optional string status = 4;          // Filter by delivery status: "sent", "failed"
  int64 start_time = 5;               // Start of time range (Unix milliseconds, inclusive)
  int64 end_time = 6;                  // End of time range (Unix milliseconds, inclusive)
  int32 page = 7;                      // Page number (1-based)
  int32 page_size = 8;                 // Items per page (max 100)
}
