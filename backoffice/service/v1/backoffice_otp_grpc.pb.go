// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.29.3
// source: backoffice/service/v1/backoffice_otp.proto

package v1

import (
	context "context"
	v1 "github.com/infigaming-com/meepo-api/push/service/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BackofficeOTP_CreateOTPProvider_FullMethodName     = "/api.backoffice.service.v1.BackofficeOTP/CreateOTPProvider"
	BackofficeOTP_UpdateOTPProvider_FullMethodName     = "/api.backoffice.service.v1.BackofficeOTP/UpdateOTPProvider"
	BackofficeOTP_DeleteOTPProvider_FullMethodName     = "/api.backoffice.service.v1.BackofficeOTP/DeleteOTPProvider"
	BackofficeOTP_GetOTPProvider_FullMethodName        = "/api.backoffice.service.v1.BackofficeOTP/GetOTPProvider"
	BackofficeOTP_ListOTPProviders_FullMethodName      = "/api.backoffice.service.v1.BackofficeOTP/ListOTPProviders"
	BackofficeOTP_CreateOTPTemplate_FullMethodName     = "/api.backoffice.service.v1.BackofficeOTP/CreateOTPTemplate"
	BackofficeOTP_UpdateOTPTemplate_FullMethodName     = "/api.backoffice.service.v1.BackofficeOTP/UpdateOTPTemplate"
	BackofficeOTP_DeleteOTPTemplate_FullMethodName     = "/api.backoffice.service.v1.BackofficeOTP/DeleteOTPTemplate"
	BackofficeOTP_GetOTPTemplate_FullMethodName        = "/api.backoffice.service.v1.BackofficeOTP/GetOTPTemplate"
	BackofficeOTP_ListOTPTemplates_FullMethodName      = "/api.backoffice.service.v1.BackofficeOTP/ListOTPTemplates"
	BackofficeOTP_SyncOTPTemplateStatus_FullMethodName = "/api.backoffice.service.v1.BackofficeOTP/SyncOTPTemplateStatus"
	BackofficeOTP_ListOTPSendLogs_FullMethodName       = "/api.backoffice.service.v1.BackofficeOTP/ListOTPSendLogs"
)

// BackofficeOTPClient is the client API for BackofficeOTP service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// BackofficeOTP service — OTP (One-Time Password) delivery configuration management.
//
// ## What is this service for?
// Meepo is a multi-tenant SaaS gaming platform. When end-users perform sensitive operations
// (registration, login, password reset, withdrawal), the platform sends OTP verification codes.
// OTP can be delivered via SMS, WhatsApp, Voice, or Email.
//
// This service allows backoffice administrators to configure HOW OTPs are delivered
// for each operator (tenant), per country. The configuration consists of two layers:
//
//	Provider  — "Which third-party service sends the OTP?" (e.g., EngageLab, Twilio)
//	Template  — "What message content is sent?" (bound to a provider, per business scenario)
//
// ## Complete setup workflow
//
// Step 1: CreateOTPProvider
//
//	Register a third-party OTP delivery service for an operator + country.
//	Example: EngageLab for operator 1001, country "BR" (Brazil).
//
// Step 2: CreateOTPTemplate
//
//	Create message templates bound to the provider, one per business scenario.
//	Example: "email_verification" template using EngageLab template ID "T001" in Portuguese.
//
// Step 3: SyncOTPTemplateStatus
//
//	Some providers (EngageLab WhatsApp) require template approval. Call this to pull the
//	latest review status from the provider. Only approved templates can be used for sending.
//
// Step 4: (Automatic) SendOTP is called by internal services (e.g., user-service)
//
//	The push-service automatically routes to the correct provider + template based on
//	the operator, country, and business scenario. No backoffice action needed at this step.
//
// Step 5: ListOTPSendLogs
//
//	Query delivery history for auditing, debugging, or statistics.
//
// ## Multi-tenant permission model
// All requests include target_operator_context. The backoffice validates that the
// authenticated admin has permission to operate on the target operator (hierarchy check).
// If target_operator_context is omitted, it defaults to the admin's own operator.
type BackofficeOTPClient interface {
	// CreateOTPProvider registers a third-party OTP delivery provider for an operator + country.
	//
	// ## What is an OTP Provider?
	// A Provider is a connection to a third-party service (e.g., EngageLab) that can
	// deliver OTP codes via SMS, WhatsApp, or Voice. Each record stores:
	//   - The provider's API credentials (encrypted at rest, never returned in responses)
	//   - Which delivery channels to use and in what order (send_channel_strategy)
	//   - A priority for fallback routing when multiple providers exist
	//
	// ## When to use this API?
	// Call this when onboarding a new operator or expanding to a new country. For example:
	//   - Operator "BetBrazil" wants to send OTP via WhatsApp in Brazil → create a provider
	//     with country="BR", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS
	//   - Same operator wants a global SMS fallback → create another provider with
	//     country="global", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_SMS
	//
	// ## How does routing work?
	// When user-service calls SendOTP for a phone number, push-service resolves the provider
	// using this fallback chain (first match wins):
	//  1. (operator_id, user's country, enabled=true) ORDER BY priority ASC
	//  2. (operator_id, "global",       enabled=true) ORDER BY priority ASC
	//  3. (system_operator_id, user's country, enabled=true) ORDER BY priority ASC
	//  4. (system_operator_id, "global",       enabled=true) ORDER BY priority ASC
	//
	// This means: operator-specific config is preferred; "global" is the fallback;
	// system-level config provides a safety net for operators that haven't configured anything.
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/provider/create)
	//
	//	{
	//	  "target_operator_context": { "operator_id": 1001 },
	//	  "country": "BR",
	//	  "provider_type": "OTP_PROVIDER_TYPE_ENGAGELAB",
	//	  "name": "EngageLab Brazil",
	//	  "enabled": true,
	//	  "priority": 0,
	//	  "credentials_json": "{\"dev_key\":\"your_key\",\"dev_secret\":\"your_secret\"}",
	//	  "config": "{}",
	//	  "send_channel_strategy": "OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS"
	//	}
	//
	// ## Response
	// Returns the created provider info (with has_credentials=true instead of actual credentials).
	//
	// ## Errors
	// - SEND_OTP_NO_PROVIDER: credentials_json is missing or invalid
	// - OTP_PROVIDER_ALREADY_EXISTS (if UNIQUE constraint violated): same operator+country+provider_type
	CreateOTPProvider(ctx context.Context, in *CreateOTPProviderRequest, opts ...grpc.CallOption) (*v1.CreateOTPProviderResponse, error)
	UpdateOTPProvider(ctx context.Context, in *UpdateOTPProviderRequest, opts ...grpc.CallOption) (*v1.UpdateOTPProviderResponse, error)
	DeleteOTPProvider(ctx context.Context, in *DeleteOTPProviderRequest, opts ...grpc.CallOption) (*v1.DeleteOTPProviderResponse, error)
	GetOTPProvider(ctx context.Context, in *GetOTPProviderRequest, opts ...grpc.CallOption) (*v1.GetOTPProviderResponse, error)
	ListOTPProviders(ctx context.Context, in *ListOTPProvidersRequest, opts ...grpc.CallOption) (*v1.ListOTPProvidersResponse, error)
	// CreateOTPTemplate creates a message template bound to a specific OTP provider.
	//
	// ## What is an OTP Template?
	// A Template defines the message content sent to the end-user. It is bound to a
	// specific OTP Provider (created via CreateOTPProvider). Each template is scoped
	// to a business scenario (template_type) such as login, registration, or withdrawal.
	//
	// ## What is external_template_id?
	// This is the template ID assigned by the third-party provider (e.g., EngageLab).
	// You must first create the template on the provider's platform, then copy the ID here.
	//
	// ### How to get it (EngageLab):
	//  1. Log in to EngageLab console → OTP → Template Management
	//  2. Create a new template (choose SMS or WhatsApp channel)
	//  3. After creation (and approval for WhatsApp), copy the template ID
	//  4. Use that ID as external_template_id when calling this API
	//
	// When SendOTP is triggered, the system passes this ID to the provider's API
	// so the provider knows which pre-approved message template to use.
	//
	// ## How does template routing work?
	// When user-service calls SendOTP, push-service resolves the template using this
	// fallback chain (first match wins, per operator level):
	//
	//	For each level: operator → company → retailer → system (skip if ID=0):
	//	  1. (operator_id, country, template_type, language)
	//	  2. (operator_id, country, template_type, "en")
	//	  3. (operator_id, "global", template_type, language)
	//	  4. (operator_id, "global", template_type, "en")
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/template/create)
	//
	//	{
	//	  "target_operator_context": { "operator_id": 1001 },
	//	  "country": "BR",
	//	  "provider_id": 166153951194906625,
	//	  "name": "Brazil Login OTP",
	//	  "template_type": "OTP_TEMPLATE_TYPE_LOGIN_OTP",
	//	  "external_template_id": "T001",
	//	  "language": "pt",
	//	  "brand_name": "BetBrazil",
	//	  "code_length": 6,
	//	  "code_ttl_seconds": 300,
	//	  "extra_params": "{}",
	//	  "enabled": true
	//	}
	//
	// ## Constraints
	// - UNIQUE(operator_id, country, template_type, language): one template per scenario+language
	// - provider_id must reference an existing OTP provider
	// - external_template_id is required for SMS/WhatsApp providers (the provider needs it to send)
	CreateOTPTemplate(ctx context.Context, in *CreateOTPTemplateRequest, opts ...grpc.CallOption) (*v1.CreateOTPTemplateResponse, error)
	UpdateOTPTemplate(ctx context.Context, in *UpdateOTPTemplateRequest, opts ...grpc.CallOption) (*v1.UpdateOTPTemplateResponse, error)
	DeleteOTPTemplate(ctx context.Context, in *DeleteOTPTemplateRequest, opts ...grpc.CallOption) (*v1.DeleteOTPTemplateResponse, error)
	GetOTPTemplate(ctx context.Context, in *GetOTPTemplateRequest, opts ...grpc.CallOption) (*v1.GetOTPTemplateResponse, error)
	ListOTPTemplates(ctx context.Context, in *ListOTPTemplatesRequest, opts ...grpc.CallOption) (*v1.ListOTPTemplatesResponse, error)
	SyncOTPTemplateStatus(ctx context.Context, in *SyncOTPTemplateStatusRequest, opts ...grpc.CallOption) (*v1.SyncOTPTemplateStatusResponse, error)
	ListOTPSendLogs(ctx context.Context, in *ListOTPSendLogsRequest, opts ...grpc.CallOption) (*v1.ListOTPSendLogsResponse, error)
}

type backofficeOTPClient struct {
	cc grpc.ClientConnInterface
}

func NewBackofficeOTPClient(cc grpc.ClientConnInterface) BackofficeOTPClient {
	return &backofficeOTPClient{cc}
}

func (c *backofficeOTPClient) CreateOTPProvider(ctx context.Context, in *CreateOTPProviderRequest, opts ...grpc.CallOption) (*v1.CreateOTPProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.CreateOTPProviderResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_CreateOTPProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) UpdateOTPProvider(ctx context.Context, in *UpdateOTPProviderRequest, opts ...grpc.CallOption) (*v1.UpdateOTPProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.UpdateOTPProviderResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_UpdateOTPProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) DeleteOTPProvider(ctx context.Context, in *DeleteOTPProviderRequest, opts ...grpc.CallOption) (*v1.DeleteOTPProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.DeleteOTPProviderResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_DeleteOTPProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) GetOTPProvider(ctx context.Context, in *GetOTPProviderRequest, opts ...grpc.CallOption) (*v1.GetOTPProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.GetOTPProviderResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_GetOTPProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) ListOTPProviders(ctx context.Context, in *ListOTPProvidersRequest, opts ...grpc.CallOption) (*v1.ListOTPProvidersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.ListOTPProvidersResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_ListOTPProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) CreateOTPTemplate(ctx context.Context, in *CreateOTPTemplateRequest, opts ...grpc.CallOption) (*v1.CreateOTPTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.CreateOTPTemplateResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_CreateOTPTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) UpdateOTPTemplate(ctx context.Context, in *UpdateOTPTemplateRequest, opts ...grpc.CallOption) (*v1.UpdateOTPTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.UpdateOTPTemplateResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_UpdateOTPTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) DeleteOTPTemplate(ctx context.Context, in *DeleteOTPTemplateRequest, opts ...grpc.CallOption) (*v1.DeleteOTPTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.DeleteOTPTemplateResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_DeleteOTPTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) GetOTPTemplate(ctx context.Context, in *GetOTPTemplateRequest, opts ...grpc.CallOption) (*v1.GetOTPTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.GetOTPTemplateResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_GetOTPTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) ListOTPTemplates(ctx context.Context, in *ListOTPTemplatesRequest, opts ...grpc.CallOption) (*v1.ListOTPTemplatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.ListOTPTemplatesResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_ListOTPTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) SyncOTPTemplateStatus(ctx context.Context, in *SyncOTPTemplateStatusRequest, opts ...grpc.CallOption) (*v1.SyncOTPTemplateStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.SyncOTPTemplateStatusResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_SyncOTPTemplateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeOTPClient) ListOTPSendLogs(ctx context.Context, in *ListOTPSendLogsRequest, opts ...grpc.CallOption) (*v1.ListOTPSendLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.ListOTPSendLogsResponse)
	err := c.cc.Invoke(ctx, BackofficeOTP_ListOTPSendLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackofficeOTPServer is the server API for BackofficeOTP service.
// All implementations must embed UnimplementedBackofficeOTPServer
// for forward compatibility.
//
// BackofficeOTP service — OTP (One-Time Password) delivery configuration management.
//
// ## What is this service for?
// Meepo is a multi-tenant SaaS gaming platform. When end-users perform sensitive operations
// (registration, login, password reset, withdrawal), the platform sends OTP verification codes.
// OTP can be delivered via SMS, WhatsApp, Voice, or Email.
//
// This service allows backoffice administrators to configure HOW OTPs are delivered
// for each operator (tenant), per country. The configuration consists of two layers:
//
//	Provider  — "Which third-party service sends the OTP?" (e.g., EngageLab, Twilio)
//	Template  — "What message content is sent?" (bound to a provider, per business scenario)
//
// ## Complete setup workflow
//
// Step 1: CreateOTPProvider
//
//	Register a third-party OTP delivery service for an operator + country.
//	Example: EngageLab for operator 1001, country "BR" (Brazil).
//
// Step 2: CreateOTPTemplate
//
//	Create message templates bound to the provider, one per business scenario.
//	Example: "email_verification" template using EngageLab template ID "T001" in Portuguese.
//
// Step 3: SyncOTPTemplateStatus
//
//	Some providers (EngageLab WhatsApp) require template approval. Call this to pull the
//	latest review status from the provider. Only approved templates can be used for sending.
//
// Step 4: (Automatic) SendOTP is called by internal services (e.g., user-service)
//
//	The push-service automatically routes to the correct provider + template based on
//	the operator, country, and business scenario. No backoffice action needed at this step.
//
// Step 5: ListOTPSendLogs
//
//	Query delivery history for auditing, debugging, or statistics.
//
// ## Multi-tenant permission model
// All requests include target_operator_context. The backoffice validates that the
// authenticated admin has permission to operate on the target operator (hierarchy check).
// If target_operator_context is omitted, it defaults to the admin's own operator.
type BackofficeOTPServer interface {
	// CreateOTPProvider registers a third-party OTP delivery provider for an operator + country.
	//
	// ## What is an OTP Provider?
	// A Provider is a connection to a third-party service (e.g., EngageLab) that can
	// deliver OTP codes via SMS, WhatsApp, or Voice. Each record stores:
	//   - The provider's API credentials (encrypted at rest, never returned in responses)
	//   - Which delivery channels to use and in what order (send_channel_strategy)
	//   - A priority for fallback routing when multiple providers exist
	//
	// ## When to use this API?
	// Call this when onboarding a new operator or expanding to a new country. For example:
	//   - Operator "BetBrazil" wants to send OTP via WhatsApp in Brazil → create a provider
	//     with country="BR", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS
	//   - Same operator wants a global SMS fallback → create another provider with
	//     country="global", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_SMS
	//
	// ## How does routing work?
	// When user-service calls SendOTP for a phone number, push-service resolves the provider
	// using this fallback chain (first match wins):
	//  1. (operator_id, user's country, enabled=true) ORDER BY priority ASC
	//  2. (operator_id, "global",       enabled=true) ORDER BY priority ASC
	//  3. (system_operator_id, user's country, enabled=true) ORDER BY priority ASC
	//  4. (system_operator_id, "global",       enabled=true) ORDER BY priority ASC
	//
	// This means: operator-specific config is preferred; "global" is the fallback;
	// system-level config provides a safety net for operators that haven't configured anything.
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/provider/create)
	//
	//	{
	//	  "target_operator_context": { "operator_id": 1001 },
	//	  "country": "BR",
	//	  "provider_type": "OTP_PROVIDER_TYPE_ENGAGELAB",
	//	  "name": "EngageLab Brazil",
	//	  "enabled": true,
	//	  "priority": 0,
	//	  "credentials_json": "{\"dev_key\":\"your_key\",\"dev_secret\":\"your_secret\"}",
	//	  "config": "{}",
	//	  "send_channel_strategy": "OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS"
	//	}
	//
	// ## Response
	// Returns the created provider info (with has_credentials=true instead of actual credentials).
	//
	// ## Errors
	// - SEND_OTP_NO_PROVIDER: credentials_json is missing or invalid
	// - OTP_PROVIDER_ALREADY_EXISTS (if UNIQUE constraint violated): same operator+country+provider_type
	CreateOTPProvider(context.Context, *CreateOTPProviderRequest) (*v1.CreateOTPProviderResponse, error)
	UpdateOTPProvider(context.Context, *UpdateOTPProviderRequest) (*v1.UpdateOTPProviderResponse, error)
	DeleteOTPProvider(context.Context, *DeleteOTPProviderRequest) (*v1.DeleteOTPProviderResponse, error)
	GetOTPProvider(context.Context, *GetOTPProviderRequest) (*v1.GetOTPProviderResponse, error)
	ListOTPProviders(context.Context, *ListOTPProvidersRequest) (*v1.ListOTPProvidersResponse, error)
	// CreateOTPTemplate creates a message template bound to a specific OTP provider.
	//
	// ## What is an OTP Template?
	// A Template defines the message content sent to the end-user. It is bound to a
	// specific OTP Provider (created via CreateOTPProvider). Each template is scoped
	// to a business scenario (template_type) such as login, registration, or withdrawal.
	//
	// ## What is external_template_id?
	// This is the template ID assigned by the third-party provider (e.g., EngageLab).
	// You must first create the template on the provider's platform, then copy the ID here.
	//
	// ### How to get it (EngageLab):
	//  1. Log in to EngageLab console → OTP → Template Management
	//  2. Create a new template (choose SMS or WhatsApp channel)
	//  3. After creation (and approval for WhatsApp), copy the template ID
	//  4. Use that ID as external_template_id when calling this API
	//
	// When SendOTP is triggered, the system passes this ID to the provider's API
	// so the provider knows which pre-approved message template to use.
	//
	// ## How does template routing work?
	// When user-service calls SendOTP, push-service resolves the template using this
	// fallback chain (first match wins, per operator level):
	//
	//	For each level: operator → company → retailer → system (skip if ID=0):
	//	  1. (operator_id, country, template_type, language)
	//	  2. (operator_id, country, template_type, "en")
	//	  3. (operator_id, "global", template_type, language)
	//	  4. (operator_id, "global", template_type, "en")
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/template/create)
	//
	//	{
	//	  "target_operator_context": { "operator_id": 1001 },
	//	  "country": "BR",
	//	  "provider_id": 166153951194906625,
	//	  "name": "Brazil Login OTP",
	//	  "template_type": "OTP_TEMPLATE_TYPE_LOGIN_OTP",
	//	  "external_template_id": "T001",
	//	  "language": "pt",
	//	  "brand_name": "BetBrazil",
	//	  "code_length": 6,
	//	  "code_ttl_seconds": 300,
	//	  "extra_params": "{}",
	//	  "enabled": true
	//	}
	//
	// ## Constraints
	// - UNIQUE(operator_id, country, template_type, language): one template per scenario+language
	// - provider_id must reference an existing OTP provider
	// - external_template_id is required for SMS/WhatsApp providers (the provider needs it to send)
	CreateOTPTemplate(context.Context, *CreateOTPTemplateRequest) (*v1.CreateOTPTemplateResponse, error)
	UpdateOTPTemplate(context.Context, *UpdateOTPTemplateRequest) (*v1.UpdateOTPTemplateResponse, error)
	DeleteOTPTemplate(context.Context, *DeleteOTPTemplateRequest) (*v1.DeleteOTPTemplateResponse, error)
	GetOTPTemplate(context.Context, *GetOTPTemplateRequest) (*v1.GetOTPTemplateResponse, error)
	ListOTPTemplates(context.Context, *ListOTPTemplatesRequest) (*v1.ListOTPTemplatesResponse, error)
	SyncOTPTemplateStatus(context.Context, *SyncOTPTemplateStatusRequest) (*v1.SyncOTPTemplateStatusResponse, error)
	ListOTPSendLogs(context.Context, *ListOTPSendLogsRequest) (*v1.ListOTPSendLogsResponse, error)
	mustEmbedUnimplementedBackofficeOTPServer()
}

// UnimplementedBackofficeOTPServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBackofficeOTPServer struct{}

func (UnimplementedBackofficeOTPServer) CreateOTPProvider(context.Context, *CreateOTPProviderRequest) (*v1.CreateOTPProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOTPProvider not implemented")
}
func (UnimplementedBackofficeOTPServer) UpdateOTPProvider(context.Context, *UpdateOTPProviderRequest) (*v1.UpdateOTPProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateOTPProvider not implemented")
}
func (UnimplementedBackofficeOTPServer) DeleteOTPProvider(context.Context, *DeleteOTPProviderRequest) (*v1.DeleteOTPProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteOTPProvider not implemented")
}
func (UnimplementedBackofficeOTPServer) GetOTPProvider(context.Context, *GetOTPProviderRequest) (*v1.GetOTPProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOTPProvider not implemented")
}
func (UnimplementedBackofficeOTPServer) ListOTPProviders(context.Context, *ListOTPProvidersRequest) (*v1.ListOTPProvidersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOTPProviders not implemented")
}
func (UnimplementedBackofficeOTPServer) CreateOTPTemplate(context.Context, *CreateOTPTemplateRequest) (*v1.CreateOTPTemplateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOTPTemplate not implemented")
}
func (UnimplementedBackofficeOTPServer) UpdateOTPTemplate(context.Context, *UpdateOTPTemplateRequest) (*v1.UpdateOTPTemplateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateOTPTemplate not implemented")
}
func (UnimplementedBackofficeOTPServer) DeleteOTPTemplate(context.Context, *DeleteOTPTemplateRequest) (*v1.DeleteOTPTemplateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteOTPTemplate not implemented")
}
func (UnimplementedBackofficeOTPServer) GetOTPTemplate(context.Context, *GetOTPTemplateRequest) (*v1.GetOTPTemplateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOTPTemplate not implemented")
}
func (UnimplementedBackofficeOTPServer) ListOTPTemplates(context.Context, *ListOTPTemplatesRequest) (*v1.ListOTPTemplatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOTPTemplates not implemented")
}
func (UnimplementedBackofficeOTPServer) SyncOTPTemplateStatus(context.Context, *SyncOTPTemplateStatusRequest) (*v1.SyncOTPTemplateStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncOTPTemplateStatus not implemented")
}
func (UnimplementedBackofficeOTPServer) ListOTPSendLogs(context.Context, *ListOTPSendLogsRequest) (*v1.ListOTPSendLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOTPSendLogs not implemented")
}
func (UnimplementedBackofficeOTPServer) mustEmbedUnimplementedBackofficeOTPServer() {}
func (UnimplementedBackofficeOTPServer) testEmbeddedByValue()                       {}

// UnsafeBackofficeOTPServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackofficeOTPServer will
// result in compilation errors.
type UnsafeBackofficeOTPServer interface {
	mustEmbedUnimplementedBackofficeOTPServer()
}

func RegisterBackofficeOTPServer(s grpc.ServiceRegistrar, srv BackofficeOTPServer) {
	// If the following call panics, it indicates UnimplementedBackofficeOTPServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BackofficeOTP_ServiceDesc, srv)
}

func _BackofficeOTP_CreateOTPProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOTPProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).CreateOTPProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_CreateOTPProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).CreateOTPProvider(ctx, req.(*CreateOTPProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_UpdateOTPProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOTPProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).UpdateOTPProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_UpdateOTPProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).UpdateOTPProvider(ctx, req.(*UpdateOTPProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_DeleteOTPProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOTPProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).DeleteOTPProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_DeleteOTPProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).DeleteOTPProvider(ctx, req.(*DeleteOTPProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_GetOTPProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOTPProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).GetOTPProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_GetOTPProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).GetOTPProvider(ctx, req.(*GetOTPProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_ListOTPProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOTPProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).ListOTPProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_ListOTPProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).ListOTPProviders(ctx, req.(*ListOTPProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_CreateOTPTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOTPTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).CreateOTPTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_CreateOTPTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).CreateOTPTemplate(ctx, req.(*CreateOTPTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_UpdateOTPTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOTPTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).UpdateOTPTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_UpdateOTPTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).UpdateOTPTemplate(ctx, req.(*UpdateOTPTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_DeleteOTPTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOTPTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).DeleteOTPTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_DeleteOTPTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).DeleteOTPTemplate(ctx, req.(*DeleteOTPTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_GetOTPTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOTPTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).GetOTPTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_GetOTPTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).GetOTPTemplate(ctx, req.(*GetOTPTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_ListOTPTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOTPTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).ListOTPTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_ListOTPTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).ListOTPTemplates(ctx, req.(*ListOTPTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_SyncOTPTemplateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncOTPTemplateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).SyncOTPTemplateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_SyncOTPTemplateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).SyncOTPTemplateStatus(ctx, req.(*SyncOTPTemplateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackofficeOTP_ListOTPSendLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOTPSendLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeOTPServer).ListOTPSendLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackofficeOTP_ListOTPSendLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeOTPServer).ListOTPSendLogs(ctx, req.(*ListOTPSendLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackofficeOTP_ServiceDesc is the grpc.ServiceDesc for BackofficeOTP service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackofficeOTP_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.backoffice.service.v1.BackofficeOTP",
	HandlerType: (*BackofficeOTPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOTPProvider",
			Handler:    _BackofficeOTP_CreateOTPProvider_Handler,
		},
		{
			MethodName: "UpdateOTPProvider",
			Handler:    _BackofficeOTP_UpdateOTPProvider_Handler,
		},
		{
			MethodName: "DeleteOTPProvider",
			Handler:    _BackofficeOTP_DeleteOTPProvider_Handler,
		},
		{
			MethodName: "GetOTPProvider",
			Handler:    _BackofficeOTP_GetOTPProvider_Handler,
		},
		{
			MethodName: "ListOTPProviders",
			Handler:    _BackofficeOTP_ListOTPProviders_Handler,
		},
		{
			MethodName: "CreateOTPTemplate",
			Handler:    _BackofficeOTP_CreateOTPTemplate_Handler,
		},
		{
			MethodName: "UpdateOTPTemplate",
			Handler:    _BackofficeOTP_UpdateOTPTemplate_Handler,
		},
		{
			MethodName: "DeleteOTPTemplate",
			Handler:    _BackofficeOTP_DeleteOTPTemplate_Handler,
		},
		{
			MethodName: "GetOTPTemplate",
			Handler:    _BackofficeOTP_GetOTPTemplate_Handler,
		},
		{
			MethodName: "ListOTPTemplates",
			Handler:    _BackofficeOTP_ListOTPTemplates_Handler,
		},
		{
			MethodName: "SyncOTPTemplateStatus",
			Handler:    _BackofficeOTP_SyncOTPTemplateStatus_Handler,
		},
		{
			MethodName: "ListOTPSendLogs",
			Handler:    _BackofficeOTP_ListOTPSendLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "backoffice/service/v1/backoffice_otp.proto",
}
