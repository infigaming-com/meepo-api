// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             v5.29.3
// source: backoffice/service/v1/backoffice_otp.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	v1 "github.com/infigaming-com/meepo-api/push/service/v1"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationBackofficeOTPCreateOTPProvider = "/api.backoffice.service.v1.BackofficeOTP/CreateOTPProvider"
const OperationBackofficeOTPCreateOTPTemplate = "/api.backoffice.service.v1.BackofficeOTP/CreateOTPTemplate"
const OperationBackofficeOTPDeleteOTPProvider = "/api.backoffice.service.v1.BackofficeOTP/DeleteOTPProvider"
const OperationBackofficeOTPDeleteOTPTemplate = "/api.backoffice.service.v1.BackofficeOTP/DeleteOTPTemplate"
const OperationBackofficeOTPGetOTPProvider = "/api.backoffice.service.v1.BackofficeOTP/GetOTPProvider"
const OperationBackofficeOTPGetOTPTemplate = "/api.backoffice.service.v1.BackofficeOTP/GetOTPTemplate"
const OperationBackofficeOTPListOTPProviders = "/api.backoffice.service.v1.BackofficeOTP/ListOTPProviders"
const OperationBackofficeOTPListOTPSendLogs = "/api.backoffice.service.v1.BackofficeOTP/ListOTPSendLogs"
const OperationBackofficeOTPListOTPTemplates = "/api.backoffice.service.v1.BackofficeOTP/ListOTPTemplates"
const OperationBackofficeOTPSyncOTPTemplateStatus = "/api.backoffice.service.v1.BackofficeOTP/SyncOTPTemplateStatus"
const OperationBackofficeOTPUpdateOTPProvider = "/api.backoffice.service.v1.BackofficeOTP/UpdateOTPProvider"
const OperationBackofficeOTPUpdateOTPTemplate = "/api.backoffice.service.v1.BackofficeOTP/UpdateOTPTemplate"

type BackofficeOTPHTTPServer interface {
	// CreateOTPProvider CreateOTPProvider registers a third-party OTP delivery provider for an operator + country.
	//
	// ## What is an OTP Provider?
	// A Provider is a connection to a third-party service (e.g., EngageLab) that can
	// deliver OTP codes via SMS, WhatsApp, or Voice. Each record stores:
	//   - The provider's API credentials (encrypted at rest, never returned in responses)
	//   - Which delivery channels to use and in what order (send_channel_strategy)
	//   - A priority for fallback routing when multiple providers exist
	//
	// ## When to use this API?
	// Call this when onboarding a new operator or expanding to a new country. For example:
	//   - Operator "BetBrazil" wants to send OTP via WhatsApp in Brazil → create a provider
	//     with country="BR", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS
	//   - Same operator wants a global SMS fallback → create another provider with
	//     country="global", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_SMS
	//
	// ## How does routing work?
	// When user-service calls SendOTP for a phone number, push-service resolves the provider
	// using this fallback chain (first match wins):
	//   1. (operator_id, user's country, enabled=true) ORDER BY priority ASC
	//   2. (operator_id, "global",       enabled=true) ORDER BY priority ASC
	//   3. (system_operator_id, user's country, enabled=true) ORDER BY priority ASC
	//   4. (system_operator_id, "global",       enabled=true) ORDER BY priority ASC
	// This means: operator-specific config is preferred; "global" is the fallback;
	// system-level config provides a safety net for operators that haven't configured anything.
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/provider/create)
	//   {
	//     "target_operator_context": { "operator_id": 1001 },
	//     "country": "BR",
	//     "provider_type": "OTP_PROVIDER_TYPE_ENGAGELAB",
	//     "name": "EngageLab Brazil",
	//     "enabled": true,
	//     "priority": 0,
	//     "credentials_json": "{\"dev_key\":\"your_key\",\"dev_secret\":\"your_secret\"}",
	//     "config": "{}",
	//     "send_channel_strategy": "OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS"
	//   }
	//
	// ## Response
	// Returns the created provider info (with has_credentials=true instead of actual credentials).
	//
	// ## Errors
	// - SEND_OTP_NO_PROVIDER: credentials_json is missing or invalid
	// - OTP_PROVIDER_ALREADY_EXISTS (if UNIQUE constraint violated): same operator+country+provider_type
	CreateOTPProvider(context.Context, *CreateOTPProviderRequest) (*v1.CreateOTPProviderResponse, error)
	// CreateOTPTemplate CreateOTPTemplate creates a message template bound to a specific OTP provider.
	//
	// ## What is an OTP Template?
	// A Template defines the message content sent to the end-user. It is bound to a
	// specific OTP Provider (created via CreateOTPProvider). Each template is scoped
	// to a business scenario (template_type) such as login, registration, or withdrawal.
	//
	// ## What is external_template_id?
	// This is the template ID assigned by the third-party provider (e.g., EngageLab).
	// You must first create the template on the provider's platform, then copy the ID here.
	//
	// ### How to get it (EngageLab):
	//   1. Log in to EngageLab console → OTP → Template Management
	//   2. Create a new template (choose SMS or WhatsApp channel)
	//   3. After creation (and approval for WhatsApp), copy the template ID
	//   4. Use that ID as external_template_id when calling this API
	//
	// When SendOTP is triggered, the system passes this ID to the provider's API
	// so the provider knows which pre-approved message template to use.
	//
	// ## How does template routing work?
	// When user-service calls SendOTP, push-service resolves the template using this
	// fallback chain (first match wins, per operator level):
	//   For each level: operator → company → retailer → system (skip if ID=0):
	//     1. (operator_id, country, template_type, language)
	//     2. (operator_id, country, template_type, "en")
	//     3. (operator_id, "global", template_type, language)
	//     4. (operator_id, "global", template_type, "en")
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/template/create)
	//   {
	//     "target_operator_context": { "operator_id": 1001 },
	//     "country": "BR",
	//     "provider_id": 166153951194906625,
	//     "name": "Brazil Login OTP",
	//     "template_type": "OTP_TEMPLATE_TYPE_LOGIN_OTP",
	//     "external_template_id": "T001",
	//     "language": "pt",
	//     "brand_name": "BetBrazil",
	//     "code_length": 6,
	//     "code_ttl_seconds": 300,
	//     "extra_params": "{}",
	//     "enabled": true
	//   }
	//
	// ## Constraints
	// - UNIQUE(operator_id, country, template_type, language): one template per scenario+language
	// - provider_id must reference an existing OTP provider
	// - external_template_id is required for SMS/WhatsApp providers (the provider needs it to send)
	CreateOTPTemplate(context.Context, *CreateOTPTemplateRequest) (*v1.CreateOTPTemplateResponse, error)
	// DeleteOTPProvider DeleteOTPProvider permanently removes an OTP provider.
	//
	// WARNING: Deleting a provider that still has templates bound to it will cause
	// those templates to become orphaned — they will still match during routing but
	// fail at send time because the provider credentials are gone.
	// Best practice: delete all associated templates first, or disable the provider instead.
	//
	// ## Errors
	// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
	DeleteOTPProvider(context.Context, *DeleteOTPProviderRequest) (*v1.DeleteOTPProviderResponse, error)
	// DeleteOTPTemplate DeleteOTPTemplate permanently removes an OTP template.
	//
	// If the deleted template was the only match for a given operator+country+type+language,
	// the system will fall back to the next level in the routing chain (e.g., company → retailer → system).
	// If no template matches at all, SendOTP will return an OTP_TEMPLATE_NOT_FOUND error.
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	DeleteOTPTemplate(context.Context, *DeleteOTPTemplateRequest) (*v1.DeleteOTPTemplateResponse, error)
	// GetOTPProvider GetOTPProvider retrieves a single OTP provider by ID.
	//
	// Returns all provider fields except credentials (has_credentials=true/false is returned instead).
	//
	// ## Errors
	// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
	GetOTPProvider(context.Context, *GetOTPProviderRequest) (*v1.GetOTPProviderResponse, error)
	// GetOTPTemplate GetOTPTemplate retrieves a single OTP template by ID.
	//
	// Returns all template fields including review_status (for providers that require approval).
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	GetOTPTemplate(context.Context, *GetOTPTemplateRequest) (*v1.GetOTPTemplateResponse, error)
	// ListOTPProviders ListOTPProviders lists OTP providers with optional filters and pagination.
	//
	// Supports filtering by country, provider_type, and enabled status.
	// Results are scoped to the operator specified in target_operator_context.
	// Returns paginated results with total count.
	ListOTPProviders(context.Context, *ListOTPProvidersRequest) (*v1.ListOTPProvidersResponse, error)
	// ListOTPSendLogs ListOTPSendLogs queries OTP delivery history for auditing, debugging, or statistics.
	//
	// Each log records: who sent what, to whom, via which provider/template/channel,
	// and whether it succeeded or failed. Logs are immutable (append-only).
	//
	// ## Filters
	//   - user_id: filter by the end-user who triggered the OTP
	//   - channel_used: filter by delivery channel ("sms", "whatsapp", "voice", "email")
	//   - status: filter by delivery status ("sent", "failed")
	//   - start_time / end_time: time range filter (Unix milliseconds)
	//
	// ## Use cases
	//   - Debug a user's OTP delivery failure: filter by user_id + status="failed"
	//   - Audit all WhatsApp OTPs in the last 24h: filter by channel_used + time range
	//   - Monitor delivery success rate: aggregate by status over a time range
	ListOTPSendLogs(context.Context, *ListOTPSendLogsRequest) (*v1.ListOTPSendLogsResponse, error)
	// ListOTPTemplates ListOTPTemplates lists OTP templates with optional filters and pagination.
	//
	// Supports filtering by country, provider_id, template_type, and enabled status.
	// Results are scoped to the operator specified in target_operator_context.
	// Returns paginated results with total count.
	ListOTPTemplates(context.Context, *ListOTPTemplatesRequest) (*v1.ListOTPTemplatesResponse, error)
	// SyncOTPTemplateStatus SyncOTPTemplateStatus pulls the latest review status from the external provider.
	//
	// Some providers (e.g., EngageLab WhatsApp) require templates to be reviewed and approved
	// before they can be used. This RPC calls the provider's API to check the current status
	// and updates the local record's review_status field.
	//
	// ## Review status values (provider-specific)
	// EngageLab: 0=pending, 1=approved, 2=rejected
	//
	// ## When to call?
	// After creating a new WhatsApp template on the provider's platform, call this periodically
	// until the status changes to "approved". SMS templates typically don't require review.
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	// - SEND_OTP_FAILED: failed to query the provider's API (credentials invalid, network error, etc.)
	SyncOTPTemplateStatus(context.Context, *SyncOTPTemplateStatusRequest) (*v1.SyncOTPTemplateStatusResponse, error)
	// UpdateOTPProvider UpdateOTPProvider partially updates an existing OTP provider.
	//
	// Only fields present in the request are updated; omitted fields remain unchanged.
	// After update, the provider routing cache is invalidated so changes take effect immediately.
	//
	// Common use cases:
	//   - Rotate credentials: set credentials_json with new keys
	//   - Disable a provider temporarily: set enabled=false (routing will skip it)
	//   - Change channel strategy: e.g., switch from WhatsApp-first to SMS-only
	//
	// ## Errors
	// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
	UpdateOTPProvider(context.Context, *UpdateOTPProviderRequest) (*v1.UpdateOTPProviderResponse, error)
	// UpdateOTPTemplate UpdateOTPTemplate partially updates an existing OTP template.
	//
	// Only fields present in the request are updated; omitted fields remain unchanged.
	// After update, the template routing cache is invalidated so changes take effect immediately.
	//
	// Common use cases:
	//   - Switch to a new external template: set external_template_id
	//   - Update the brand name displayed in OTP messages: set brand_name
	//   - Disable a template temporarily: set enabled=false
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	UpdateOTPTemplate(context.Context, *UpdateOTPTemplateRequest) (*v1.UpdateOTPTemplateResponse, error)
}

func RegisterBackofficeOTPHTTPServer(s *http.Server, srv BackofficeOTPHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/backoffice/otp/provider/create", _BackofficeOTP_CreateOTPProvider0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/provider/update", _BackofficeOTP_UpdateOTPProvider0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/provider/delete", _BackofficeOTP_DeleteOTPProvider0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/provider/get", _BackofficeOTP_GetOTPProvider0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/provider/list", _BackofficeOTP_ListOTPProviders0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/template/create", _BackofficeOTP_CreateOTPTemplate0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/template/update", _BackofficeOTP_UpdateOTPTemplate0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/template/delete", _BackofficeOTP_DeleteOTPTemplate0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/template/get", _BackofficeOTP_GetOTPTemplate0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/template/list", _BackofficeOTP_ListOTPTemplates0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/template/sync-status", _BackofficeOTP_SyncOTPTemplateStatus0_HTTP_Handler(srv))
	r.POST("/v1/backoffice/otp/send-logs/list", _BackofficeOTP_ListOTPSendLogs0_HTTP_Handler(srv))
}

func _BackofficeOTP_CreateOTPProvider0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateOTPProviderRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPCreateOTPProvider)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateOTPProvider(ctx, req.(*CreateOTPProviderRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.CreateOTPProviderResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_UpdateOTPProvider0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateOTPProviderRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPUpdateOTPProvider)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateOTPProvider(ctx, req.(*UpdateOTPProviderRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.UpdateOTPProviderResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_DeleteOTPProvider0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteOTPProviderRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPDeleteOTPProvider)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteOTPProvider(ctx, req.(*DeleteOTPProviderRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.DeleteOTPProviderResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_GetOTPProvider0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetOTPProviderRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPGetOTPProvider)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetOTPProvider(ctx, req.(*GetOTPProviderRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.GetOTPProviderResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_ListOTPProviders0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListOTPProvidersRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPListOTPProviders)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListOTPProviders(ctx, req.(*ListOTPProvidersRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.ListOTPProvidersResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_CreateOTPTemplate0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateOTPTemplateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPCreateOTPTemplate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateOTPTemplate(ctx, req.(*CreateOTPTemplateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.CreateOTPTemplateResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_UpdateOTPTemplate0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateOTPTemplateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPUpdateOTPTemplate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateOTPTemplate(ctx, req.(*UpdateOTPTemplateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.UpdateOTPTemplateResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_DeleteOTPTemplate0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteOTPTemplateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPDeleteOTPTemplate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteOTPTemplate(ctx, req.(*DeleteOTPTemplateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.DeleteOTPTemplateResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_GetOTPTemplate0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetOTPTemplateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPGetOTPTemplate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetOTPTemplate(ctx, req.(*GetOTPTemplateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.GetOTPTemplateResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_ListOTPTemplates0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListOTPTemplatesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPListOTPTemplates)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListOTPTemplates(ctx, req.(*ListOTPTemplatesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.ListOTPTemplatesResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_SyncOTPTemplateStatus0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SyncOTPTemplateStatusRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPSyncOTPTemplateStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SyncOTPTemplateStatus(ctx, req.(*SyncOTPTemplateStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.SyncOTPTemplateStatusResponse)
		return ctx.Result(200, reply)
	}
}

func _BackofficeOTP_ListOTPSendLogs0_HTTP_Handler(srv BackofficeOTPHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListOTPSendLogsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBackofficeOTPListOTPSendLogs)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListOTPSendLogs(ctx, req.(*ListOTPSendLogsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.ListOTPSendLogsResponse)
		return ctx.Result(200, reply)
	}
}

type BackofficeOTPHTTPClient interface {
	// CreateOTPProvider CreateOTPProvider registers a third-party OTP delivery provider for an operator + country.
	//
	// ## What is an OTP Provider?
	// A Provider is a connection to a third-party service (e.g., EngageLab) that can
	// deliver OTP codes via SMS, WhatsApp, or Voice. Each record stores:
	//   - The provider's API credentials (encrypted at rest, never returned in responses)
	//   - Which delivery channels to use and in what order (send_channel_strategy)
	//   - A priority for fallback routing when multiple providers exist
	//
	// ## When to use this API?
	// Call this when onboarding a new operator or expanding to a new country. For example:
	//   - Operator "BetBrazil" wants to send OTP via WhatsApp in Brazil → create a provider
	//     with country="BR", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS
	//   - Same operator wants a global SMS fallback → create another provider with
	//     country="global", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
	//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_SMS
	//
	// ## How does routing work?
	// When user-service calls SendOTP for a phone number, push-service resolves the provider
	// using this fallback chain (first match wins):
	//   1. (operator_id, user's country, enabled=true) ORDER BY priority ASC
	//   2. (operator_id, "global",       enabled=true) ORDER BY priority ASC
	//   3. (system_operator_id, user's country, enabled=true) ORDER BY priority ASC
	//   4. (system_operator_id, "global",       enabled=true) ORDER BY priority ASC
	// This means: operator-specific config is preferred; "global" is the fallback;
	// system-level config provides a safety net for operators that haven't configured anything.
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/provider/create)
	//   {
	//     "target_operator_context": { "operator_id": 1001 },
	//     "country": "BR",
	//     "provider_type": "OTP_PROVIDER_TYPE_ENGAGELAB",
	//     "name": "EngageLab Brazil",
	//     "enabled": true,
	//     "priority": 0,
	//     "credentials_json": "{\"dev_key\":\"your_key\",\"dev_secret\":\"your_secret\"}",
	//     "config": "{}",
	//     "send_channel_strategy": "OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS"
	//   }
	//
	// ## Response
	// Returns the created provider info (with has_credentials=true instead of actual credentials).
	//
	// ## Errors
	// - SEND_OTP_NO_PROVIDER: credentials_json is missing or invalid
	// - OTP_PROVIDER_ALREADY_EXISTS (if UNIQUE constraint violated): same operator+country+provider_type
	CreateOTPProvider(ctx context.Context, req *CreateOTPProviderRequest, opts ...http.CallOption) (rsp *v1.CreateOTPProviderResponse, err error)
	// CreateOTPTemplate CreateOTPTemplate creates a message template bound to a specific OTP provider.
	//
	// ## What is an OTP Template?
	// A Template defines the message content sent to the end-user. It is bound to a
	// specific OTP Provider (created via CreateOTPProvider). Each template is scoped
	// to a business scenario (template_type) such as login, registration, or withdrawal.
	//
	// ## What is external_template_id?
	// This is the template ID assigned by the third-party provider (e.g., EngageLab).
	// You must first create the template on the provider's platform, then copy the ID here.
	//
	// ### How to get it (EngageLab):
	//   1. Log in to EngageLab console → OTP → Template Management
	//   2. Create a new template (choose SMS or WhatsApp channel)
	//   3. After creation (and approval for WhatsApp), copy the template ID
	//   4. Use that ID as external_template_id when calling this API
	//
	// When SendOTP is triggered, the system passes this ID to the provider's API
	// so the provider knows which pre-approved message template to use.
	//
	// ## How does template routing work?
	// When user-service calls SendOTP, push-service resolves the template using this
	// fallback chain (first match wins, per operator level):
	//   For each level: operator → company → retailer → system (skip if ID=0):
	//     1. (operator_id, country, template_type, language)
	//     2. (operator_id, country, template_type, "en")
	//     3. (operator_id, "global", template_type, language)
	//     4. (operator_id, "global", template_type, "en")
	//
	// ## Example request body (HTTP POST /v1/backoffice/otp/template/create)
	//   {
	//     "target_operator_context": { "operator_id": 1001 },
	//     "country": "BR",
	//     "provider_id": 166153951194906625,
	//     "name": "Brazil Login OTP",
	//     "template_type": "OTP_TEMPLATE_TYPE_LOGIN_OTP",
	//     "external_template_id": "T001",
	//     "language": "pt",
	//     "brand_name": "BetBrazil",
	//     "code_length": 6,
	//     "code_ttl_seconds": 300,
	//     "extra_params": "{}",
	//     "enabled": true
	//   }
	//
	// ## Constraints
	// - UNIQUE(operator_id, country, template_type, language): one template per scenario+language
	// - provider_id must reference an existing OTP provider
	// - external_template_id is required for SMS/WhatsApp providers (the provider needs it to send)
	CreateOTPTemplate(ctx context.Context, req *CreateOTPTemplateRequest, opts ...http.CallOption) (rsp *v1.CreateOTPTemplateResponse, err error)
	// DeleteOTPProvider DeleteOTPProvider permanently removes an OTP provider.
	//
	// WARNING: Deleting a provider that still has templates bound to it will cause
	// those templates to become orphaned — they will still match during routing but
	// fail at send time because the provider credentials are gone.
	// Best practice: delete all associated templates first, or disable the provider instead.
	//
	// ## Errors
	// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
	DeleteOTPProvider(ctx context.Context, req *DeleteOTPProviderRequest, opts ...http.CallOption) (rsp *v1.DeleteOTPProviderResponse, err error)
	// DeleteOTPTemplate DeleteOTPTemplate permanently removes an OTP template.
	//
	// If the deleted template was the only match for a given operator+country+type+language,
	// the system will fall back to the next level in the routing chain (e.g., company → retailer → system).
	// If no template matches at all, SendOTP will return an OTP_TEMPLATE_NOT_FOUND error.
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	DeleteOTPTemplate(ctx context.Context, req *DeleteOTPTemplateRequest, opts ...http.CallOption) (rsp *v1.DeleteOTPTemplateResponse, err error)
	// GetOTPProvider GetOTPProvider retrieves a single OTP provider by ID.
	//
	// Returns all provider fields except credentials (has_credentials=true/false is returned instead).
	//
	// ## Errors
	// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
	GetOTPProvider(ctx context.Context, req *GetOTPProviderRequest, opts ...http.CallOption) (rsp *v1.GetOTPProviderResponse, err error)
	// GetOTPTemplate GetOTPTemplate retrieves a single OTP template by ID.
	//
	// Returns all template fields including review_status (for providers that require approval).
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	GetOTPTemplate(ctx context.Context, req *GetOTPTemplateRequest, opts ...http.CallOption) (rsp *v1.GetOTPTemplateResponse, err error)
	// ListOTPProviders ListOTPProviders lists OTP providers with optional filters and pagination.
	//
	// Supports filtering by country, provider_type, and enabled status.
	// Results are scoped to the operator specified in target_operator_context.
	// Returns paginated results with total count.
	ListOTPProviders(ctx context.Context, req *ListOTPProvidersRequest, opts ...http.CallOption) (rsp *v1.ListOTPProvidersResponse, err error)
	// ListOTPSendLogs ListOTPSendLogs queries OTP delivery history for auditing, debugging, or statistics.
	//
	// Each log records: who sent what, to whom, via which provider/template/channel,
	// and whether it succeeded or failed. Logs are immutable (append-only).
	//
	// ## Filters
	//   - user_id: filter by the end-user who triggered the OTP
	//   - channel_used: filter by delivery channel ("sms", "whatsapp", "voice", "email")
	//   - status: filter by delivery status ("sent", "failed")
	//   - start_time / end_time: time range filter (Unix milliseconds)
	//
	// ## Use cases
	//   - Debug a user's OTP delivery failure: filter by user_id + status="failed"
	//   - Audit all WhatsApp OTPs in the last 24h: filter by channel_used + time range
	//   - Monitor delivery success rate: aggregate by status over a time range
	ListOTPSendLogs(ctx context.Context, req *ListOTPSendLogsRequest, opts ...http.CallOption) (rsp *v1.ListOTPSendLogsResponse, err error)
	// ListOTPTemplates ListOTPTemplates lists OTP templates with optional filters and pagination.
	//
	// Supports filtering by country, provider_id, template_type, and enabled status.
	// Results are scoped to the operator specified in target_operator_context.
	// Returns paginated results with total count.
	ListOTPTemplates(ctx context.Context, req *ListOTPTemplatesRequest, opts ...http.CallOption) (rsp *v1.ListOTPTemplatesResponse, err error)
	// SyncOTPTemplateStatus SyncOTPTemplateStatus pulls the latest review status from the external provider.
	//
	// Some providers (e.g., EngageLab WhatsApp) require templates to be reviewed and approved
	// before they can be used. This RPC calls the provider's API to check the current status
	// and updates the local record's review_status field.
	//
	// ## Review status values (provider-specific)
	// EngageLab: 0=pending, 1=approved, 2=rejected
	//
	// ## When to call?
	// After creating a new WhatsApp template on the provider's platform, call this periodically
	// until the status changes to "approved". SMS templates typically don't require review.
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	// - SEND_OTP_FAILED: failed to query the provider's API (credentials invalid, network error, etc.)
	SyncOTPTemplateStatus(ctx context.Context, req *SyncOTPTemplateStatusRequest, opts ...http.CallOption) (rsp *v1.SyncOTPTemplateStatusResponse, err error)
	// UpdateOTPProvider UpdateOTPProvider partially updates an existing OTP provider.
	//
	// Only fields present in the request are updated; omitted fields remain unchanged.
	// After update, the provider routing cache is invalidated so changes take effect immediately.
	//
	// Common use cases:
	//   - Rotate credentials: set credentials_json with new keys
	//   - Disable a provider temporarily: set enabled=false (routing will skip it)
	//   - Change channel strategy: e.g., switch from WhatsApp-first to SMS-only
	//
	// ## Errors
	// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
	UpdateOTPProvider(ctx context.Context, req *UpdateOTPProviderRequest, opts ...http.CallOption) (rsp *v1.UpdateOTPProviderResponse, err error)
	// UpdateOTPTemplate UpdateOTPTemplate partially updates an existing OTP template.
	//
	// Only fields present in the request are updated; omitted fields remain unchanged.
	// After update, the template routing cache is invalidated so changes take effect immediately.
	//
	// Common use cases:
	//   - Switch to a new external template: set external_template_id
	//   - Update the brand name displayed in OTP messages: set brand_name
	//   - Disable a template temporarily: set enabled=false
	//
	// ## Errors
	// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
	UpdateOTPTemplate(ctx context.Context, req *UpdateOTPTemplateRequest, opts ...http.CallOption) (rsp *v1.UpdateOTPTemplateResponse, err error)
}

type BackofficeOTPHTTPClientImpl struct {
	cc *http.Client
}

func NewBackofficeOTPHTTPClient(client *http.Client) BackofficeOTPHTTPClient {
	return &BackofficeOTPHTTPClientImpl{client}
}

// CreateOTPProvider CreateOTPProvider registers a third-party OTP delivery provider for an operator + country.
//
// ## What is an OTP Provider?
// A Provider is a connection to a third-party service (e.g., EngageLab) that can
// deliver OTP codes via SMS, WhatsApp, or Voice. Each record stores:
//   - The provider's API credentials (encrypted at rest, never returned in responses)
//   - Which delivery channels to use and in what order (send_channel_strategy)
//   - A priority for fallback routing when multiple providers exist
//
// ## When to use this API?
// Call this when onboarding a new operator or expanding to a new country. For example:
//   - Operator "BetBrazil" wants to send OTP via WhatsApp in Brazil → create a provider
//     with country="BR", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS
//   - Same operator wants a global SMS fallback → create another provider with
//     country="global", provider_type=OTP_PROVIDER_TYPE_ENGAGELAB,
//     send_channel_strategy=OTP_SEND_CHANNEL_STRATEGY_SMS
//
// ## How does routing work?
// When user-service calls SendOTP for a phone number, push-service resolves the provider
// using this fallback chain (first match wins):
//   1. (operator_id, user's country, enabled=true) ORDER BY priority ASC
//   2. (operator_id, "global",       enabled=true) ORDER BY priority ASC
//   3. (system_operator_id, user's country, enabled=true) ORDER BY priority ASC
//   4. (system_operator_id, "global",       enabled=true) ORDER BY priority ASC
// This means: operator-specific config is preferred; "global" is the fallback;
// system-level config provides a safety net for operators that haven't configured anything.
//
// ## Example request body (HTTP POST /v1/backoffice/otp/provider/create)
//   {
//     "target_operator_context": { "operator_id": 1001 },
//     "country": "BR",
//     "provider_type": "OTP_PROVIDER_TYPE_ENGAGELAB",
//     "name": "EngageLab Brazil",
//     "enabled": true,
//     "priority": 0,
//     "credentials_json": "{\"dev_key\":\"your_key\",\"dev_secret\":\"your_secret\"}",
//     "config": "{}",
//     "send_channel_strategy": "OTP_SEND_CHANNEL_STRATEGY_WHATSAPP_SMS"
//   }
//
// ## Response
// Returns the created provider info (with has_credentials=true instead of actual credentials).
//
// ## Errors
// - SEND_OTP_NO_PROVIDER: credentials_json is missing or invalid
// - OTP_PROVIDER_ALREADY_EXISTS (if UNIQUE constraint violated): same operator+country+provider_type
func (c *BackofficeOTPHTTPClientImpl) CreateOTPProvider(ctx context.Context, in *CreateOTPProviderRequest, opts ...http.CallOption) (*v1.CreateOTPProviderResponse, error) {
	var out v1.CreateOTPProviderResponse
	pattern := "/v1/backoffice/otp/provider/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPCreateOTPProvider))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// CreateOTPTemplate CreateOTPTemplate creates a message template bound to a specific OTP provider.
//
// ## What is an OTP Template?
// A Template defines the message content sent to the end-user. It is bound to a
// specific OTP Provider (created via CreateOTPProvider). Each template is scoped
// to a business scenario (template_type) such as login, registration, or withdrawal.
//
// ## What is external_template_id?
// This is the template ID assigned by the third-party provider (e.g., EngageLab).
// You must first create the template on the provider's platform, then copy the ID here.
//
// ### How to get it (EngageLab):
//   1. Log in to EngageLab console → OTP → Template Management
//   2. Create a new template (choose SMS or WhatsApp channel)
//   3. After creation (and approval for WhatsApp), copy the template ID
//   4. Use that ID as external_template_id when calling this API
//
// When SendOTP is triggered, the system passes this ID to the provider's API
// so the provider knows which pre-approved message template to use.
//
// ## How does template routing work?
// When user-service calls SendOTP, push-service resolves the template using this
// fallback chain (first match wins, per operator level):
//   For each level: operator → company → retailer → system (skip if ID=0):
//     1. (operator_id, country, template_type, language)
//     2. (operator_id, country, template_type, "en")
//     3. (operator_id, "global", template_type, language)
//     4. (operator_id, "global", template_type, "en")
//
// ## Example request body (HTTP POST /v1/backoffice/otp/template/create)
//   {
//     "target_operator_context": { "operator_id": 1001 },
//     "country": "BR",
//     "provider_id": 166153951194906625,
//     "name": "Brazil Login OTP",
//     "template_type": "OTP_TEMPLATE_TYPE_LOGIN_OTP",
//     "external_template_id": "T001",
//     "language": "pt",
//     "brand_name": "BetBrazil",
//     "code_length": 6,
//     "code_ttl_seconds": 300,
//     "extra_params": "{}",
//     "enabled": true
//   }
//
// ## Constraints
// - UNIQUE(operator_id, country, template_type, language): one template per scenario+language
// - provider_id must reference an existing OTP provider
// - external_template_id is required for SMS/WhatsApp providers (the provider needs it to send)
func (c *BackofficeOTPHTTPClientImpl) CreateOTPTemplate(ctx context.Context, in *CreateOTPTemplateRequest, opts ...http.CallOption) (*v1.CreateOTPTemplateResponse, error) {
	var out v1.CreateOTPTemplateResponse
	pattern := "/v1/backoffice/otp/template/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPCreateOTPTemplate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteOTPProvider DeleteOTPProvider permanently removes an OTP provider.
//
// WARNING: Deleting a provider that still has templates bound to it will cause
// those templates to become orphaned — they will still match during routing but
// fail at send time because the provider credentials are gone.
// Best practice: delete all associated templates first, or disable the provider instead.
//
// ## Errors
// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
func (c *BackofficeOTPHTTPClientImpl) DeleteOTPProvider(ctx context.Context, in *DeleteOTPProviderRequest, opts ...http.CallOption) (*v1.DeleteOTPProviderResponse, error) {
	var out v1.DeleteOTPProviderResponse
	pattern := "/v1/backoffice/otp/provider/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPDeleteOTPProvider))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteOTPTemplate DeleteOTPTemplate permanently removes an OTP template.
//
// If the deleted template was the only match for a given operator+country+type+language,
// the system will fall back to the next level in the routing chain (e.g., company → retailer → system).
// If no template matches at all, SendOTP will return an OTP_TEMPLATE_NOT_FOUND error.
//
// ## Errors
// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
func (c *BackofficeOTPHTTPClientImpl) DeleteOTPTemplate(ctx context.Context, in *DeleteOTPTemplateRequest, opts ...http.CallOption) (*v1.DeleteOTPTemplateResponse, error) {
	var out v1.DeleteOTPTemplateResponse
	pattern := "/v1/backoffice/otp/template/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPDeleteOTPTemplate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetOTPProvider GetOTPProvider retrieves a single OTP provider by ID.
//
// Returns all provider fields except credentials (has_credentials=true/false is returned instead).
//
// ## Errors
// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
func (c *BackofficeOTPHTTPClientImpl) GetOTPProvider(ctx context.Context, in *GetOTPProviderRequest, opts ...http.CallOption) (*v1.GetOTPProviderResponse, error) {
	var out v1.GetOTPProviderResponse
	pattern := "/v1/backoffice/otp/provider/get"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPGetOTPProvider))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetOTPTemplate GetOTPTemplate retrieves a single OTP template by ID.
//
// Returns all template fields including review_status (for providers that require approval).
//
// ## Errors
// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
func (c *BackofficeOTPHTTPClientImpl) GetOTPTemplate(ctx context.Context, in *GetOTPTemplateRequest, opts ...http.CallOption) (*v1.GetOTPTemplateResponse, error) {
	var out v1.GetOTPTemplateResponse
	pattern := "/v1/backoffice/otp/template/get"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPGetOTPTemplate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListOTPProviders ListOTPProviders lists OTP providers with optional filters and pagination.
//
// Supports filtering by country, provider_type, and enabled status.
// Results are scoped to the operator specified in target_operator_context.
// Returns paginated results with total count.
func (c *BackofficeOTPHTTPClientImpl) ListOTPProviders(ctx context.Context, in *ListOTPProvidersRequest, opts ...http.CallOption) (*v1.ListOTPProvidersResponse, error) {
	var out v1.ListOTPProvidersResponse
	pattern := "/v1/backoffice/otp/provider/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPListOTPProviders))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListOTPSendLogs ListOTPSendLogs queries OTP delivery history for auditing, debugging, or statistics.
//
// Each log records: who sent what, to whom, via which provider/template/channel,
// and whether it succeeded or failed. Logs are immutable (append-only).
//
// ## Filters
//   - user_id: filter by the end-user who triggered the OTP
//   - channel_used: filter by delivery channel ("sms", "whatsapp", "voice", "email")
//   - status: filter by delivery status ("sent", "failed")
//   - start_time / end_time: time range filter (Unix milliseconds)
//
// ## Use cases
//   - Debug a user's OTP delivery failure: filter by user_id + status="failed"
//   - Audit all WhatsApp OTPs in the last 24h: filter by channel_used + time range
//   - Monitor delivery success rate: aggregate by status over a time range
func (c *BackofficeOTPHTTPClientImpl) ListOTPSendLogs(ctx context.Context, in *ListOTPSendLogsRequest, opts ...http.CallOption) (*v1.ListOTPSendLogsResponse, error) {
	var out v1.ListOTPSendLogsResponse
	pattern := "/v1/backoffice/otp/send-logs/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPListOTPSendLogs))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListOTPTemplates ListOTPTemplates lists OTP templates with optional filters and pagination.
//
// Supports filtering by country, provider_id, template_type, and enabled status.
// Results are scoped to the operator specified in target_operator_context.
// Returns paginated results with total count.
func (c *BackofficeOTPHTTPClientImpl) ListOTPTemplates(ctx context.Context, in *ListOTPTemplatesRequest, opts ...http.CallOption) (*v1.ListOTPTemplatesResponse, error) {
	var out v1.ListOTPTemplatesResponse
	pattern := "/v1/backoffice/otp/template/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPListOTPTemplates))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SyncOTPTemplateStatus SyncOTPTemplateStatus pulls the latest review status from the external provider.
//
// Some providers (e.g., EngageLab WhatsApp) require templates to be reviewed and approved
// before they can be used. This RPC calls the provider's API to check the current status
// and updates the local record's review_status field.
//
// ## Review status values (provider-specific)
// EngageLab: 0=pending, 1=approved, 2=rejected
//
// ## When to call?
// After creating a new WhatsApp template on the provider's platform, call this periodically
// until the status changes to "approved". SMS templates typically don't require review.
//
// ## Errors
// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
// - SEND_OTP_FAILED: failed to query the provider's API (credentials invalid, network error, etc.)
func (c *BackofficeOTPHTTPClientImpl) SyncOTPTemplateStatus(ctx context.Context, in *SyncOTPTemplateStatusRequest, opts ...http.CallOption) (*v1.SyncOTPTemplateStatusResponse, error) {
	var out v1.SyncOTPTemplateStatusResponse
	pattern := "/v1/backoffice/otp/template/sync-status"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPSyncOTPTemplateStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateOTPProvider UpdateOTPProvider partially updates an existing OTP provider.
//
// Only fields present in the request are updated; omitted fields remain unchanged.
// After update, the provider routing cache is invalidated so changes take effect immediately.
//
// Common use cases:
//   - Rotate credentials: set credentials_json with new keys
//   - Disable a provider temporarily: set enabled=false (routing will skip it)
//   - Change channel strategy: e.g., switch from WhatsApp-first to SMS-only
//
// ## Errors
// - OTP_PROVIDER_NOT_FOUND: no provider with the given ID
func (c *BackofficeOTPHTTPClientImpl) UpdateOTPProvider(ctx context.Context, in *UpdateOTPProviderRequest, opts ...http.CallOption) (*v1.UpdateOTPProviderResponse, error) {
	var out v1.UpdateOTPProviderResponse
	pattern := "/v1/backoffice/otp/provider/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPUpdateOTPProvider))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// UpdateOTPTemplate UpdateOTPTemplate partially updates an existing OTP template.
//
// Only fields present in the request are updated; omitted fields remain unchanged.
// After update, the template routing cache is invalidated so changes take effect immediately.
//
// Common use cases:
//   - Switch to a new external template: set external_template_id
//   - Update the brand name displayed in OTP messages: set brand_name
//   - Disable a template temporarily: set enabled=false
//
// ## Errors
// - OTP_TEMPLATE_NOT_FOUND: no template with the given ID
func (c *BackofficeOTPHTTPClientImpl) UpdateOTPTemplate(ctx context.Context, in *UpdateOTPTemplateRequest, opts ...http.CallOption) (*v1.UpdateOTPTemplateResponse, error) {
	var out v1.UpdateOTPTemplateResponse
	pattern := "/v1/backoffice/otp/template/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBackofficeOTPUpdateOTPTemplate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
