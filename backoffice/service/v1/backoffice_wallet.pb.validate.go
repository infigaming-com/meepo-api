// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: backoffice/service/v1/backoffice_wallet.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetWalletsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetWalletsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletsRequestMultiError, or nil if none found.
func (m *GetWalletsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if len(errors) > 0 {
		return GetWalletsRequestMultiError(errors)
	}

	return nil
}

// GetWalletsRequestMultiError is an error wrapping multiple validation errors
// returned by GetWalletsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetWalletsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletsRequestMultiError) AllErrors() []error { return m }

// GetWalletsRequestValidationError is the validation error returned by
// GetWalletsRequest.Validate if the designated constraints aren't met.
type GetWalletsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletsRequestValidationError) ErrorName() string {
	return "GetWalletsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletsRequestValidationError{}

// Validate checks the field values on GetWalletCreditsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletCreditsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletCreditsRequestMultiError, or nil if none found.
func (m *GetWalletCreditsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletCreditsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletCreditsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletCreditsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletCreditsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletCreditsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletCreditsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return GetWalletCreditsRequestMultiError(errors)
	}

	return nil
}

// GetWalletCreditsRequestMultiError is an error wrapping multiple validation
// errors returned by GetWalletCreditsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWalletCreditsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditsRequestMultiError) AllErrors() []error { return m }

// GetWalletCreditsRequestValidationError is the validation error returned by
// GetWalletCreditsRequest.Validate if the designated constraints aren't met.
type GetWalletCreditsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditsRequestValidationError) ErrorName() string {
	return "GetWalletCreditsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditsRequestValidationError{}

// Validate checks the field values on GetWalletCreditsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletCreditsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletCreditsResponseMultiError, or nil if none found.
func (m *GetWalletCreditsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCredits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletCreditsResponseValidationError{
						field:  fmt.Sprintf("Credits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletCreditsResponseValidationError{
						field:  fmt.Sprintf("Credits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletCreditsResponseValidationError{
					field:  fmt.Sprintf("Credits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return GetWalletCreditsResponseMultiError(errors)
	}

	return nil
}

// GetWalletCreditsResponseMultiError is an error wrapping multiple validation
// errors returned by GetWalletCreditsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetWalletCreditsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditsResponseMultiError) AllErrors() []error { return m }

// GetWalletCreditsResponseValidationError is the validation error returned by
// GetWalletCreditsResponse.Validate if the designated constraints aren't met.
type GetWalletCreditsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditsResponseValidationError) ErrorName() string {
	return "GetWalletCreditsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditsResponseValidationError{}

// Validate checks the field values on ListWalletBalanceTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListWalletBalanceTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletBalanceTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListWalletBalanceTransactionsRequestMultiError, or nil if none found.
func (m *ListWalletBalanceTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceTransactionsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceTransactionsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListWalletBalanceTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListWalletBalanceTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletBalanceTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListWalletBalanceTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceTransactionsRequestMultiError) AllErrors() []error { return m }

// ListWalletBalanceTransactionsRequestValidationError is the validation error
// returned by ListWalletBalanceTransactionsRequest.Validate if the designated
// constraints aren't met.
type ListWalletBalanceTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceTransactionsRequestValidationError) ErrorName() string {
	return "ListWalletBalanceTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceTransactionsRequestValidationError{}

// Validate checks the field values on ListWalletBalanceTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListWalletBalanceTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletBalanceTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListWalletBalanceTransactionsResponseMultiError, or nil if none found.
func (m *ListWalletBalanceTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBalanceTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceTransactionsResponseValidationError{
					field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListWalletBalanceTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListWalletBalanceTransactionsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListWalletBalanceTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListWalletBalanceTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceTransactionsResponseMultiError) AllErrors() []error { return m }

// ListWalletBalanceTransactionsResponseValidationError is the validation error
// returned by ListWalletBalanceTransactionsResponse.Validate if the
// designated constraints aren't met.
type ListWalletBalanceTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceTransactionsResponseValidationError) ErrorName() string {
	return "ListWalletBalanceTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceTransactionsResponseValidationError{}

// Validate checks the field values on GetWalletCreditTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetWalletCreditTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetWalletCreditTransactionsRequestMultiError, or nil if none found.
func (m *GetWalletCreditTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreditId

	if len(errors) > 0 {
		return GetWalletCreditTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetWalletCreditTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetWalletCreditTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWalletCreditTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditTransactionsRequestMultiError) AllErrors() []error { return m }

// GetWalletCreditTransactionsRequestValidationError is the validation error
// returned by GetWalletCreditTransactionsRequest.Validate if the designated
// constraints aren't met.
type GetWalletCreditTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditTransactionsRequestValidationError) ErrorName() string {
	return "GetWalletCreditTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditTransactionsRequestValidationError{}

// Validate checks the field values on GetWalletCreditTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetWalletCreditTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetWalletCreditTransactionsResponseMultiError, or nil if none found.
func (m *GetWalletCreditTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCreditTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletCreditTransactionsResponseValidationError{
						field:  fmt.Sprintf("CreditTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletCreditTransactionsResponseValidationError{
						field:  fmt.Sprintf("CreditTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletCreditTransactionsResponseValidationError{
					field:  fmt.Sprintf("CreditTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return GetWalletCreditTransactionsResponseMultiError(errors)
	}

	return nil
}

// GetWalletCreditTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetWalletCreditTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetWalletCreditTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditTransactionsResponseMultiError) AllErrors() []error { return m }

// GetWalletCreditTransactionsResponseValidationError is the validation error
// returned by GetWalletCreditTransactionsResponse.Validate if the designated
// constraints aren't met.
type GetWalletCreditTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditTransactionsResponseValidationError) ErrorName() string {
	return "GetWalletCreditTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditTransactionsResponseValidationError{}

// Validate checks the field values on UpdateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateWalletRequestMultiError, or nil if none found.
func (m *UpdateWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return UpdateWalletRequestMultiError(errors)
	}

	return nil
}

// UpdateWalletRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateWalletRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletRequestMultiError) AllErrors() []error { return m }

// UpdateWalletRequestValidationError is the validation error returned by
// UpdateWalletRequest.Validate if the designated constraints aren't met.
type UpdateWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletRequestValidationError) ErrorName() string {
	return "UpdateWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletRequestValidationError{}

// Validate checks the field values on UpdateWalletResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateWalletResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateWalletResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateWalletResponseMultiError, or nil if none found.
func (m *UpdateWalletResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateWalletResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateWalletResponseMultiError(errors)
	}

	return nil
}

// UpdateWalletResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateWalletResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateWalletResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletResponseMultiError) AllErrors() []error { return m }

// UpdateWalletResponseValidationError is the validation error returned by
// UpdateWalletResponse.Validate if the designated constraints aren't met.
type UpdateWalletResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletResponseValidationError) ErrorName() string {
	return "UpdateWalletResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletResponseValidationError{}

// Validate checks the field values on WalletCurrency with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WalletCurrency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletCurrency with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WalletCurrencyMultiError,
// or nil if none found.
func (m *WalletCurrency) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletCurrency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Enabled

	// no validation rules for Hidden

	// no validation rules for Type

	// no validation rules for Symbol

	// no validation rules for Icon

	// no validation rules for DecimalPlaces

	if len(errors) > 0 {
		return WalletCurrencyMultiError(errors)
	}

	return nil
}

// WalletCurrencyMultiError is an error wrapping multiple validation errors
// returned by WalletCurrency.ValidateAll() if the designated constraints
// aren't met.
type WalletCurrencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletCurrencyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletCurrencyMultiError) AllErrors() []error { return m }

// WalletCurrencyValidationError is the validation error returned by
// WalletCurrency.Validate if the designated constraints aren't met.
type WalletCurrencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletCurrencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletCurrencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletCurrencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletCurrencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletCurrencyValidationError) ErrorName() string { return "WalletCurrencyValidationError" }

// Error satisfies the builtin error interface
func (e WalletCurrencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletCurrency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletCurrencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletCurrencyValidationError{}

// Validate checks the field values on AddWalletCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddWalletCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddWalletCurrencyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddWalletCurrencyRequestMultiError, or nil if none found.
func (m *AddWalletCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddWalletCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Enabled

	// no validation rules for Hidden

	// no validation rules for Type

	// no validation rules for Symbol

	// no validation rules for Icon

	// no validation rules for DecimalPlaces

	// no validation rules for CurrencyDecimalPlaces

	if len(errors) > 0 {
		return AddWalletCurrencyRequestMultiError(errors)
	}

	return nil
}

// AddWalletCurrencyRequestMultiError is an error wrapping multiple validation
// errors returned by AddWalletCurrencyRequest.ValidateAll() if the designated
// constraints aren't met.
type AddWalletCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddWalletCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddWalletCurrencyRequestMultiError) AllErrors() []error { return m }

// AddWalletCurrencyRequestValidationError is the validation error returned by
// AddWalletCurrencyRequest.Validate if the designated constraints aren't met.
type AddWalletCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddWalletCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddWalletCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddWalletCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddWalletCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddWalletCurrencyRequestValidationError) ErrorName() string {
	return "AddWalletCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddWalletCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddWalletCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddWalletCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddWalletCurrencyRequestValidationError{}

// Validate checks the field values on AddWalletCurrencyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddWalletCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddWalletCurrencyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddWalletCurrencyResponseMultiError, or nil if none found.
func (m *AddWalletCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddWalletCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddWalletCurrencyResponseMultiError(errors)
	}

	return nil
}

// AddWalletCurrencyResponseMultiError is an error wrapping multiple validation
// errors returned by AddWalletCurrencyResponse.ValidateAll() if the
// designated constraints aren't met.
type AddWalletCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddWalletCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddWalletCurrencyResponseMultiError) AllErrors() []error { return m }

// AddWalletCurrencyResponseValidationError is the validation error returned by
// AddWalletCurrencyResponse.Validate if the designated constraints aren't met.
type AddWalletCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddWalletCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddWalletCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddWalletCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddWalletCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddWalletCurrencyResponseValidationError) ErrorName() string {
	return "AddWalletCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddWalletCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddWalletCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddWalletCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddWalletCurrencyResponseValidationError{}

// Validate checks the field values on ListWalletCurrenciesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletCurrenciesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletCurrenciesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletCurrenciesRequestMultiError, or nil if none found.
func (m *ListWalletCurrenciesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletCurrenciesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if len(errors) > 0 {
		return ListWalletCurrenciesRequestMultiError(errors)
	}

	return nil
}

// ListWalletCurrenciesRequestMultiError is an error wrapping multiple
// validation errors returned by ListWalletCurrenciesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListWalletCurrenciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletCurrenciesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletCurrenciesRequestMultiError) AllErrors() []error { return m }

// ListWalletCurrenciesRequestValidationError is the validation error returned
// by ListWalletCurrenciesRequest.Validate if the designated constraints
// aren't met.
type ListWalletCurrenciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletCurrenciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletCurrenciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletCurrenciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletCurrenciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletCurrenciesRequestValidationError) ErrorName() string {
	return "ListWalletCurrenciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletCurrenciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletCurrenciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletCurrenciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletCurrenciesRequestValidationError{}

// Validate checks the field values on ListWalletCurrenciesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletCurrenciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletCurrenciesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletCurrenciesResponseMultiError, or nil if none found.
func (m *ListWalletCurrenciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletCurrenciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCurrencies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletCurrenciesResponseValidationError{
					field:  fmt.Sprintf("Currencies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for TotalEnabled

	// no validation rules for TotalHidden

	if len(errors) > 0 {
		return ListWalletCurrenciesResponseMultiError(errors)
	}

	return nil
}

// ListWalletCurrenciesResponseMultiError is an error wrapping multiple
// validation errors returned by ListWalletCurrenciesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListWalletCurrenciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletCurrenciesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletCurrenciesResponseMultiError) AllErrors() []error { return m }

// ListWalletCurrenciesResponseValidationError is the validation error returned
// by ListWalletCurrenciesResponse.Validate if the designated constraints
// aren't met.
type ListWalletCurrenciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletCurrenciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletCurrenciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletCurrenciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletCurrenciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletCurrenciesResponseValidationError) ErrorName() string {
	return "ListWalletCurrenciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletCurrenciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletCurrenciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletCurrenciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletCurrenciesResponseValidationError{}

// Validate checks the field values on UpdateWalletCurrencyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateWalletCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateWalletCurrencyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateWalletCurrencyRequestMultiError, or nil if none found.
func (m *UpdateWalletCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateWalletCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Symbol != nil {
		// no validation rules for Symbol
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.DecimalPlaces != nil {
		// no validation rules for DecimalPlaces
	}

	if m.CurrencyDecimalPlaces != nil {
		// no validation rules for CurrencyDecimalPlaces
	}

	if len(errors) > 0 {
		return UpdateWalletCurrencyRequestMultiError(errors)
	}

	return nil
}

// UpdateWalletCurrencyRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateWalletCurrencyRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateWalletCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletCurrencyRequestMultiError) AllErrors() []error { return m }

// UpdateWalletCurrencyRequestValidationError is the validation error returned
// by UpdateWalletCurrencyRequest.Validate if the designated constraints
// aren't met.
type UpdateWalletCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletCurrencyRequestValidationError) ErrorName() string {
	return "UpdateWalletCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletCurrencyRequestValidationError{}

// Validate checks the field values on UpdateWalletCurrencyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateWalletCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateWalletCurrencyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateWalletCurrencyResponseMultiError, or nil if none found.
func (m *UpdateWalletCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateWalletCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateWalletCurrencyResponseValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateWalletCurrencyResponseValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateWalletCurrencyResponseValidationError{
				field:  "Currency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateWalletCurrencyResponseMultiError(errors)
	}

	return nil
}

// UpdateWalletCurrencyResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateWalletCurrencyResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateWalletCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletCurrencyResponseMultiError) AllErrors() []error { return m }

// UpdateWalletCurrencyResponseValidationError is the validation error returned
// by UpdateWalletCurrencyResponse.Validate if the designated constraints
// aren't met.
type UpdateWalletCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletCurrencyResponseValidationError) ErrorName() string {
	return "UpdateWalletCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletCurrencyResponseValidationError{}

// Validate checks the field values on ListOperatorBalancesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOperatorBalancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOperatorBalancesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOperatorBalancesRequestMultiError, or nil if none found.
func (m *ListOperatorBalancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorBalancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOperatorBalancesRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOperatorBalancesRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOperatorBalancesRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListOperatorBalancesRequestMultiError(errors)
	}

	return nil
}

// ListOperatorBalancesRequestMultiError is an error wrapping multiple
// validation errors returned by ListOperatorBalancesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListOperatorBalancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorBalancesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorBalancesRequestMultiError) AllErrors() []error { return m }

// ListOperatorBalancesRequestValidationError is the validation error returned
// by ListOperatorBalancesRequest.Validate if the designated constraints
// aren't met.
type ListOperatorBalancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorBalancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorBalancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorBalancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorBalancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorBalancesRequestValidationError) ErrorName() string {
	return "ListOperatorBalancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorBalancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorBalancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorBalancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorBalancesRequestValidationError{}

// Validate checks the field values on GetExchangeRatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExchangeRatesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExchangeRatesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExchangeRatesRequestMultiError, or nil if none found.
func (m *GetExchangeRatesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExchangeRatesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetExchangeRatesRequestMultiError(errors)
	}

	return nil
}

// GetExchangeRatesRequestMultiError is an error wrapping multiple validation
// errors returned by GetExchangeRatesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetExchangeRatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExchangeRatesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExchangeRatesRequestMultiError) AllErrors() []error { return m }

// GetExchangeRatesRequestValidationError is the validation error returned by
// GetExchangeRatesRequest.Validate if the designated constraints aren't met.
type GetExchangeRatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExchangeRatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExchangeRatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExchangeRatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExchangeRatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExchangeRatesRequestValidationError) ErrorName() string {
	return "GetExchangeRatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExchangeRatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExchangeRatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExchangeRatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExchangeRatesRequestValidationError{}

// Validate checks the field values on GetExchangeRatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExchangeRatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExchangeRatesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExchangeRatesResponseMultiError, or nil if none found.
func (m *GetExchangeRatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExchangeRatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExchangeRates

	if len(errors) > 0 {
		return GetExchangeRatesResponseMultiError(errors)
	}

	return nil
}

// GetExchangeRatesResponseMultiError is an error wrapping multiple validation
// errors returned by GetExchangeRatesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetExchangeRatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExchangeRatesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExchangeRatesResponseMultiError) AllErrors() []error { return m }

// GetExchangeRatesResponseValidationError is the validation error returned by
// GetExchangeRatesResponse.Validate if the designated constraints aren't met.
type GetExchangeRatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExchangeRatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExchangeRatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExchangeRatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExchangeRatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExchangeRatesResponseValidationError) ErrorName() string {
	return "GetExchangeRatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetExchangeRatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExchangeRatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExchangeRatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExchangeRatesResponseValidationError{}

// Validate checks the field values on OperatorTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorTransferRequestMultiError, or nil if none found.
func (m *OperatorTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorTransferRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorTransferRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorTransferRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for CashAmount

	if len(errors) > 0 {
		return OperatorTransferRequestMultiError(errors)
	}

	return nil
}

// OperatorTransferRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorTransferRequestMultiError) AllErrors() []error { return m }

// OperatorTransferRequestValidationError is the validation error returned by
// OperatorTransferRequest.Validate if the designated constraints aren't met.
type OperatorTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorTransferRequestValidationError) ErrorName() string {
	return "OperatorTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorTransferRequestValidationError{}

// Validate checks the field values on OperatorTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorTransferResponseMultiError, or nil if none found.
func (m *OperatorTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OperatorCash

	// no validation rules for OperatorBalanceCurrency

	// no validation rules for TargetOperatorCash

	// no validation rules for TargetOperatorBalanceCurrency

	if len(errors) > 0 {
		return OperatorTransferResponseMultiError(errors)
	}

	return nil
}

// OperatorTransferResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorTransferResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorTransferResponseMultiError) AllErrors() []error { return m }

// OperatorTransferResponseValidationError is the validation error returned by
// OperatorTransferResponse.Validate if the designated constraints aren't met.
type OperatorTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorTransferResponseValidationError) ErrorName() string {
	return "OperatorTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorTransferResponseValidationError{}

// Validate checks the field values on OperatorSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorSwapRequestMultiError, or nil if none found.
func (m *OperatorSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSwapRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSwapRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for TargetCurrency

	// no validation rules for CashAmount

	if len(errors) > 0 {
		return OperatorSwapRequestMultiError(errors)
	}

	return nil
}

// OperatorSwapRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSwapRequestMultiError) AllErrors() []error { return m }

// OperatorSwapRequestValidationError is the validation error returned by
// OperatorSwapRequest.Validate if the designated constraints aren't met.
type OperatorSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSwapRequestValidationError) ErrorName() string {
	return "OperatorSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSwapRequestValidationError{}

// Validate checks the field values on OperatorSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorSwapResponseMultiError, or nil if none found.
func (m *OperatorSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrencyBalanceCash

	// no validation rules for CurrencyBalanceCashUsd

	// no validation rules for CurrencyBalanceCashReportingCurrency

	// no validation rules for TargetCurrencyBalanceCash

	// no validation rules for TargetCurrencyBalanceCashUsd

	// no validation rules for TargetCurrencyBalanceCashReportingCurrency

	if len(errors) > 0 {
		return OperatorSwapResponseMultiError(errors)
	}

	return nil
}

// OperatorSwapResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSwapResponseMultiError) AllErrors() []error { return m }

// OperatorSwapResponseValidationError is the validation error returned by
// OperatorSwapResponse.Validate if the designated constraints aren't met.
type OperatorSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSwapResponseValidationError) ErrorName() string {
	return "OperatorSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSwapResponseValidationError{}

// Validate checks the field values on OperatorBalanceFreezeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceFreezeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceFreezeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorBalanceFreezeRequestMultiError, or nil if none found.
func (m *OperatorBalanceFreezeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceFreezeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceFreezeRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceFreezeRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceFreezeRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for CashAmount

	// no validation rules for Memo

	if len(errors) > 0 {
		return OperatorBalanceFreezeRequestMultiError(errors)
	}

	return nil
}

// OperatorBalanceFreezeRequestMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceFreezeRequest.ValidateAll() if
// the designated constraints aren't met.
type OperatorBalanceFreezeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceFreezeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceFreezeRequestMultiError) AllErrors() []error { return m }

// OperatorBalanceFreezeRequestValidationError is the validation error returned
// by OperatorBalanceFreezeRequest.Validate if the designated constraints
// aren't met.
type OperatorBalanceFreezeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceFreezeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceFreezeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceFreezeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceFreezeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceFreezeRequestValidationError) ErrorName() string {
	return "OperatorBalanceFreezeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceFreezeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceFreezeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceFreezeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceFreezeRequestValidationError{}

// Validate checks the field values on OperatorBalanceFreezeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceFreezeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceFreezeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperatorBalanceFreezeResponseMultiError, or nil if none found.
func (m *OperatorBalanceFreezeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceFreezeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	if len(errors) > 0 {
		return OperatorBalanceFreezeResponseMultiError(errors)
	}

	return nil
}

// OperatorBalanceFreezeResponseMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceFreezeResponse.ValidateAll()
// if the designated constraints aren't met.
type OperatorBalanceFreezeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceFreezeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceFreezeResponseMultiError) AllErrors() []error { return m }

// OperatorBalanceFreezeResponseValidationError is the validation error
// returned by OperatorBalanceFreezeResponse.Validate if the designated
// constraints aren't met.
type OperatorBalanceFreezeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceFreezeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceFreezeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceFreezeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceFreezeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceFreezeResponseValidationError) ErrorName() string {
	return "OperatorBalanceFreezeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceFreezeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceFreezeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceFreezeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceFreezeResponseValidationError{}

// Validate checks the field values on OperatorBalanceRollbackRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceRollbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceRollbackRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperatorBalanceRollbackRequestMultiError, or nil if none found.
func (m *OperatorBalanceRollbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceRollbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceRollbackRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceRollbackRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceRollbackRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OriginalTransactionId

	// no validation rules for Memo

	if len(errors) > 0 {
		return OperatorBalanceRollbackRequestMultiError(errors)
	}

	return nil
}

// OperatorBalanceRollbackRequestMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceRollbackRequest.ValidateAll()
// if the designated constraints aren't met.
type OperatorBalanceRollbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceRollbackRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceRollbackRequestMultiError) AllErrors() []error { return m }

// OperatorBalanceRollbackRequestValidationError is the validation error
// returned by OperatorBalanceRollbackRequest.Validate if the designated
// constraints aren't met.
type OperatorBalanceRollbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceRollbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceRollbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceRollbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceRollbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceRollbackRequestValidationError) ErrorName() string {
	return "OperatorBalanceRollbackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceRollbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceRollbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceRollbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceRollbackRequestValidationError{}

// Validate checks the field values on OperatorBalanceRollbackResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceRollbackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceRollbackResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperatorBalanceRollbackResponseMultiError, or nil if none found.
func (m *OperatorBalanceRollbackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceRollbackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	// no validation rules for CashAmount

	// no validation rules for CashAmountUsd

	// no validation rules for CashAmountReportingCurrency

	if len(errors) > 0 {
		return OperatorBalanceRollbackResponseMultiError(errors)
	}

	return nil
}

// OperatorBalanceRollbackResponseMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceRollbackResponse.ValidateAll()
// if the designated constraints aren't met.
type OperatorBalanceRollbackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceRollbackResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceRollbackResponseMultiError) AllErrors() []error { return m }

// OperatorBalanceRollbackResponseValidationError is the validation error
// returned by OperatorBalanceRollbackResponse.Validate if the designated
// constraints aren't met.
type OperatorBalanceRollbackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceRollbackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceRollbackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceRollbackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceRollbackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceRollbackResponseValidationError) ErrorName() string {
	return "OperatorBalanceRollbackResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceRollbackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceRollbackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceRollbackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceRollbackResponseValidationError{}

// Validate checks the field values on OperatorBalanceSettleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceSettleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceSettleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorBalanceSettleRequestMultiError, or nil if none found.
func (m *OperatorBalanceSettleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceSettleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceSettleRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceSettleRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceSettleRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for OriginalTransactionId

	// no validation rules for Memo

	if len(errors) > 0 {
		return OperatorBalanceSettleRequestMultiError(errors)
	}

	return nil
}

// OperatorBalanceSettleRequestMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceSettleRequest.ValidateAll() if
// the designated constraints aren't met.
type OperatorBalanceSettleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceSettleRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceSettleRequestMultiError) AllErrors() []error { return m }

// OperatorBalanceSettleRequestValidationError is the validation error returned
// by OperatorBalanceSettleRequest.Validate if the designated constraints
// aren't met.
type OperatorBalanceSettleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceSettleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceSettleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceSettleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceSettleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceSettleRequestValidationError) ErrorName() string {
	return "OperatorBalanceSettleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceSettleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceSettleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceSettleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceSettleRequestValidationError{}

// Validate checks the field values on OperatorBalanceSettleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceSettleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceSettleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// OperatorBalanceSettleResponseMultiError, or nil if none found.
func (m *OperatorBalanceSettleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceSettleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	// no validation rules for CashAmount

	// no validation rules for CashAmountUsd

	// no validation rules for CashAmountReportingCurrency

	if len(errors) > 0 {
		return OperatorBalanceSettleResponseMultiError(errors)
	}

	return nil
}

// OperatorBalanceSettleResponseMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceSettleResponse.ValidateAll()
// if the designated constraints aren't met.
type OperatorBalanceSettleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceSettleResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceSettleResponseMultiError) AllErrors() []error { return m }

// OperatorBalanceSettleResponseValidationError is the validation error
// returned by OperatorBalanceSettleResponse.Validate if the designated
// constraints aren't met.
type OperatorBalanceSettleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceSettleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceSettleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceSettleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceSettleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceSettleResponseValidationError) ErrorName() string {
	return "OperatorBalanceSettleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceSettleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceSettleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceSettleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceSettleResponseValidationError{}

// Validate checks the field values on ListOperatorBalanceTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListOperatorBalanceTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListOperatorBalanceTransactionsRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListOperatorBalanceTransactionsRequestMultiError, or nil if none found.
func (m *ListOperatorBalanceTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorBalanceTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOperatorBalanceTransactionsRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TargetOperatorType

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorBalanceTransactionsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorBalanceTransactionsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListOperatorBalanceTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListOperatorBalanceTransactionsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListOperatorBalanceTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListOperatorBalanceTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorBalanceTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorBalanceTransactionsRequestMultiError) AllErrors() []error { return m }

// ListOperatorBalanceTransactionsRequestValidationError is the validation
// error returned by ListOperatorBalanceTransactionsRequest.Validate if the
// designated constraints aren't met.
type ListOperatorBalanceTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorBalanceTransactionsRequestValidationError) ErrorName() string {
	return "ListOperatorBalanceTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorBalanceTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorBalanceTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorBalanceTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorBalanceTransactionsRequestValidationError{}

// Validate checks the field values on OperatorBalanceTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorBalanceTransactionMultiError, or nil if none found.
func (m *OperatorBalanceTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceTransactionValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RetailerOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for OperatorName

	// no validation rules for SettlementCurrency

	// no validation rules for BeforeBalance

	// no validation rules for AfterBalance

	// no validation rules for CashAmount

	// no validation rules for TransactionType

	// no validation rules for Status

	// no validation rules for Memo

	// no validation rules for FeeAmount

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceTransactionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperatorBalanceTransactionMultiError(errors)
	}

	return nil
}

// OperatorBalanceTransactionMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceTransaction.ValidateAll() if
// the designated constraints aren't met.
type OperatorBalanceTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceTransactionMultiError) AllErrors() []error { return m }

// OperatorBalanceTransactionValidationError is the validation error returned
// by OperatorBalanceTransaction.Validate if the designated constraints aren't met.
type OperatorBalanceTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceTransactionValidationError) ErrorName() string {
	return "OperatorBalanceTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceTransactionValidationError{}

// Validate checks the field values on ListOperatorBalanceTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListOperatorBalanceTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListOperatorBalanceTransactionsResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListOperatorBalanceTransactionsResponseMultiError, or nil if none found.
func (m *ListOperatorBalanceTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorBalanceTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorBalanceTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListOperatorBalanceTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListOperatorBalanceTransactionsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListOperatorBalanceTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListOperatorBalanceTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorBalanceTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorBalanceTransactionsResponseMultiError) AllErrors() []error { return m }

// ListOperatorBalanceTransactionsResponseValidationError is the validation
// error returned by ListOperatorBalanceTransactionsResponse.Validate if the
// designated constraints aren't met.
type ListOperatorBalanceTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorBalanceTransactionsResponseValidationError) ErrorName() string {
	return "ListOperatorBalanceTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorBalanceTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorBalanceTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorBalanceTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorBalanceTransactionsResponseValidationError{}

// Validate checks the field values on UpdateOperatorBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOperatorBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOperatorBalanceRequestMultiError, or nil if none found.
func (m *UpdateOperatorBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorBalanceRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorBalanceRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorBalanceRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateOperatorBalanceRequestMultiError(errors)
	}

	return nil
}

// UpdateOperatorBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateOperatorBalanceRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateOperatorBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorBalanceRequestMultiError) AllErrors() []error { return m }

// UpdateOperatorBalanceRequestValidationError is the validation error returned
// by UpdateOperatorBalanceRequest.Validate if the designated constraints
// aren't met.
type UpdateOperatorBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorBalanceRequestValidationError) ErrorName() string {
	return "UpdateOperatorBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorBalanceRequestValidationError{}

// Validate checks the field values on UpdateOperatorBalanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOperatorBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorBalanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateOperatorBalanceResponseMultiError, or nil if none found.
func (m *UpdateOperatorBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateOperatorBalanceResponseMultiError(errors)
	}

	return nil
}

// UpdateOperatorBalanceResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateOperatorBalanceResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateOperatorBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorBalanceResponseMultiError) AllErrors() []error { return m }

// UpdateOperatorBalanceResponseValidationError is the validation error
// returned by UpdateOperatorBalanceResponse.Validate if the designated
// constraints aren't met.
type UpdateOperatorBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorBalanceResponseValidationError) ErrorName() string {
	return "UpdateOperatorBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorBalanceResponseValidationError{}

// Validate checks the field values on SetDepositRewardSequencesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SetDepositRewardSequencesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDepositRewardSequencesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetDepositRewardSequencesRequestMultiError, or nil if none found.
func (m *SetDepositRewardSequencesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDepositRewardSequencesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDepositRewardSequencesRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	for idx, item := range m.GetWelcomeRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetDepositRewardSequencesRequestValidationError{
					field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDailyRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetDepositRewardSequencesRequestValidationError{
					field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FollowParent != nil {
		// no validation rules for FollowParent
	}

	if m.WelcomeRewardEnabled != nil {
		// no validation rules for WelcomeRewardEnabled
	}

	if m.DailyRewardEnabled != nil {
		// no validation rules for DailyRewardEnabled
	}

	if len(errors) > 0 {
		return SetDepositRewardSequencesRequestMultiError(errors)
	}

	return nil
}

// SetDepositRewardSequencesRequestMultiError is an error wrapping multiple
// validation errors returned by
// SetDepositRewardSequencesRequest.ValidateAll() if the designated
// constraints aren't met.
type SetDepositRewardSequencesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDepositRewardSequencesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDepositRewardSequencesRequestMultiError) AllErrors() []error { return m }

// SetDepositRewardSequencesRequestValidationError is the validation error
// returned by SetDepositRewardSequencesRequest.Validate if the designated
// constraints aren't met.
type SetDepositRewardSequencesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDepositRewardSequencesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDepositRewardSequencesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDepositRewardSequencesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDepositRewardSequencesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDepositRewardSequencesRequestValidationError) ErrorName() string {
	return "SetDepositRewardSequencesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetDepositRewardSequencesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDepositRewardSequencesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDepositRewardSequencesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDepositRewardSequencesRequestValidationError{}

// Validate checks the field values on DeleteDepositRewardSequencesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteDepositRewardSequencesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDepositRewardSequencesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteDepositRewardSequencesRequestMultiError, or nil if none found.
func (m *DeleteDepositRewardSequencesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDepositRewardSequencesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDepositRewardSequencesRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	for idx, item := range m.GetWelcomeRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDepositRewardSequencesRequestValidationError{
					field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDailyRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteDepositRewardSequencesRequestValidationError{
					field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteDepositRewardSequencesRequestMultiError(errors)
	}

	return nil
}

// DeleteDepositRewardSequencesRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteDepositRewardSequencesRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDepositRewardSequencesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDepositRewardSequencesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDepositRewardSequencesRequestMultiError) AllErrors() []error { return m }

// DeleteDepositRewardSequencesRequestValidationError is the validation error
// returned by DeleteDepositRewardSequencesRequest.Validate if the designated
// constraints aren't met.
type DeleteDepositRewardSequencesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDepositRewardSequencesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDepositRewardSequencesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDepositRewardSequencesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDepositRewardSequencesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDepositRewardSequencesRequestValidationError) ErrorName() string {
	return "DeleteDepositRewardSequencesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDepositRewardSequencesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDepositRewardSequencesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDepositRewardSequencesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDepositRewardSequencesRequestValidationError{}

// Validate checks the field values on GetDepositRewardConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDepositRewardConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepositRewardConfigRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDepositRewardConfigRequestMultiError, or nil if none found.
func (m *GetDepositRewardConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepositRewardConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	if len(errors) > 0 {
		return GetDepositRewardConfigRequestMultiError(errors)
	}

	return nil
}

// GetDepositRewardConfigRequestMultiError is an error wrapping multiple
// validation errors returned by GetDepositRewardConfigRequest.ValidateAll()
// if the designated constraints aren't met.
type GetDepositRewardConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepositRewardConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepositRewardConfigRequestMultiError) AllErrors() []error { return m }

// GetDepositRewardConfigRequestValidationError is the validation error
// returned by GetDepositRewardConfigRequest.Validate if the designated
// constraints aren't met.
type GetDepositRewardConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepositRewardConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepositRewardConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepositRewardConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepositRewardConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepositRewardConfigRequestValidationError) ErrorName() string {
	return "GetDepositRewardConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDepositRewardConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepositRewardConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepositRewardConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepositRewardConfigRequestValidationError{}

// Validate checks the field values on GetGamificationCurrencyConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetGamificationCurrencyConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGamificationCurrencyConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetGamificationCurrencyConfigRequestMultiError, or nil if none found.
func (m *GetGamificationCurrencyConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGamificationCurrencyConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGamificationCurrencyConfigRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetGamificationCurrencyConfigRequestMultiError(errors)
	}

	return nil
}

// GetGamificationCurrencyConfigRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetGamificationCurrencyConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type GetGamificationCurrencyConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGamificationCurrencyConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGamificationCurrencyConfigRequestMultiError) AllErrors() []error { return m }

// GetGamificationCurrencyConfigRequestValidationError is the validation error
// returned by GetGamificationCurrencyConfigRequest.Validate if the designated
// constraints aren't met.
type GetGamificationCurrencyConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGamificationCurrencyConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGamificationCurrencyConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGamificationCurrencyConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGamificationCurrencyConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGamificationCurrencyConfigRequestValidationError) ErrorName() string {
	return "GetGamificationCurrencyConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetGamificationCurrencyConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGamificationCurrencyConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGamificationCurrencyConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGamificationCurrencyConfigRequestValidationError{}

// Validate checks the field values on UpdateOperatorCurrencyConfigRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateOperatorCurrencyConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorCurrencyConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateOperatorCurrencyConfigRequestMultiError, or nil if none found.
func (m *UpdateOperatorCurrencyConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorCurrencyConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorCurrencyConfigRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorCurrencyConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "OperatorCurrencyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "OperatorCurrencyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorCurrencyConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorCurrencyConfigRequestValidationError{
				field:  "OperatorCurrencyConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateOperatorCurrencyConfigRequestMultiError(errors)
	}

	return nil
}

// UpdateOperatorCurrencyConfigRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateOperatorCurrencyConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateOperatorCurrencyConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorCurrencyConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorCurrencyConfigRequestMultiError) AllErrors() []error { return m }

// UpdateOperatorCurrencyConfigRequestValidationError is the validation error
// returned by UpdateOperatorCurrencyConfigRequest.Validate if the designated
// constraints aren't met.
type UpdateOperatorCurrencyConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorCurrencyConfigRequestValidationError) ErrorName() string {
	return "UpdateOperatorCurrencyConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorCurrencyConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorCurrencyConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorCurrencyConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorCurrencyConfigRequestValidationError{}

// Validate checks the field values on UpdateDeductionOrderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeductionOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeductionOrderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeductionOrderRequestMultiError, or nil if none found.
func (m *UpdateDeductionOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeductionOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeductionOrderRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeductionOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "DeductionOrder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "DeductionOrder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeductionOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeductionOrderRequestValidationError{
				field:  "DeductionOrder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDeductionOrderRequestMultiError(errors)
	}

	return nil
}

// UpdateDeductionOrderRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDeductionOrderRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDeductionOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeductionOrderRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeductionOrderRequestMultiError) AllErrors() []error { return m }

// UpdateDeductionOrderRequestValidationError is the validation error returned
// by UpdateDeductionOrderRequest.Validate if the designated constraints
// aren't met.
type UpdateDeductionOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeductionOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeductionOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeductionOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeductionOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeductionOrderRequestValidationError) ErrorName() string {
	return "UpdateDeductionOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeductionOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeductionOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeductionOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeductionOrderRequestValidationError{}

// Validate checks the field values on
// DeleteWalletResponsibleGamblingConfigRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteWalletResponsibleGamblingConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteWalletResponsibleGamblingConfigRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeleteWalletResponsibleGamblingConfigRequestMultiError, or nil if none found.
func (m *DeleteWalletResponsibleGamblingConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteWalletResponsibleGamblingConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for LimitType

	if len(errors) > 0 {
		return DeleteWalletResponsibleGamblingConfigRequestMultiError(errors)
	}

	return nil
}

// DeleteWalletResponsibleGamblingConfigRequestMultiError is an error wrapping
// multiple validation errors returned by
// DeleteWalletResponsibleGamblingConfigRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteWalletResponsibleGamblingConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteWalletResponsibleGamblingConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteWalletResponsibleGamblingConfigRequestMultiError) AllErrors() []error { return m }

// DeleteWalletResponsibleGamblingConfigRequestValidationError is the
// validation error returned by
// DeleteWalletResponsibleGamblingConfigRequest.Validate if the designated
// constraints aren't met.
type DeleteWalletResponsibleGamblingConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteWalletResponsibleGamblingConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteWalletResponsibleGamblingConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteWalletResponsibleGamblingConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteWalletResponsibleGamblingConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteWalletResponsibleGamblingConfigRequestValidationError) ErrorName() string {
	return "DeleteWalletResponsibleGamblingConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteWalletResponsibleGamblingConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteWalletResponsibleGamblingConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteWalletResponsibleGamblingConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteWalletResponsibleGamblingConfigRequestValidationError{}

// Validate checks the field values on
// ListWalletResponsibleGamblingConfigsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListWalletResponsibleGamblingConfigsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListWalletResponsibleGamblingConfigsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListWalletResponsibleGamblingConfigsRequestMultiError, or nil if none found.
func (m *ListWalletResponsibleGamblingConfigsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletResponsibleGamblingConfigsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if len(errors) > 0 {
		return ListWalletResponsibleGamblingConfigsRequestMultiError(errors)
	}

	return nil
}

// ListWalletResponsibleGamblingConfigsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListWalletResponsibleGamblingConfigsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListWalletResponsibleGamblingConfigsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletResponsibleGamblingConfigsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletResponsibleGamblingConfigsRequestMultiError) AllErrors() []error { return m }

// ListWalletResponsibleGamblingConfigsRequestValidationError is the validation
// error returned by ListWalletResponsibleGamblingConfigsRequest.Validate if
// the designated constraints aren't met.
type ListWalletResponsibleGamblingConfigsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletResponsibleGamblingConfigsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletResponsibleGamblingConfigsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletResponsibleGamblingConfigsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletResponsibleGamblingConfigsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletResponsibleGamblingConfigsRequestValidationError) ErrorName() string {
	return "ListWalletResponsibleGamblingConfigsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletResponsibleGamblingConfigsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletResponsibleGamblingConfigsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletResponsibleGamblingConfigsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletResponsibleGamblingConfigsRequestValidationError{}

// Validate checks the field values on ListCustomerRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCustomerRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCustomerRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCustomerRecordsRequestMultiError, or nil if none found.
func (m *ListCustomerRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCustomerRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCustomerRecordsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCustomerRecordsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCustomerRecordsRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCustomerRecordsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCustomerRecordsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCustomerRecordsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCustomerRecordsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCustomerRecordsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCustomerRecordsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListCustomerRecordsRequestMultiError(errors)
	}

	return nil
}

// ListCustomerRecordsRequestMultiError is an error wrapping multiple
// validation errors returned by ListCustomerRecordsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListCustomerRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCustomerRecordsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCustomerRecordsRequestMultiError) AllErrors() []error { return m }

// ListCustomerRecordsRequestValidationError is the validation error returned
// by ListCustomerRecordsRequest.Validate if the designated constraints aren't met.
type ListCustomerRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCustomerRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCustomerRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCustomerRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCustomerRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCustomerRecordsRequestValidationError) ErrorName() string {
	return "ListCustomerRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCustomerRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCustomerRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCustomerRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCustomerRecordsRequestValidationError{}

// Validate checks the field values on ExportCustomerRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportCustomerRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportCustomerRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportCustomerRecordsRequestMultiError, or nil if none found.
func (m *ExportCustomerRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportCustomerRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Format

	// no validation rules for TimeZone

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportCustomerRecordsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportCustomerRecordsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportCustomerRecordsRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExportCustomerRecordsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExportCustomerRecordsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExportCustomerRecordsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExportCustomerRecordsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExportCustomerRecordsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExportCustomerRecordsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if len(errors) > 0 {
		return ExportCustomerRecordsRequestMultiError(errors)
	}

	return nil
}

// ExportCustomerRecordsRequestMultiError is an error wrapping multiple
// validation errors returned by ExportCustomerRecordsRequest.ValidateAll() if
// the designated constraints aren't met.
type ExportCustomerRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportCustomerRecordsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportCustomerRecordsRequestMultiError) AllErrors() []error { return m }

// ExportCustomerRecordsRequestValidationError is the validation error returned
// by ExportCustomerRecordsRequest.Validate if the designated constraints
// aren't met.
type ExportCustomerRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportCustomerRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportCustomerRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportCustomerRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportCustomerRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportCustomerRecordsRequestValidationError) ErrorName() string {
	return "ExportCustomerRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportCustomerRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportCustomerRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportCustomerRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportCustomerRecordsRequestValidationError{}

// Validate checks the field values on SetFICAThresholdConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetFICAThresholdConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetFICAThresholdConfigRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetFICAThresholdConfigRequestMultiError, or nil if none found.
func (m *SetFICAThresholdConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetFICAThresholdConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetFicaThresholdConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetFICAThresholdConfigRequestValidationError{
					field:  "FicaThresholdConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetFICAThresholdConfigRequestValidationError{
					field:  "FicaThresholdConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFicaThresholdConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetFICAThresholdConfigRequestValidationError{
				field:  "FicaThresholdConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetFICAThresholdConfigRequestMultiError(errors)
	}

	return nil
}

// SetFICAThresholdConfigRequestMultiError is an error wrapping multiple
// validation errors returned by SetFICAThresholdConfigRequest.ValidateAll()
// if the designated constraints aren't met.
type SetFICAThresholdConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetFICAThresholdConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetFICAThresholdConfigRequestMultiError) AllErrors() []error { return m }

// SetFICAThresholdConfigRequestValidationError is the validation error
// returned by SetFICAThresholdConfigRequest.Validate if the designated
// constraints aren't met.
type SetFICAThresholdConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetFICAThresholdConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetFICAThresholdConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetFICAThresholdConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetFICAThresholdConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetFICAThresholdConfigRequestValidationError) ErrorName() string {
	return "SetFICAThresholdConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetFICAThresholdConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetFICAThresholdConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetFICAThresholdConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetFICAThresholdConfigRequestValidationError{}

// Validate checks the field values on GetFICAThresholdConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFICAThresholdConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFICAThresholdConfigRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetFICAThresholdConfigRequestMultiError, or nil if none found.
func (m *GetFICAThresholdConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFICAThresholdConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetFICAThresholdConfigRequestMultiError(errors)
	}

	return nil
}

// GetFICAThresholdConfigRequestMultiError is an error wrapping multiple
// validation errors returned by GetFICAThresholdConfigRequest.ValidateAll()
// if the designated constraints aren't met.
type GetFICAThresholdConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFICAThresholdConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFICAThresholdConfigRequestMultiError) AllErrors() []error { return m }

// GetFICAThresholdConfigRequestValidationError is the validation error
// returned by GetFICAThresholdConfigRequest.Validate if the designated
// constraints aren't met.
type GetFICAThresholdConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFICAThresholdConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFICAThresholdConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFICAThresholdConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFICAThresholdConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFICAThresholdConfigRequestValidationError) ErrorName() string {
	return "GetFICAThresholdConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFICAThresholdConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFICAThresholdConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFICAThresholdConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFICAThresholdConfigRequestValidationError{}

// Validate checks the field values on ListFICAThresholdTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListFICAThresholdTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFICAThresholdTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListFICAThresholdTransactionsRequestMultiError, or nil if none found.
func (m *ListFICAThresholdTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFICAThresholdTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFICAThresholdTransactionsRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFICAThresholdTransactionsRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFICAThresholdTransactionsRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFICAThresholdTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFICAThresholdTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFICAThresholdTransactionsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFICAThresholdTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFICAThresholdTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFICAThresholdTransactionsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.KycLevel != nil {
		// no validation rules for KycLevel
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListFICAThresholdTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListFICAThresholdTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListFICAThresholdTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListFICAThresholdTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFICAThresholdTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFICAThresholdTransactionsRequestMultiError) AllErrors() []error { return m }

// ListFICAThresholdTransactionsRequestValidationError is the validation error
// returned by ListFICAThresholdTransactionsRequest.Validate if the designated
// constraints aren't met.
type ListFICAThresholdTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFICAThresholdTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFICAThresholdTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFICAThresholdTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFICAThresholdTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFICAThresholdTransactionsRequestValidationError) ErrorName() string {
	return "ListFICAThresholdTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListFICAThresholdTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFICAThresholdTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFICAThresholdTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFICAThresholdTransactionsRequestValidationError{}

// Validate checks the field values on ExportFICAThresholdTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExportFICAThresholdTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExportFICAThresholdTransactionsRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ExportFICAThresholdTransactionsRequestMultiError, or nil if none found.
func (m *ExportFICAThresholdTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportFICAThresholdTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Format

	// no validation rules for TimeZone

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportFICAThresholdTransactionsRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportFICAThresholdTransactionsRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportFICAThresholdTransactionsRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExportFICAThresholdTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExportFICAThresholdTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExportFICAThresholdTransactionsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExportFICAThresholdTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExportFICAThresholdTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExportFICAThresholdTransactionsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.KycLevel != nil {
		// no validation rules for KycLevel
	}

	if len(errors) > 0 {
		return ExportFICAThresholdTransactionsRequestMultiError(errors)
	}

	return nil
}

// ExportFICAThresholdTransactionsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ExportFICAThresholdTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ExportFICAThresholdTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportFICAThresholdTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportFICAThresholdTransactionsRequestMultiError) AllErrors() []error { return m }

// ExportFICAThresholdTransactionsRequestValidationError is the validation
// error returned by ExportFICAThresholdTransactionsRequest.Validate if the
// designated constraints aren't met.
type ExportFICAThresholdTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportFICAThresholdTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportFICAThresholdTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportFICAThresholdTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportFICAThresholdTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportFICAThresholdTransactionsRequestValidationError) ErrorName() string {
	return "ExportFICAThresholdTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportFICAThresholdTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportFICAThresholdTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportFICAThresholdTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportFICAThresholdTransactionsRequestValidationError{}

// Validate checks the field values on GetWalletCreditsResponse_Credit with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletCreditsResponse_Credit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditsResponse_Credit with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetWalletCreditsResponse_CreditMultiError, or nil if none found.
func (m *GetWalletCreditsResponse_Credit) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditsResponse_Credit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletCreditsResponse_CreditValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletCreditsResponse_CreditValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletCreditsResponse_CreditValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreditId

	// no validation rules for Type

	// no validation rules for VipLevel

	// no validation rules for BeforeBlanace

	// no validation rules for AfterBalance

	// no validation rules for Currency

	if len(errors) > 0 {
		return GetWalletCreditsResponse_CreditMultiError(errors)
	}

	return nil
}

// GetWalletCreditsResponse_CreditMultiError is an error wrapping multiple
// validation errors returned by GetWalletCreditsResponse_Credit.ValidateAll()
// if the designated constraints aren't met.
type GetWalletCreditsResponse_CreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditsResponse_CreditMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditsResponse_CreditMultiError) AllErrors() []error { return m }

// GetWalletCreditsResponse_CreditValidationError is the validation error
// returned by GetWalletCreditsResponse_Credit.Validate if the designated
// constraints aren't met.
type GetWalletCreditsResponse_CreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditsResponse_CreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditsResponse_CreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditsResponse_CreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditsResponse_CreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditsResponse_CreditValidationError) ErrorName() string {
	return "GetWalletCreditsResponse_CreditValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditsResponse_CreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditsResponse_Credit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditsResponse_CreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditsResponse_CreditValidationError{}

// Validate checks the field values on
// ListWalletBalanceTransactionsResponse_BalanceTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletBalanceTransactionsResponse_BalanceTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListWalletBalanceTransactionsResponse_BalanceTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError, or nil
// if none found.
func (m *ListWalletBalanceTransactionsResponse_BalanceTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceTransactionsResponse_BalanceTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TransactionId

	// no validation rules for TransactionType

	// no validation rules for VipLevel

	// no validation rules for ChangeBalance

	// no validation rules for BeforeBalance

	// no validation rules for AfterBalance

	// no validation rules for Currency

	// no validation rules for RelatedTransactionId

	if len(errors) > 0 {
		return ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError(errors)
	}

	return nil
}

// ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError is an
// error wrapping multiple validation errors returned by
// ListWalletBalanceTransactionsResponse_BalanceTransaction.ValidateAll() if
// the designated constraints aren't met.
type ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError) AllErrors() []error {
	return m
}

// ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError is
// the validation error returned by
// ListWalletBalanceTransactionsResponse_BalanceTransaction.Validate if the
// designated constraints aren't met.
type ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) ErrorName() string {
	return "ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceTransactionsResponse_BalanceTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{}

// Validate checks the field values on
// GetWalletCreditTransactionsResponse_CreditTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletCreditTransactionsResponse_CreditTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetWalletCreditTransactionsResponse_CreditTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletCreditTransactionsResponse_CreditTransactionMultiError, or nil if
// none found.
func (m *GetWalletCreditTransactionsResponse_CreditTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditTransactionsResponse_CreditTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletCreditTransactionsResponse_CreditTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletCreditTransactionsResponse_CreditTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletCreditTransactionsResponse_CreditTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if len(errors) > 0 {
		return GetWalletCreditTransactionsResponse_CreditTransactionMultiError(errors)
	}

	return nil
}

// GetWalletCreditTransactionsResponse_CreditTransactionMultiError is an error
// wrapping multiple validation errors returned by
// GetWalletCreditTransactionsResponse_CreditTransaction.ValidateAll() if the
// designated constraints aren't met.
type GetWalletCreditTransactionsResponse_CreditTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditTransactionsResponse_CreditTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditTransactionsResponse_CreditTransactionMultiError) AllErrors() []error {
	return m
}

// GetWalletCreditTransactionsResponse_CreditTransactionValidationError is the
// validation error returned by
// GetWalletCreditTransactionsResponse_CreditTransaction.Validate if the
// designated constraints aren't met.
type GetWalletCreditTransactionsResponse_CreditTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) ErrorName() string {
	return "GetWalletCreditTransactionsResponse_CreditTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditTransactionsResponse_CreditTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditTransactionsResponse_CreditTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditTransactionsResponse_CreditTransactionValidationError{}
