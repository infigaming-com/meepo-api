// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: crm/service/v1/crm.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Segment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Segment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Segment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SegmentMultiError, or nil if none found.
func (m *Segment) ValidateAll() error {
	return m.validate(true)
}

func (m *Segment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SegmentKey

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Type

	// no validation rules for OwnerOperatorId

	// no validation rules for OwnerCompanyOperatorId

	// no validation rules for OwnerRetailerOperatorId

	// no validation rules for OwnerSystemOperatorId

	// no validation rules for OwnerLevel

	if all {
		switch v := interface{}(m.GetRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentValidationError{
				field:  "Rules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastCalculatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "LastCalculatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentValidationError{
					field:  "LastCalculatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCalculatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentValidationError{
				field:  "LastCalculatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserCount

	if len(errors) > 0 {
		return SegmentMultiError(errors)
	}

	return nil
}

// SegmentMultiError is an error wrapping multiple validation errors returned
// by Segment.ValidateAll() if the designated constraints aren't met.
type SegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentMultiError) AllErrors() []error { return m }

// SegmentValidationError is the validation error returned by Segment.Validate
// if the designated constraints aren't met.
type SegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentValidationError) ErrorName() string { return "SegmentValidationError" }

// Error satisfies the builtin error interface
func (e SegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentValidationError{}

// Validate checks the field values on SegmentUser with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SegmentUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentUser with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SegmentUserMultiError, or
// nil if none found.
func (m *SegmentUser) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SegmentId

	// no validation rules for UserId

	// no validation rules for OperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for SystemOperatorId

	if all {
		switch v := interface{}(m.GetEnteredAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentUserValidationError{
					field:  "EnteredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentUserValidationError{
					field:  "EnteredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnteredAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentUserValidationError{
				field:  "EnteredAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLeftAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentUserValidationError{
					field:  "LeftAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentUserValidationError{
					field:  "LeftAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeftAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentUserValidationError{
				field:  "LeftAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsMember

	if len(errors) > 0 {
		return SegmentUserMultiError(errors)
	}

	return nil
}

// SegmentUserMultiError is an error wrapping multiple validation errors
// returned by SegmentUser.ValidateAll() if the designated constraints aren't met.
type SegmentUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentUserMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentUserMultiError) AllErrors() []error { return m }

// SegmentUserValidationError is the validation error returned by
// SegmentUser.Validate if the designated constraints aren't met.
type SegmentUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentUserValidationError) ErrorName() string { return "SegmentUserValidationError" }

// Error satisfies the builtin error interface
func (e SegmentUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentUserValidationError{}

// Validate checks the field values on CreateSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSegmentRequestMultiError, or nil if none found.
func (m *CreateSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SegmentKey

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSegmentRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSegmentRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSegmentRequestValidationError{
				field:  "Rules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSegmentRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSegmentRequestMultiError(errors)
	}

	return nil
}

// CreateSegmentRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSegmentRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSegmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSegmentRequestMultiError) AllErrors() []error { return m }

// CreateSegmentRequestValidationError is the validation error returned by
// CreateSegmentRequest.Validate if the designated constraints aren't met.
type CreateSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSegmentRequestValidationError) ErrorName() string {
	return "CreateSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSegmentRequestValidationError{}

// Validate checks the field values on CreateSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSegmentResponseMultiError, or nil if none found.
func (m *CreateSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSegmentResponseValidationError{
				field:  "Segment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSegmentResponseMultiError(errors)
	}

	return nil
}

// CreateSegmentResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSegmentResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSegmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSegmentResponseMultiError) AllErrors() []error { return m }

// CreateSegmentResponseValidationError is the validation error returned by
// CreateSegmentResponse.Validate if the designated constraints aren't met.
type CreateSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSegmentResponseValidationError) ErrorName() string {
	return "CreateSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSegmentResponseValidationError{}

// Validate checks the field values on UpdateSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSegmentRequestMultiError, or nil if none found.
func (m *UpdateSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSegmentRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Rules != nil {

		if all {
			switch v := interface{}(m.GetRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateSegmentRequestValidationError{
						field:  "Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateSegmentRequestValidationError{
						field:  "Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateSegmentRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return UpdateSegmentRequestMultiError(errors)
	}

	return nil
}

// UpdateSegmentRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSegmentRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSegmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSegmentRequestMultiError) AllErrors() []error { return m }

// UpdateSegmentRequestValidationError is the validation error returned by
// UpdateSegmentRequest.Validate if the designated constraints aren't met.
type UpdateSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSegmentRequestValidationError) ErrorName() string {
	return "UpdateSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSegmentRequestValidationError{}

// Validate checks the field values on UpdateSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSegmentResponseMultiError, or nil if none found.
func (m *UpdateSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSegmentResponseValidationError{
				field:  "Segment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSegmentResponseMultiError(errors)
	}

	return nil
}

// UpdateSegmentResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateSegmentResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSegmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSegmentResponseMultiError) AllErrors() []error { return m }

// UpdateSegmentResponseValidationError is the validation error returned by
// UpdateSegmentResponse.Validate if the designated constraints aren't met.
type UpdateSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSegmentResponseValidationError) ErrorName() string {
	return "UpdateSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSegmentResponseValidationError{}

// Validate checks the field values on GetSegmentRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentRequestMultiError, or nil if none found.
func (m *GetSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSegmentRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSegmentRequestMultiError(errors)
	}

	return nil
}

// GetSegmentRequestMultiError is an error wrapping multiple validation errors
// returned by GetSegmentRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentRequestMultiError) AllErrors() []error { return m }

// GetSegmentRequestValidationError is the validation error returned by
// GetSegmentRequest.Validate if the designated constraints aren't met.
type GetSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentRequestValidationError) ErrorName() string {
	return "GetSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentRequestValidationError{}

// Validate checks the field values on GetSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentResponseMultiError, or nil if none found.
func (m *GetSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSegment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSegmentResponseValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSegmentResponseValidationError{
				field:  "Segment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSegmentResponseMultiError(errors)
	}

	return nil
}

// GetSegmentResponseMultiError is an error wrapping multiple validation errors
// returned by GetSegmentResponse.ValidateAll() if the designated constraints
// aren't met.
type GetSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentResponseMultiError) AllErrors() []error { return m }

// GetSegmentResponseValidationError is the validation error returned by
// GetSegmentResponse.Validate if the designated constraints aren't met.
type GetSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentResponseValidationError) ErrorName() string {
	return "GetSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentResponseValidationError{}

// Validate checks the field values on ListSegmentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSegmentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSegmentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSegmentsRequestMultiError, or nil if none found.
func (m *ListSegmentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSegmentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSegmentsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSegmentsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSegmentsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for IncludeInherited

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return ListSegmentsRequestMultiError(errors)
	}

	return nil
}

// ListSegmentsRequestMultiError is an error wrapping multiple validation
// errors returned by ListSegmentsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListSegmentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSegmentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSegmentsRequestMultiError) AllErrors() []error { return m }

// ListSegmentsRequestValidationError is the validation error returned by
// ListSegmentsRequest.Validate if the designated constraints aren't met.
type ListSegmentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSegmentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSegmentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSegmentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSegmentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSegmentsRequestValidationError) ErrorName() string {
	return "ListSegmentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSegmentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSegmentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSegmentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSegmentsRequestValidationError{}

// Validate checks the field values on ListSegmentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSegmentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSegmentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSegmentsResponseMultiError, or nil if none found.
func (m *ListSegmentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSegmentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSegments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSegmentsResponseValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSegmentsResponseValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSegmentsResponseValidationError{
					field:  fmt.Sprintf("Segments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListSegmentsResponseMultiError(errors)
	}

	return nil
}

// ListSegmentsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSegmentsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListSegmentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSegmentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSegmentsResponseMultiError) AllErrors() []error { return m }

// ListSegmentsResponseValidationError is the validation error returned by
// ListSegmentsResponse.Validate if the designated constraints aren't met.
type ListSegmentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSegmentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSegmentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSegmentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSegmentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSegmentsResponseValidationError) ErrorName() string {
	return "ListSegmentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSegmentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSegmentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSegmentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSegmentsResponseValidationError{}

// Validate checks the field values on DeleteSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSegmentRequestMultiError, or nil if none found.
func (m *DeleteSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteSegmentRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteSegmentRequestMultiError(errors)
	}

	return nil
}

// DeleteSegmentRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSegmentRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSegmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSegmentRequestMultiError) AllErrors() []error { return m }

// DeleteSegmentRequestValidationError is the validation error returned by
// DeleteSegmentRequest.Validate if the designated constraints aren't met.
type DeleteSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSegmentRequestValidationError) ErrorName() string {
	return "DeleteSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSegmentRequestValidationError{}

// Validate checks the field values on DeleteSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSegmentResponseMultiError, or nil if none found.
func (m *DeleteSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSegmentResponseMultiError(errors)
	}

	return nil
}

// DeleteSegmentResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteSegmentResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSegmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSegmentResponseMultiError) AllErrors() []error { return m }

// DeleteSegmentResponseValidationError is the validation error returned by
// DeleteSegmentResponse.Validate if the designated constraints aren't met.
type DeleteSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSegmentResponseValidationError) ErrorName() string {
	return "DeleteSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSegmentResponseValidationError{}

// Validate checks the field values on CalculateSegmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CalculateSegmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CalculateSegmentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CalculateSegmentRequestMultiError, or nil if none found.
func (m *CalculateSegmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CalculateSegmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CalculateSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CalculateSegmentRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CalculateSegmentRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CalculateSegmentRequestMultiError(errors)
	}

	return nil
}

// CalculateSegmentRequestMultiError is an error wrapping multiple validation
// errors returned by CalculateSegmentRequest.ValidateAll() if the designated
// constraints aren't met.
type CalculateSegmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateSegmentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateSegmentRequestMultiError) AllErrors() []error { return m }

// CalculateSegmentRequestValidationError is the validation error returned by
// CalculateSegmentRequest.Validate if the designated constraints aren't met.
type CalculateSegmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateSegmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateSegmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateSegmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateSegmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateSegmentRequestValidationError) ErrorName() string {
	return "CalculateSegmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateSegmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateSegmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateSegmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateSegmentRequestValidationError{}

// Validate checks the field values on CalculateSegmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CalculateSegmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CalculateSegmentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CalculateSegmentResponseMultiError, or nil if none found.
func (m *CalculateSegmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CalculateSegmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UsersMatched

	// no validation rules for UsersAdded

	// no validation rules for UsersRemoved

	if len(errors) > 0 {
		return CalculateSegmentResponseMultiError(errors)
	}

	return nil
}

// CalculateSegmentResponseMultiError is an error wrapping multiple validation
// errors returned by CalculateSegmentResponse.ValidateAll() if the designated
// constraints aren't met.
type CalculateSegmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateSegmentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateSegmentResponseMultiError) AllErrors() []error { return m }

// CalculateSegmentResponseValidationError is the validation error returned by
// CalculateSegmentResponse.Validate if the designated constraints aren't met.
type CalculateSegmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateSegmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateSegmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateSegmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateSegmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateSegmentResponseValidationError) ErrorName() string {
	return "CalculateSegmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateSegmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateSegmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateSegmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateSegmentResponseValidationError{}

// Validate checks the field values on GetSegmentUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentUsersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentUsersRequestMultiError, or nil if none found.
func (m *GetSegmentUsersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentUsersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SegmentId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSegmentUsersRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSegmentUsersRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSegmentUsersRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for OnlyCurrentMembers

	if len(errors) > 0 {
		return GetSegmentUsersRequestMultiError(errors)
	}

	return nil
}

// GetSegmentUsersRequestMultiError is an error wrapping multiple validation
// errors returned by GetSegmentUsersRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSegmentUsersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentUsersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentUsersRequestMultiError) AllErrors() []error { return m }

// GetSegmentUsersRequestValidationError is the validation error returned by
// GetSegmentUsersRequest.Validate if the designated constraints aren't met.
type GetSegmentUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentUsersRequestValidationError) ErrorName() string {
	return "GetSegmentUsersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentUsersRequestValidationError{}

// Validate checks the field values on GetSegmentUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentUsersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentUsersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentUsersResponseMultiError, or nil if none found.
func (m *GetSegmentUsersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentUsersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSegmentUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSegmentUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSegmentUsersResponseValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return GetSegmentUsersResponseMultiError(errors)
	}

	return nil
}

// GetSegmentUsersResponseMultiError is an error wrapping multiple validation
// errors returned by GetSegmentUsersResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSegmentUsersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentUsersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentUsersResponseMultiError) AllErrors() []error { return m }

// GetSegmentUsersResponseValidationError is the validation error returned by
// GetSegmentUsersResponse.Validate if the designated constraints aren't met.
type GetSegmentUsersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentUsersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentUsersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentUsersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentUsersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentUsersResponseValidationError) ErrorName() string {
	return "GetSegmentUsersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentUsersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentUsersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentUsersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentUsersResponseValidationError{}

// Validate checks the field values on GetUserSegmentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserSegmentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserSegmentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserSegmentsRequestMultiError, or nil if none found.
func (m *GetUserSegmentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserSegmentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserSegmentsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserSegmentsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserSegmentsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OnlyCurrentMemberships

	if len(errors) > 0 {
		return GetUserSegmentsRequestMultiError(errors)
	}

	return nil
}

// GetUserSegmentsRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserSegmentsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserSegmentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserSegmentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserSegmentsRequestMultiError) AllErrors() []error { return m }

// GetUserSegmentsRequestValidationError is the validation error returned by
// GetUserSegmentsRequest.Validate if the designated constraints aren't met.
type GetUserSegmentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserSegmentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserSegmentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserSegmentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserSegmentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserSegmentsRequestValidationError) ErrorName() string {
	return "GetUserSegmentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserSegmentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserSegmentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserSegmentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserSegmentsRequestValidationError{}

// Validate checks the field values on GetUserSegmentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserSegmentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserSegmentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserSegmentsResponseMultiError, or nil if none found.
func (m *GetUserSegmentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserSegmentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSegments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserSegmentsResponseValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserSegmentsResponseValidationError{
						field:  fmt.Sprintf("Segments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserSegmentsResponseValidationError{
					field:  fmt.Sprintf("Segments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserSegmentsResponseMultiError(errors)
	}

	return nil
}

// GetUserSegmentsResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserSegmentsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserSegmentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserSegmentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserSegmentsResponseMultiError) AllErrors() []error { return m }

// GetUserSegmentsResponseValidationError is the validation error returned by
// GetUserSegmentsResponse.Validate if the designated constraints aren't met.
type GetUserSegmentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserSegmentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserSegmentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserSegmentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserSegmentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserSegmentsResponseValidationError) ErrorName() string {
	return "GetUserSegmentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserSegmentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserSegmentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserSegmentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserSegmentsResponseValidationError{}

// Validate checks the field values on SetSegmentOverrideRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetSegmentOverrideRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSegmentOverrideRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetSegmentOverrideRequestMultiError, or nil if none found.
func (m *SetSegmentOverrideRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSegmentOverrideRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SegmentId

	// no validation rules for Disabled

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetSegmentOverrideRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetSegmentOverrideRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetSegmentOverrideRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetSegmentOverrideRequestMultiError(errors)
	}

	return nil
}

// SetSegmentOverrideRequestMultiError is an error wrapping multiple validation
// errors returned by SetSegmentOverrideRequest.ValidateAll() if the
// designated constraints aren't met.
type SetSegmentOverrideRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSegmentOverrideRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSegmentOverrideRequestMultiError) AllErrors() []error { return m }

// SetSegmentOverrideRequestValidationError is the validation error returned by
// SetSegmentOverrideRequest.Validate if the designated constraints aren't met.
type SetSegmentOverrideRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSegmentOverrideRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSegmentOverrideRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSegmentOverrideRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSegmentOverrideRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSegmentOverrideRequestValidationError) ErrorName() string {
	return "SetSegmentOverrideRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetSegmentOverrideRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSegmentOverrideRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSegmentOverrideRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSegmentOverrideRequestValidationError{}

// Validate checks the field values on SetSegmentOverrideResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetSegmentOverrideResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSegmentOverrideResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetSegmentOverrideResponseMultiError, or nil if none found.
func (m *SetSegmentOverrideResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSegmentOverrideResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetSegmentOverrideResponseMultiError(errors)
	}

	return nil
}

// SetSegmentOverrideResponseMultiError is an error wrapping multiple
// validation errors returned by SetSegmentOverrideResponse.ValidateAll() if
// the designated constraints aren't met.
type SetSegmentOverrideResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSegmentOverrideResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSegmentOverrideResponseMultiError) AllErrors() []error { return m }

// SetSegmentOverrideResponseValidationError is the validation error returned
// by SetSegmentOverrideResponse.Validate if the designated constraints aren't met.
type SetSegmentOverrideResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSegmentOverrideResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSegmentOverrideResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSegmentOverrideResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSegmentOverrideResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSegmentOverrideResponseValidationError) ErrorName() string {
	return "SetSegmentOverrideResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetSegmentOverrideResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSegmentOverrideResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSegmentOverrideResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSegmentOverrideResponseValidationError{}

// Validate checks the field values on GetSegmentOverrideRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentOverrideRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentOverrideRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentOverrideRequestMultiError, or nil if none found.
func (m *GetSegmentOverrideRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentOverrideRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SegmentId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSegmentOverrideRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSegmentOverrideRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSegmentOverrideRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSegmentOverrideRequestMultiError(errors)
	}

	return nil
}

// GetSegmentOverrideRequestMultiError is an error wrapping multiple validation
// errors returned by GetSegmentOverrideRequest.ValidateAll() if the
// designated constraints aren't met.
type GetSegmentOverrideRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentOverrideRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentOverrideRequestMultiError) AllErrors() []error { return m }

// GetSegmentOverrideRequestValidationError is the validation error returned by
// GetSegmentOverrideRequest.Validate if the designated constraints aren't met.
type GetSegmentOverrideRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentOverrideRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentOverrideRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentOverrideRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentOverrideRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentOverrideRequestValidationError) ErrorName() string {
	return "GetSegmentOverrideRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentOverrideRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentOverrideRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentOverrideRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentOverrideRequestValidationError{}

// Validate checks the field values on GetSegmentOverrideResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentOverrideResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentOverrideResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentOverrideResponseMultiError, or nil if none found.
func (m *GetSegmentOverrideResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentOverrideResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Disabled

	// no validation rules for HasOverride

	if len(errors) > 0 {
		return GetSegmentOverrideResponseMultiError(errors)
	}

	return nil
}

// GetSegmentOverrideResponseMultiError is an error wrapping multiple
// validation errors returned by GetSegmentOverrideResponse.ValidateAll() if
// the designated constraints aren't met.
type GetSegmentOverrideResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentOverrideResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentOverrideResponseMultiError) AllErrors() []error { return m }

// GetSegmentOverrideResponseValidationError is the validation error returned
// by GetSegmentOverrideResponse.Validate if the designated constraints aren't met.
type GetSegmentOverrideResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentOverrideResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentOverrideResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentOverrideResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentOverrideResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentOverrideResponseValidationError) ErrorName() string {
	return "GetSegmentOverrideResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentOverrideResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentOverrideResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentOverrideResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentOverrideResponseValidationError{}

// Validate checks the field values on FieldSchema with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldSchema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldSchema with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldSchemaMultiError, or
// nil if none found.
func (m *FieldSchema) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldSchema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Field

	// no validation rules for Label

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValueSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FieldSchemaValidationError{
					field:  "ValueSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FieldSchemaValidationError{
					field:  "ValueSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValueSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FieldSchemaValidationError{
				field:  "ValueSchema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FieldSchemaMultiError(errors)
	}

	return nil
}

// FieldSchemaMultiError is an error wrapping multiple validation errors
// returned by FieldSchema.ValidateAll() if the designated constraints aren't met.
type FieldSchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldSchemaMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldSchemaMultiError) AllErrors() []error { return m }

// FieldSchemaValidationError is the validation error returned by
// FieldSchema.Validate if the designated constraints aren't met.
type FieldSchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldSchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldSchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldSchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldSchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldSchemaValidationError) ErrorName() string { return "FieldSchemaValidationError" }

// Error satisfies the builtin error interface
func (e FieldSchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldSchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldSchemaValidationError{}

// Validate checks the field values on GetSegmentFieldSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentFieldSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentFieldSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSegmentFieldSchemaRequestMultiError, or nil if none found.
func (m *GetSegmentFieldSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentFieldSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return GetSegmentFieldSchemaRequestMultiError(errors)
	}

	return nil
}

// GetSegmentFieldSchemaRequestMultiError is an error wrapping multiple
// validation errors returned by GetSegmentFieldSchemaRequest.ValidateAll() if
// the designated constraints aren't met.
type GetSegmentFieldSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentFieldSchemaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentFieldSchemaRequestMultiError) AllErrors() []error { return m }

// GetSegmentFieldSchemaRequestValidationError is the validation error returned
// by GetSegmentFieldSchemaRequest.Validate if the designated constraints
// aren't met.
type GetSegmentFieldSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentFieldSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentFieldSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentFieldSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentFieldSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentFieldSchemaRequestValidationError) ErrorName() string {
	return "GetSegmentFieldSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentFieldSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentFieldSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentFieldSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentFieldSchemaRequestValidationError{}

// Validate checks the field values on GetSegmentFieldSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSegmentFieldSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSegmentFieldSchemaResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSegmentFieldSchemaResponseMultiError, or nil if none found.
func (m *GetSegmentFieldSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSegmentFieldSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSegmentFieldSchemaResponseValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSegmentFieldSchemaResponseValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSegmentFieldSchemaResponseValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSegmentFieldSchemaResponseMultiError(errors)
	}

	return nil
}

// GetSegmentFieldSchemaResponseMultiError is an error wrapping multiple
// validation errors returned by GetSegmentFieldSchemaResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSegmentFieldSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSegmentFieldSchemaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSegmentFieldSchemaResponseMultiError) AllErrors() []error { return m }

// GetSegmentFieldSchemaResponseValidationError is the validation error
// returned by GetSegmentFieldSchemaResponse.Validate if the designated
// constraints aren't met.
type GetSegmentFieldSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSegmentFieldSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSegmentFieldSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSegmentFieldSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSegmentFieldSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSegmentFieldSchemaResponseValidationError) ErrorName() string {
	return "GetSegmentFieldSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSegmentFieldSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSegmentFieldSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSegmentFieldSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSegmentFieldSchemaResponseValidationError{}
