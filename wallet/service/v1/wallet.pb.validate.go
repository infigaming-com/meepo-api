// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: wallet/service/v1/wallet.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetUserBalancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserBalancesRequestMultiError, or nil if none found.
func (m *GetUserBalancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if len(errors) > 0 {
		return GetUserBalancesRequestMultiError(errors)
	}

	return nil
}

// GetUserBalancesRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserBalancesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserBalancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalancesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalancesRequestMultiError) AllErrors() []error { return m }

// GetUserBalancesRequestValidationError is the validation error returned by
// GetUserBalancesRequest.Validate if the designated constraints aren't met.
type GetUserBalancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalancesRequestValidationError) ErrorName() string {
	return "GetUserBalancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalancesRequestValidationError{}

// Validate checks the field values on GetUserBalancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalancesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserBalancesResponseMultiError, or nil if none found.
func (m *GetUserBalancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBalances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserBalancesResponseValidationError{
						field:  fmt.Sprintf("Balances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserBalancesResponseValidationError{
						field:  fmt.Sprintf("Balances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserBalancesResponseValidationError{
					field:  fmt.Sprintf("Balances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserBalancesResponseMultiError(errors)
	}

	return nil
}

// GetUserBalancesResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserBalancesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserBalancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalancesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalancesResponseMultiError) AllErrors() []error { return m }

// GetUserBalancesResponseValidationError is the validation error returned by
// GetUserBalancesResponse.Validate if the designated constraints aren't met.
type GetUserBalancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalancesResponseValidationError) ErrorName() string {
	return "GetUserBalancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalancesResponseValidationError{}

// Validate checks the field values on GetUserBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserBalanceRequestMultiError, or nil if none found.
func (m *GetUserBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for SettlementCurrency

	if len(errors) > 0 {
		return GetUserBalanceRequestMultiError(errors)
	}

	return nil
}

// GetUserBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserBalanceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalanceRequestMultiError) AllErrors() []error { return m }

// GetUserBalanceRequestValidationError is the validation error returned by
// GetUserBalanceRequest.Validate if the designated constraints aren't met.
type GetUserBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalanceRequestValidationError) ErrorName() string {
	return "GetUserBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalanceRequestValidationError{}

// Validate checks the field values on GetUserBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserBalanceResponseMultiError, or nil if none found.
func (m *GetUserBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExchangeRate

	// no validation rules for Cash

	// no validation rules for OperatorBonus

	// no validation rules for ProviderBonus

	if len(errors) > 0 {
		return GetUserBalanceResponseMultiError(errors)
	}

	return nil
}

// GetUserBalanceResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserBalanceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalanceResponseMultiError) AllErrors() []error { return m }

// GetUserBalanceResponseValidationError is the validation error returned by
// GetUserBalanceResponse.Validate if the designated constraints aren't met.
type GetUserBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalanceResponseValidationError) ErrorName() string {
	return "GetUserBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalanceResponseValidationError{}

// Validate checks the field values on CreditRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditRequestMultiError, or
// nil if none found.
func (m *CreditRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for Cash

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreditRequestMultiError(errors)
	}

	return nil
}

// CreditRequestMultiError is an error wrapping multiple validation errors
// returned by CreditRequest.ValidateAll() if the designated constraints
// aren't met.
type CreditRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditRequestMultiError) AllErrors() []error { return m }

// CreditRequestValidationError is the validation error returned by
// CreditRequest.Validate if the designated constraints aren't met.
type CreditRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditRequestValidationError) ErrorName() string { return "CreditRequestValidationError" }

// Error satisfies the builtin error interface
func (e CreditRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditRequestValidationError{}

// Validate checks the field values on CreditResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditResponseMultiError,
// or nil if none found.
func (m *CreditResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return CreditResponseMultiError(errors)
	}

	return nil
}

// CreditResponseMultiError is an error wrapping multiple validation errors
// returned by CreditResponse.ValidateAll() if the designated constraints
// aren't met.
type CreditResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditResponseMultiError) AllErrors() []error { return m }

// CreditResponseValidationError is the validation error returned by
// CreditResponse.Validate if the designated constraints aren't met.
type CreditResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditResponseValidationError) ErrorName() string { return "CreditResponseValidationError" }

// Error satisfies the builtin error interface
func (e CreditResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditResponseValidationError{}

// Validate checks the field values on DebitRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebitRequestMultiError, or
// nil if none found.
func (m *DebitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for Cash

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebitRequestMultiError(errors)
	}

	return nil
}

// DebitRequestMultiError is an error wrapping multiple validation errors
// returned by DebitRequest.ValidateAll() if the designated constraints aren't met.
type DebitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitRequestMultiError) AllErrors() []error { return m }

// DebitRequestValidationError is the validation error returned by
// DebitRequest.Validate if the designated constraints aren't met.
type DebitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitRequestValidationError) ErrorName() string { return "DebitRequestValidationError" }

// Error satisfies the builtin error interface
func (e DebitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitRequestValidationError{}

// Validate checks the field values on DebitResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebitResponseMultiError, or
// nil if none found.
func (m *DebitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return DebitResponseMultiError(errors)
	}

	return nil
}

// DebitResponseMultiError is an error wrapping multiple validation errors
// returned by DebitResponse.ValidateAll() if the designated constraints
// aren't met.
type DebitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitResponseMultiError) AllErrors() []error { return m }

// DebitResponseValidationError is the validation error returned by
// DebitResponse.Validate if the designated constraints aren't met.
type DebitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitResponseValidationError) ErrorName() string { return "DebitResponseValidationError" }

// Error satisfies the builtin error interface
func (e DebitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitResponseValidationError{}

// Validate checks the field values on GameDebitRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameDebitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameDebitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameDebitRequestMultiError, or nil if none found.
func (m *GameDebitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GameDebitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for SettlementCurrency

	// no validation rules for ReportingCurrency

	// no validation rules for ExchangeRate

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for Amount

	// no validation rules for Turnover

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameDebitRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameDebitRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameDebitRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.AllowOverdraft != nil {
		// no validation rules for AllowOverdraft
	}

	if len(errors) > 0 {
		return GameDebitRequestMultiError(errors)
	}

	return nil
}

// GameDebitRequestMultiError is an error wrapping multiple validation errors
// returned by GameDebitRequest.ValidateAll() if the designated constraints
// aren't met.
type GameDebitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameDebitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameDebitRequestMultiError) AllErrors() []error { return m }

// GameDebitRequestValidationError is the validation error returned by
// GameDebitRequest.Validate if the designated constraints aren't met.
type GameDebitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameDebitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameDebitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameDebitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameDebitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameDebitRequestValidationError) ErrorName() string { return "GameDebitRequestValidationError" }

// Error satisfies the builtin error interface
func (e GameDebitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameDebitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameDebitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameDebitRequestValidationError{}

// Validate checks the field values on GameDebitResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameDebitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameDebitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameDebitResponseMultiError, or nil if none found.
func (m *GameDebitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GameDebitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for ExchangeRate

	// no validation rules for Cash

	// no validation rules for OperatorBonus

	// no validation rules for ProviderBonus

	// no validation rules for CashAmount

	// no validation rules for OperatorBonusAmount

	// no validation rules for ProviderBonusAmount

	// no validation rules for CashAmountUsd

	// no validation rules for OperatorBonusAmountUsd

	// no validation rules for ProviderBonusAmountUsd

	// no validation rules for CashAmountReportingCurrency

	// no validation rules for OperatorBonusAmountReportingCurrency

	// no validation rules for ProviderBonusAmountReportingCurrency

	if len(errors) > 0 {
		return GameDebitResponseMultiError(errors)
	}

	return nil
}

// GameDebitResponseMultiError is an error wrapping multiple validation errors
// returned by GameDebitResponse.ValidateAll() if the designated constraints
// aren't met.
type GameDebitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameDebitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameDebitResponseMultiError) AllErrors() []error { return m }

// GameDebitResponseValidationError is the validation error returned by
// GameDebitResponse.Validate if the designated constraints aren't met.
type GameDebitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameDebitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameDebitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameDebitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameDebitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameDebitResponseValidationError) ErrorName() string {
	return "GameDebitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GameDebitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameDebitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameDebitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameDebitResponseValidationError{}

// Validate checks the field values on GameCreditRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameCreditRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameCreditRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameCreditRequestMultiError, or nil if none found.
func (m *GameCreditRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GameCreditRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for SettlementCurrency

	// no validation rules for ReportingCurrency

	// no validation rules for ExchangeRate

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for OriginalTransactionId

	// no validation rules for Amount

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameCreditRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameCreditRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameCreditRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GameCreditRequestMultiError(errors)
	}

	return nil
}

// GameCreditRequestMultiError is an error wrapping multiple validation errors
// returned by GameCreditRequest.ValidateAll() if the designated constraints
// aren't met.
type GameCreditRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameCreditRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameCreditRequestMultiError) AllErrors() []error { return m }

// GameCreditRequestValidationError is the validation error returned by
// GameCreditRequest.Validate if the designated constraints aren't met.
type GameCreditRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameCreditRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameCreditRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameCreditRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameCreditRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameCreditRequestValidationError) ErrorName() string {
	return "GameCreditRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GameCreditRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameCreditRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameCreditRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameCreditRequestValidationError{}

// Validate checks the field values on GameCreditResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GameCreditResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameCreditResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameCreditResponseMultiError, or nil if none found.
func (m *GameCreditResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GameCreditResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for ExchangeRate

	// no validation rules for Cash

	// no validation rules for OperatorBonus

	// no validation rules for ProviderBonus

	// no validation rules for CashAmount

	// no validation rules for OperatorBonusAmount

	// no validation rules for ProviderBonusAmount

	// no validation rules for CashAmountUsd

	// no validation rules for OperatorBonusAmountUsd

	// no validation rules for ProviderBonusAmountUsd

	// no validation rules for CashAmountReportingCurrency

	// no validation rules for OperatorBonusAmountReportingCurrency

	// no validation rules for ProviderBonusAmountReportingCurrency

	if len(errors) > 0 {
		return GameCreditResponseMultiError(errors)
	}

	return nil
}

// GameCreditResponseMultiError is an error wrapping multiple validation errors
// returned by GameCreditResponse.ValidateAll() if the designated constraints
// aren't met.
type GameCreditResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameCreditResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameCreditResponseMultiError) AllErrors() []error { return m }

// GameCreditResponseValidationError is the validation error returned by
// GameCreditResponse.Validate if the designated constraints aren't met.
type GameCreditResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameCreditResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameCreditResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameCreditResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameCreditResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameCreditResponseValidationError) ErrorName() string {
	return "GameCreditResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GameCreditResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameCreditResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameCreditResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameCreditResponseValidationError{}

// Validate checks the field values on ChannelInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChannelInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChannelInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChannelInfoMultiError, or
// nil if none found.
func (m *ChannelInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ChannelInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChannelInfoValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChannelInfoValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChannelInfoValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChannelInfoMultiError(errors)
	}

	return nil
}

// ChannelInfoMultiError is an error wrapping multiple validation errors
// returned by ChannelInfo.ValidateAll() if the designated constraints aren't met.
type ChannelInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChannelInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChannelInfoMultiError) AllErrors() []error { return m }

// ChannelInfoValidationError is the validation error returned by
// ChannelInfo.Validate if the designated constraints aren't met.
type ChannelInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChannelInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChannelInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChannelInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChannelInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChannelInfoValidationError) ErrorName() string { return "ChannelInfoValidationError" }

// Error satisfies the builtin error interface
func (e ChannelInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChannelInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChannelInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChannelInfoValidationError{}

// Validate checks the field values on FreezeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FreezeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FreezeRequestMultiError, or
// nil if none found.
func (m *FreezeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for Cash

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FreezeRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FreezeRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FreezeRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChannelInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FreezeRequestValidationError{
					field:  "ChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FreezeRequestValidationError{
					field:  "ChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChannelInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FreezeRequestValidationError{
				field:  "ChannelInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FreezeRequestMultiError(errors)
	}

	return nil
}

// FreezeRequestMultiError is an error wrapping multiple validation errors
// returned by FreezeRequest.ValidateAll() if the designated constraints
// aren't met.
type FreezeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeRequestMultiError) AllErrors() []error { return m }

// FreezeRequestValidationError is the validation error returned by
// FreezeRequest.Validate if the designated constraints aren't met.
type FreezeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeRequestValidationError) ErrorName() string { return "FreezeRequestValidationError" }

// Error satisfies the builtin error interface
func (e FreezeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeRequestValidationError{}

// Validate checks the field values on FreezeResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FreezeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FreezeResponseMultiError,
// or nil if none found.
func (m *FreezeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return FreezeResponseMultiError(errors)
	}

	return nil
}

// FreezeResponseMultiError is an error wrapping multiple validation errors
// returned by FreezeResponse.ValidateAll() if the designated constraints
// aren't met.
type FreezeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeResponseMultiError) AllErrors() []error { return m }

// FreezeResponseValidationError is the validation error returned by
// FreezeResponse.Validate if the designated constraints aren't met.
type FreezeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeResponseValidationError) ErrorName() string { return "FreezeResponseValidationError" }

// Error satisfies the builtin error interface
func (e FreezeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeResponseValidationError{}

// Validate checks the field values on SettleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SettleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SettleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SettleRequestMultiError, or
// nil if none found.
func (m *SettleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SettleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for OriginalTransactionId

	if all {
		switch v := interface{}(m.GetChannelInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SettleRequestValidationError{
					field:  "ChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SettleRequestValidationError{
					field:  "ChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChannelInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SettleRequestValidationError{
				field:  "ChannelInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SettleRequestMultiError(errors)
	}

	return nil
}

// SettleRequestMultiError is an error wrapping multiple validation errors
// returned by SettleRequest.ValidateAll() if the designated constraints
// aren't met.
type SettleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettleRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettleRequestMultiError) AllErrors() []error { return m }

// SettleRequestValidationError is the validation error returned by
// SettleRequest.Validate if the designated constraints aren't met.
type SettleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettleRequestValidationError) ErrorName() string { return "SettleRequestValidationError" }

// Error satisfies the builtin error interface
func (e SettleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettleRequestValidationError{}

// Validate checks the field values on SettleResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SettleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SettleResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SettleResponseMultiError,
// or nil if none found.
func (m *SettleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SettleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return SettleResponseMultiError(errors)
	}

	return nil
}

// SettleResponseMultiError is an error wrapping multiple validation errors
// returned by SettleResponse.ValidateAll() if the designated constraints
// aren't met.
type SettleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettleResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettleResponseMultiError) AllErrors() []error { return m }

// SettleResponseValidationError is the validation error returned by
// SettleResponse.Validate if the designated constraints aren't met.
type SettleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettleResponseValidationError) ErrorName() string { return "SettleResponseValidationError" }

// Error satisfies the builtin error interface
func (e SettleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettleResponseValidationError{}

// Validate checks the field values on RollbackRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RollbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackRequestMultiError, or nil if none found.
func (m *RollbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionType

	// no validation rules for TransactionId

	// no validation rules for OriginalTransactionId

	if all {
		switch v := interface{}(m.GetChannelInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RollbackRequestValidationError{
					field:  "ChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RollbackRequestValidationError{
					field:  "ChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChannelInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RollbackRequestValidationError{
				field:  "ChannelInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RollbackRequestMultiError(errors)
	}

	return nil
}

// RollbackRequestMultiError is an error wrapping multiple validation errors
// returned by RollbackRequest.ValidateAll() if the designated constraints
// aren't met.
type RollbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackRequestMultiError) AllErrors() []error { return m }

// RollbackRequestValidationError is the validation error returned by
// RollbackRequest.Validate if the designated constraints aren't met.
type RollbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackRequestValidationError) ErrorName() string { return "RollbackRequestValidationError" }

// Error satisfies the builtin error interface
func (e RollbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackRequestValidationError{}

// Validate checks the field values on RollbackResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RollbackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackResponseMultiError, or nil if none found.
func (m *RollbackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	// no validation rules for OperatorBonus

	// no validation rules for ProviderBonus

	// no validation rules for CashAmount

	// no validation rules for OperatorBonusAmount

	// no validation rules for ProviderBonusAmount

	// no validation rules for CashAmountUsd

	// no validation rules for OperatorBonusAmountUsd

	// no validation rules for ProviderBonusAmountUsd

	// no validation rules for CashAmountReportingCurrency

	// no validation rules for OperatorBonusAmountReportingCurrency

	// no validation rules for ProviderBonusAmountReportingCurrency

	if len(errors) > 0 {
		return RollbackResponseMultiError(errors)
	}

	return nil
}

// RollbackResponseMultiError is an error wrapping multiple validation errors
// returned by RollbackResponse.ValidateAll() if the designated constraints
// aren't met.
type RollbackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackResponseMultiError) AllErrors() []error { return m }

// RollbackResponseValidationError is the validation error returned by
// RollbackResponse.Validate if the designated constraints aren't met.
type RollbackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackResponseValidationError) ErrorName() string { return "RollbackResponseValidationError" }

// Error satisfies the builtin error interface
func (e RollbackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackResponseValidationError{}

// Validate checks the field values on GetWalletsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetWalletsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletsRequestMultiError, or nil if none found.
func (m *GetWalletsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWalletsRequestMultiError(errors)
	}

	return nil
}

// GetWalletsRequestMultiError is an error wrapping multiple validation errors
// returned by GetWalletsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetWalletsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletsRequestMultiError) AllErrors() []error { return m }

// GetWalletsRequestValidationError is the validation error returned by
// GetWalletsRequest.Validate if the designated constraints aren't met.
type GetWalletsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletsRequestValidationError) ErrorName() string {
	return "GetWalletsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletsRequestValidationError{}

// Validate checks the field values on GetWalletsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletsResponseMultiError, or nil if none found.
func (m *GetWalletsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotalAssets()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletsResponseValidationError{
					field:  "TotalAssets",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletsResponseValidationError{
					field:  "TotalAssets",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAssets()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletsResponseValidationError{
				field:  "TotalAssets",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetWallets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletsResponseValidationError{
						field:  fmt.Sprintf("Wallets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletsResponseValidationError{
						field:  fmt.Sprintf("Wallets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletsResponseValidationError{
					field:  fmt.Sprintf("Wallets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetWalletsResponseMultiError(errors)
	}

	return nil
}

// GetWalletsResponseMultiError is an error wrapping multiple validation errors
// returned by GetWalletsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetWalletsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletsResponseMultiError) AllErrors() []error { return m }

// GetWalletsResponseValidationError is the validation error returned by
// GetWalletsResponse.Validate if the designated constraints aren't met.
type GetWalletsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletsResponseValidationError) ErrorName() string {
	return "GetWalletsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletsResponseValidationError{}

// Validate checks the field values on ListWalletBalanceTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListWalletBalanceTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletBalanceTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListWalletBalanceTransactionsRequestMultiError, or nil if none found.
func (m *ListWalletBalanceTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListWalletBalanceTransactionsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.TransactionType != nil {
		// no validation rules for TransactionType
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceTransactionsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceTransactionsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListWalletBalanceTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListWalletBalanceTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletBalanceTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListWalletBalanceTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceTransactionsRequestMultiError) AllErrors() []error { return m }

// ListWalletBalanceTransactionsRequestValidationError is the validation error
// returned by ListWalletBalanceTransactionsRequest.Validate if the designated
// constraints aren't met.
type ListWalletBalanceTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceTransactionsRequestValidationError) ErrorName() string {
	return "ListWalletBalanceTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceTransactionsRequestValidationError{}

// Validate checks the field values on ListWalletBalanceTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListWalletBalanceTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletBalanceTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListWalletBalanceTransactionsResponseMultiError, or nil if none found.
func (m *ListWalletBalanceTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBalanceTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceTransactionsResponseValidationError{
					field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListWalletBalanceTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListWalletBalanceTransactionsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListWalletBalanceTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListWalletBalanceTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceTransactionsResponseMultiError) AllErrors() []error { return m }

// ListWalletBalanceTransactionsResponseValidationError is the validation error
// returned by ListWalletBalanceTransactionsResponse.Validate if the
// designated constraints aren't met.
type ListWalletBalanceTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceTransactionsResponseValidationError) ErrorName() string {
	return "ListWalletBalanceTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceTransactionsResponseValidationError{}

// Validate checks the field values on GetWalletBalanceTransactionsByIdsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetWalletBalanceTransactionsByIdsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetWalletBalanceTransactionsByIdsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetWalletBalanceTransactionsByIdsRequestMultiError, or nil if none found.
func (m *GetWalletBalanceTransactionsByIdsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletBalanceTransactionsByIdsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletBalanceTransactionsByIdsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletBalanceTransactionsByIdsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletBalanceTransactionsByIdsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWalletBalanceTransactionsByIdsRequestMultiError(errors)
	}

	return nil
}

// GetWalletBalanceTransactionsByIdsRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetWalletBalanceTransactionsByIdsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWalletBalanceTransactionsByIdsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletBalanceTransactionsByIdsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletBalanceTransactionsByIdsRequestMultiError) AllErrors() []error { return m }

// GetWalletBalanceTransactionsByIdsRequestValidationError is the validation
// error returned by GetWalletBalanceTransactionsByIdsRequest.Validate if the
// designated constraints aren't met.
type GetWalletBalanceTransactionsByIdsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletBalanceTransactionsByIdsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletBalanceTransactionsByIdsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletBalanceTransactionsByIdsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletBalanceTransactionsByIdsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletBalanceTransactionsByIdsRequestValidationError) ErrorName() string {
	return "GetWalletBalanceTransactionsByIdsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletBalanceTransactionsByIdsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletBalanceTransactionsByIdsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletBalanceTransactionsByIdsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletBalanceTransactionsByIdsRequestValidationError{}

// Validate checks the field values on
// GetWalletBalanceTransactionsByIdsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetWalletBalanceTransactionsByIdsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetWalletBalanceTransactionsByIdsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetWalletBalanceTransactionsByIdsResponseMultiError, or nil if none found.
func (m *GetWalletBalanceTransactionsByIdsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletBalanceTransactionsByIdsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBalanceTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletBalanceTransactionsByIdsResponseValidationError{
						field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletBalanceTransactionsByIdsResponseValidationError{
						field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletBalanceTransactionsByIdsResponseValidationError{
					field:  fmt.Sprintf("BalanceTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetWalletBalanceTransactionsByIdsResponseMultiError(errors)
	}

	return nil
}

// GetWalletBalanceTransactionsByIdsResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetWalletBalanceTransactionsByIdsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetWalletBalanceTransactionsByIdsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletBalanceTransactionsByIdsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletBalanceTransactionsByIdsResponseMultiError) AllErrors() []error { return m }

// GetWalletBalanceTransactionsByIdsResponseValidationError is the validation
// error returned by GetWalletBalanceTransactionsByIdsResponse.Validate if the
// designated constraints aren't met.
type GetWalletBalanceTransactionsByIdsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletBalanceTransactionsByIdsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletBalanceTransactionsByIdsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletBalanceTransactionsByIdsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletBalanceTransactionsByIdsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletBalanceTransactionsByIdsResponseValidationError) ErrorName() string {
	return "GetWalletBalanceTransactionsByIdsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletBalanceTransactionsByIdsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletBalanceTransactionsByIdsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletBalanceTransactionsByIdsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletBalanceTransactionsByIdsResponseValidationError{}

// Validate checks the field values on GetWalletCreditTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetWalletCreditTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetWalletCreditTransactionsRequestMultiError, or nil if none found.
func (m *GetWalletCreditTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreditId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletCreditTransactionsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletCreditTransactionsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletCreditTransactionsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return GetWalletCreditTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetWalletCreditTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetWalletCreditTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWalletCreditTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditTransactionsRequestMultiError) AllErrors() []error { return m }

// GetWalletCreditTransactionsRequestValidationError is the validation error
// returned by GetWalletCreditTransactionsRequest.Validate if the designated
// constraints aren't met.
type GetWalletCreditTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditTransactionsRequestValidationError) ErrorName() string {
	return "GetWalletCreditTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditTransactionsRequestValidationError{}

// Validate checks the field values on GetWalletCreditTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetWalletCreditTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletCreditTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetWalletCreditTransactionsResponseMultiError, or nil if none found.
func (m *GetWalletCreditTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCreditTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletCreditTransactionsResponseValidationError{
						field:  fmt.Sprintf("CreditTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletCreditTransactionsResponseValidationError{
						field:  fmt.Sprintf("CreditTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletCreditTransactionsResponseValidationError{
					field:  fmt.Sprintf("CreditTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return GetWalletCreditTransactionsResponseMultiError(errors)
	}

	return nil
}

// GetWalletCreditTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetWalletCreditTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetWalletCreditTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditTransactionsResponseMultiError) AllErrors() []error { return m }

// GetWalletCreditTransactionsResponseValidationError is the validation error
// returned by GetWalletCreditTransactionsResponse.Validate if the designated
// constraints aren't met.
type GetWalletCreditTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletCreditTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletCreditTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletCreditTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletCreditTransactionsResponseValidationError) ErrorName() string {
	return "GetWalletCreditTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditTransactionsResponseValidationError{}

// Validate checks the field values on GetExchangeRatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExchangeRatesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExchangeRatesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExchangeRatesRequestMultiError, or nil if none found.
func (m *GetExchangeRatesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExchangeRatesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetExchangeRatesRequestMultiError(errors)
	}

	return nil
}

// GetExchangeRatesRequestMultiError is an error wrapping multiple validation
// errors returned by GetExchangeRatesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetExchangeRatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExchangeRatesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExchangeRatesRequestMultiError) AllErrors() []error { return m }

// GetExchangeRatesRequestValidationError is the validation error returned by
// GetExchangeRatesRequest.Validate if the designated constraints aren't met.
type GetExchangeRatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExchangeRatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExchangeRatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExchangeRatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExchangeRatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExchangeRatesRequestValidationError) ErrorName() string {
	return "GetExchangeRatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExchangeRatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExchangeRatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExchangeRatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExchangeRatesRequestValidationError{}

// Validate checks the field values on GetExchangeRatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExchangeRatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExchangeRatesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExchangeRatesResponseMultiError, or nil if none found.
func (m *GetExchangeRatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExchangeRatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExchangeRates

	if len(errors) > 0 {
		return GetExchangeRatesResponseMultiError(errors)
	}

	return nil
}

// GetExchangeRatesResponseMultiError is an error wrapping multiple validation
// errors returned by GetExchangeRatesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetExchangeRatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExchangeRatesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExchangeRatesResponseMultiError) AllErrors() []error { return m }

// GetExchangeRatesResponseValidationError is the validation error returned by
// GetExchangeRatesResponse.Validate if the designated constraints aren't met.
type GetExchangeRatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExchangeRatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExchangeRatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExchangeRatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExchangeRatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExchangeRatesResponseValidationError) ErrorName() string {
	return "GetExchangeRatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetExchangeRatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExchangeRatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExchangeRatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExchangeRatesResponseValidationError{}

// Validate checks the field values on GetExchangeRatesWithBaseCurrencyRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetExchangeRatesWithBaseCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetExchangeRatesWithBaseCurrencyRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetExchangeRatesWithBaseCurrencyRequestMultiError, or nil if none found.
func (m *GetExchangeRatesWithBaseCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExchangeRatesWithBaseCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.BaseCurrency != nil {
		// no validation rules for BaseCurrency
	}

	if len(errors) > 0 {
		return GetExchangeRatesWithBaseCurrencyRequestMultiError(errors)
	}

	return nil
}

// GetExchangeRatesWithBaseCurrencyRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetExchangeRatesWithBaseCurrencyRequest.ValidateAll() if the designated
// constraints aren't met.
type GetExchangeRatesWithBaseCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExchangeRatesWithBaseCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExchangeRatesWithBaseCurrencyRequestMultiError) AllErrors() []error { return m }

// GetExchangeRatesWithBaseCurrencyRequestValidationError is the validation
// error returned by GetExchangeRatesWithBaseCurrencyRequest.Validate if the
// designated constraints aren't met.
type GetExchangeRatesWithBaseCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExchangeRatesWithBaseCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExchangeRatesWithBaseCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExchangeRatesWithBaseCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExchangeRatesWithBaseCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExchangeRatesWithBaseCurrencyRequestValidationError) ErrorName() string {
	return "GetExchangeRatesWithBaseCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExchangeRatesWithBaseCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExchangeRatesWithBaseCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExchangeRatesWithBaseCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExchangeRatesWithBaseCurrencyRequestValidationError{}

// Validate checks the field values on GetExchangeRatesWithBaseCurrencyResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetExchangeRatesWithBaseCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetExchangeRatesWithBaseCurrencyResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetExchangeRatesWithBaseCurrencyResponseMultiError, or nil if none found.
func (m *GetExchangeRatesWithBaseCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExchangeRatesWithBaseCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExchangeRates

	if len(errors) > 0 {
		return GetExchangeRatesWithBaseCurrencyResponseMultiError(errors)
	}

	return nil
}

// GetExchangeRatesWithBaseCurrencyResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetExchangeRatesWithBaseCurrencyResponse.ValidateAll() if the designated
// constraints aren't met.
type GetExchangeRatesWithBaseCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExchangeRatesWithBaseCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExchangeRatesWithBaseCurrencyResponseMultiError) AllErrors() []error { return m }

// GetExchangeRatesWithBaseCurrencyResponseValidationError is the validation
// error returned by GetExchangeRatesWithBaseCurrencyResponse.Validate if the
// designated constraints aren't met.
type GetExchangeRatesWithBaseCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExchangeRatesWithBaseCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExchangeRatesWithBaseCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExchangeRatesWithBaseCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExchangeRatesWithBaseCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExchangeRatesWithBaseCurrencyResponseValidationError) ErrorName() string {
	return "GetExchangeRatesWithBaseCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetExchangeRatesWithBaseCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExchangeRatesWithBaseCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExchangeRatesWithBaseCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExchangeRatesWithBaseCurrencyResponseValidationError{}

// Validate checks the field values on GetUserTransactionSummaryRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetUserTransactionSummaryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserTransactionSummaryRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetUserTransactionSummaryRequestMultiError, or nil if none found.
func (m *GetUserTransactionSummaryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserTransactionSummaryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserTransactionSummaryRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserTransactionSummaryRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserTransactionSummaryRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserTransactionSummaryRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserTransactionSummaryRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserTransactionSummaryRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserTransactionSummaryRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserTransactionSummaryRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserTransactionSummaryRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserTransactionSummaryRequestMultiError(errors)
	}

	return nil
}

// GetUserTransactionSummaryRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetUserTransactionSummaryRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserTransactionSummaryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserTransactionSummaryRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserTransactionSummaryRequestMultiError) AllErrors() []error { return m }

// GetUserTransactionSummaryRequestValidationError is the validation error
// returned by GetUserTransactionSummaryRequest.Validate if the designated
// constraints aren't met.
type GetUserTransactionSummaryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserTransactionSummaryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserTransactionSummaryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserTransactionSummaryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserTransactionSummaryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserTransactionSummaryRequestValidationError) ErrorName() string {
	return "GetUserTransactionSummaryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserTransactionSummaryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserTransactionSummaryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserTransactionSummaryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserTransactionSummaryRequestValidationError{}

// Validate checks the field values on GetUserTransactionSummaryResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetUserTransactionSummaryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserTransactionSummaryResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetUserTransactionSummaryResponseMultiError, or nil if none found.
func (m *GetUserTransactionSummaryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserTransactionSummaryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalDepositUsd

	// no validation rules for TotalWithdrawUsd

	// no validation rules for DepositMinusWithdrawUsd

	// no validation rules for TotalValidBetUsd

	// no validation rules for TotalDepositReportingCurrency

	// no validation rules for TotalWithdrawReportingCurrency

	// no validation rules for DepositMinusWithdrawReportingCurrency

	// no validation rules for TotalValidBetReportingCurrency

	// no validation rules for TotalDepositCount

	// no validation rules for TotalWithdrawCount

	// no validation rules for TodayWithdrawCount

	if len(errors) > 0 {
		return GetUserTransactionSummaryResponseMultiError(errors)
	}

	return nil
}

// GetUserTransactionSummaryResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetUserTransactionSummaryResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserTransactionSummaryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserTransactionSummaryResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserTransactionSummaryResponseMultiError) AllErrors() []error { return m }

// GetUserTransactionSummaryResponseValidationError is the validation error
// returned by GetUserTransactionSummaryResponse.Validate if the designated
// constraints aren't met.
type GetUserTransactionSummaryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserTransactionSummaryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserTransactionSummaryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserTransactionSummaryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserTransactionSummaryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserTransactionSummaryResponseValidationError) ErrorName() string {
	return "GetUserTransactionSummaryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserTransactionSummaryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserTransactionSummaryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserTransactionSummaryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserTransactionSummaryResponseValidationError{}

// Validate checks the field values on
// GetBackofficeUserOverviewFromWalletRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetBackofficeUserOverviewFromWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetBackofficeUserOverviewFromWalletRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetBackofficeUserOverviewFromWalletRequestMultiError, or nil if none found.
func (m *GetBackofficeUserOverviewFromWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBackofficeUserOverviewFromWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBackofficeUserOverviewFromWalletRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBackofficeUserOverviewFromWalletRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBackofficeUserOverviewFromWalletRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBackofficeUserOverviewFromWalletRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBackofficeUserOverviewFromWalletRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBackofficeUserOverviewFromWalletRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBackofficeUserOverviewFromWalletRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBackofficeUserOverviewFromWalletRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBackofficeUserOverviewFromWalletRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBackofficeUserOverviewFromWalletRequestMultiError(errors)
	}

	return nil
}

// GetBackofficeUserOverviewFromWalletRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetBackofficeUserOverviewFromWalletRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBackofficeUserOverviewFromWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBackofficeUserOverviewFromWalletRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBackofficeUserOverviewFromWalletRequestMultiError) AllErrors() []error { return m }

// GetBackofficeUserOverviewFromWalletRequestValidationError is the validation
// error returned by GetBackofficeUserOverviewFromWalletRequest.Validate if
// the designated constraints aren't met.
type GetBackofficeUserOverviewFromWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBackofficeUserOverviewFromWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBackofficeUserOverviewFromWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBackofficeUserOverviewFromWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBackofficeUserOverviewFromWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBackofficeUserOverviewFromWalletRequestValidationError) ErrorName() string {
	return "GetBackofficeUserOverviewFromWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBackofficeUserOverviewFromWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBackofficeUserOverviewFromWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBackofficeUserOverviewFromWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBackofficeUserOverviewFromWalletRequestValidationError{}

// Validate checks the field values on
// GetBackofficeUserOverviewFromWalletResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetBackofficeUserOverviewFromWalletResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetBackofficeUserOverviewFromWalletResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetBackofficeUserOverviewFromWalletResponseMultiError, or nil if none found.
func (m *GetBackofficeUserOverviewFromWalletResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBackofficeUserOverviewFromWalletResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BalanceUsd

	// no validation rules for DepositMinusWithdrawUsd

	// no validation rules for TurnoverUsd

	// no validation rules for CashTurnoverUsd

	// no validation rules for BonusTurnoverUsd

	// no validation rules for DepositUsd

	// no validation rules for LastDepositUsd

	// no validation rules for DepositCount

	// no validation rules for WithdrawUsd

	// no validation rules for LastWithdrawUsd

	// no validation rules for WithdrawCount

	// no validation rules for BonusUsd

	// no validation rules for ValidTurnoverUsd

	// no validation rules for AverageBetAmountUsd

	// no validation rules for GgrUsd

	// no validation rules for GgrPercentage

	// no validation rules for ManuallyAddedBalanceUsd

	// no validation rules for BonusClaimedUsd

	// no validation rules for NgrUsd

	// no validation rules for GgrToNgrPercentage

	// no validation rules for TurnoverMultiplier

	// no validation rules for WithdrawToDepositRatio

	// no validation rules for Rtp

	// no validation rules for BalanceReportingCurrency

	// no validation rules for DepositMinusWithdrawReportingCurrency

	// no validation rules for TurnoverReportingCurrency

	// no validation rules for CashTurnoverReportingCurrency

	// no validation rules for BonusTurnoverReportingCurrency

	// no validation rules for DepositReportingCurrency

	// no validation rules for LastDepositReportingCurrency

	// no validation rules for WithdrawReportingCurrency

	// no validation rules for LastWithdrawReportingCurrency

	// no validation rules for BonusReportingCurrency

	// no validation rules for ValidTurnoverReportingCurrency

	// no validation rules for AverageBetAmountReportingCurrency

	// no validation rules for GgrReportingCurrency

	// no validation rules for ManuallyAddedBalanceReportingCurrency

	// no validation rules for BonusClaimedReportingCurrency

	// no validation rules for NgrReportingCurrency

	if len(errors) > 0 {
		return GetBackofficeUserOverviewFromWalletResponseMultiError(errors)
	}

	return nil
}

// GetBackofficeUserOverviewFromWalletResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetBackofficeUserOverviewFromWalletResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBackofficeUserOverviewFromWalletResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBackofficeUserOverviewFromWalletResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBackofficeUserOverviewFromWalletResponseMultiError) AllErrors() []error { return m }

// GetBackofficeUserOverviewFromWalletResponseValidationError is the validation
// error returned by GetBackofficeUserOverviewFromWalletResponse.Validate if
// the designated constraints aren't met.
type GetBackofficeUserOverviewFromWalletResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBackofficeUserOverviewFromWalletResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBackofficeUserOverviewFromWalletResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBackofficeUserOverviewFromWalletResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBackofficeUserOverviewFromWalletResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBackofficeUserOverviewFromWalletResponseValidationError) ErrorName() string {
	return "GetBackofficeUserOverviewFromWalletResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBackofficeUserOverviewFromWalletResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBackofficeUserOverviewFromWalletResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBackofficeUserOverviewFromWalletResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBackofficeUserOverviewFromWalletResponseValidationError{}

// Validate checks the field values on GetOverviewDashboardFromWalletRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetOverviewDashboardFromWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOverviewDashboardFromWalletRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetOverviewDashboardFromWalletRequestMultiError, or nil if none found.
func (m *GetOverviewDashboardFromWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletRequestMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetOverviewDashboardFromWalletRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOverviewDashboardFromWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletRequestMultiError) AllErrors() []error { return m }

// GetOverviewDashboardFromWalletRequestValidationError is the validation error
// returned by GetOverviewDashboardFromWalletRequest.Validate if the
// designated constraints aren't met.
type GetOverviewDashboardFromWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOverviewDashboardFromWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletRequestValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletRequestValidationError{}

// Validate checks the field values on GetOverviewDashboardFromWalletResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetOverviewDashboardFromWalletResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOverviewDashboardFromWalletResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetOverviewDashboardFromWalletResponseMultiError, or nil if none found.
func (m *GetOverviewDashboardFromWalletResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGgr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Ggr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Ggr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGgr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletResponseValidationError{
				field:  "Ggr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNgr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Ngr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Ngr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNgr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletResponseValidationError{
				field:  "Ngr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeposit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Deposit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Deposit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeposit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletResponseValidationError{
				field:  "Deposit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWithdraw()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Withdraw",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "Withdraw",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWithdraw()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletResponseValidationError{
				field:  "Withdraw",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDepositMinusWithdraw()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "DepositMinusWithdraw",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOverviewDashboardFromWalletResponseValidationError{
					field:  "DepositMinusWithdraw",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositMinusWithdraw()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOverviewDashboardFromWalletResponseValidationError{
				field:  "DepositMinusWithdraw",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletResponseMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetOverviewDashboardFromWalletResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOverviewDashboardFromWalletResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletResponseMultiError) AllErrors() []error { return m }

// GetOverviewDashboardFromWalletResponseValidationError is the validation
// error returned by GetOverviewDashboardFromWalletResponse.Validate if the
// designated constraints aren't met.
type GetOverviewDashboardFromWalletResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOverviewDashboardFromWalletResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletResponseValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletResponseValidationError{}

// Validate checks the field values on Currency with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Currency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Currency with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CurrencyMultiError, or nil
// if none found.
func (m *Currency) ValidateAll() error {
	return m.validate(true)
}

func (m *Currency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Enabled

	// no validation rules for Hidden

	// no validation rules for Type

	// no validation rules for Symbol

	// no validation rules for Icon

	// no validation rules for DecimalPlaces

	if len(errors) > 0 {
		return CurrencyMultiError(errors)
	}

	return nil
}

// CurrencyMultiError is an error wrapping multiple validation errors returned
// by Currency.ValidateAll() if the designated constraints aren't met.
type CurrencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyMultiError) AllErrors() []error { return m }

// CurrencyValidationError is the validation error returned by
// Currency.Validate if the designated constraints aren't met.
type CurrencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyValidationError) ErrorName() string { return "CurrencyValidationError" }

// Error satisfies the builtin error interface
func (e CurrencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyValidationError{}

// Validate checks the field values on AddCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCurrencyRequestMultiError, or nil if none found.
func (m *AddCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddCurrencyRequestValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddCurrencyRequestValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddCurrencyRequestValidationError{
				field:  "Currency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddCurrencyRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddCurrencyRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddCurrencyRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddCurrencyRequestMultiError(errors)
	}

	return nil
}

// AddCurrencyRequestMultiError is an error wrapping multiple validation errors
// returned by AddCurrencyRequest.ValidateAll() if the designated constraints
// aren't met.
type AddCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCurrencyRequestMultiError) AllErrors() []error { return m }

// AddCurrencyRequestValidationError is the validation error returned by
// AddCurrencyRequest.Validate if the designated constraints aren't met.
type AddCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCurrencyRequestValidationError) ErrorName() string {
	return "AddCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCurrencyRequestValidationError{}

// Validate checks the field values on AddCurrencyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddCurrencyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddCurrencyResponseMultiError, or nil if none found.
func (m *AddCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddCurrencyResponseMultiError(errors)
	}

	return nil
}

// AddCurrencyResponseMultiError is an error wrapping multiple validation
// errors returned by AddCurrencyResponse.ValidateAll() if the designated
// constraints aren't met.
type AddCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddCurrencyResponseMultiError) AllErrors() []error { return m }

// AddCurrencyResponseValidationError is the validation error returned by
// AddCurrencyResponse.Validate if the designated constraints aren't met.
type AddCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddCurrencyResponseValidationError) ErrorName() string {
	return "AddCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddCurrencyResponseValidationError{}

// Validate checks the field values on UpdateCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCurrencyRequestMultiError, or nil if none found.
func (m *UpdateCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Symbol != nil {
		// no validation rules for Symbol
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.DecimalPlaces != nil {
		// no validation rules for DecimalPlaces
	}

	if len(errors) > 0 {
		return UpdateCurrencyRequestMultiError(errors)
	}

	return nil
}

// UpdateCurrencyRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateCurrencyRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCurrencyRequestMultiError) AllErrors() []error { return m }

// UpdateCurrencyRequestValidationError is the validation error returned by
// UpdateCurrencyRequest.Validate if the designated constraints aren't met.
type UpdateCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCurrencyRequestValidationError) ErrorName() string {
	return "UpdateCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCurrencyRequestValidationError{}

// Validate checks the field values on UpdateCurrencyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCurrencyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCurrencyResponseMultiError, or nil if none found.
func (m *UpdateCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateCurrencyResponseMultiError(errors)
	}

	return nil
}

// UpdateCurrencyResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateCurrencyResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCurrencyResponseMultiError) AllErrors() []error { return m }

// UpdateCurrencyResponseValidationError is the validation error returned by
// UpdateCurrencyResponse.Validate if the designated constraints aren't met.
type UpdateCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCurrencyResponseValidationError) ErrorName() string {
	return "UpdateCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCurrencyResponseValidationError{}

// Validate checks the field values on GetCurrenciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCurrenciesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrenciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCurrenciesRequestMultiError, or nil if none found.
func (m *GetCurrenciesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrenciesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetCurrenciesRequestMultiError(errors)
	}

	return nil
}

// GetCurrenciesRequestMultiError is an error wrapping multiple validation
// errors returned by GetCurrenciesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCurrenciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrenciesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrenciesRequestMultiError) AllErrors() []error { return m }

// GetCurrenciesRequestValidationError is the validation error returned by
// GetCurrenciesRequest.Validate if the designated constraints aren't met.
type GetCurrenciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrenciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrenciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrenciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrenciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrenciesRequestValidationError) ErrorName() string {
	return "GetCurrenciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrenciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrenciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrenciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrenciesRequestValidationError{}

// Validate checks the field values on GetCurrenciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCurrenciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrenciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCurrenciesResponseMultiError, or nil if none found.
func (m *GetCurrenciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrenciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCurrencies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCurrenciesResponseValidationError{
					field:  fmt.Sprintf("Currencies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCurrenciesResponseMultiError(errors)
	}

	return nil
}

// GetCurrenciesResponseMultiError is an error wrapping multiple validation
// errors returned by GetCurrenciesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCurrenciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrenciesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrenciesResponseMultiError) AllErrors() []error { return m }

// GetCurrenciesResponseValidationError is the validation error returned by
// GetCurrenciesResponse.Validate if the designated constraints aren't met.
type GetCurrenciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrenciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrenciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrenciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrenciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrenciesResponseValidationError) ErrorName() string {
	return "GetCurrenciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrenciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrenciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrenciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrenciesResponseValidationError{}

// Validate checks the field values on GetOperatorCurrenciesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperatorCurrenciesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorCurrenciesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOperatorCurrenciesRequestMultiError, or nil if none found.
func (m *GetOperatorCurrenciesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorCurrenciesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOperatorCurrenciesRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOperatorCurrenciesRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOperatorCurrenciesRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOperatorCurrenciesRequestMultiError(errors)
	}

	return nil
}

// GetOperatorCurrenciesRequestMultiError is an error wrapping multiple
// validation errors returned by GetOperatorCurrenciesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetOperatorCurrenciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorCurrenciesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorCurrenciesRequestMultiError) AllErrors() []error { return m }

// GetOperatorCurrenciesRequestValidationError is the validation error returned
// by GetOperatorCurrenciesRequest.Validate if the designated constraints
// aren't met.
type GetOperatorCurrenciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorCurrenciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorCurrenciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorCurrenciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorCurrenciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorCurrenciesRequestValidationError) ErrorName() string {
	return "GetOperatorCurrenciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorCurrenciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorCurrenciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorCurrenciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorCurrenciesRequestValidationError{}

// Validate checks the field values on GetOperatorCurrenciesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperatorCurrenciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorCurrenciesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetOperatorCurrenciesResponseMultiError, or nil if none found.
func (m *GetOperatorCurrenciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorCurrenciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCurrencies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOperatorCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOperatorCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOperatorCurrenciesResponseValidationError{
					field:  fmt.Sprintf("Currencies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetOperatorCurrenciesResponseMultiError(errors)
	}

	return nil
}

// GetOperatorCurrenciesResponseMultiError is an error wrapping multiple
// validation errors returned by GetOperatorCurrenciesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetOperatorCurrenciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorCurrenciesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorCurrenciesResponseMultiError) AllErrors() []error { return m }

// GetOperatorCurrenciesResponseValidationError is the validation error
// returned by GetOperatorCurrenciesResponse.Validate if the designated
// constraints aren't met.
type GetOperatorCurrenciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorCurrenciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorCurrenciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorCurrenciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorCurrenciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorCurrenciesResponseValidationError) ErrorName() string {
	return "GetOperatorCurrenciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorCurrenciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorCurrenciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorCurrenciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorCurrenciesResponseValidationError{}

// Validate checks the field values on ListCurrenciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCurrenciesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCurrenciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCurrenciesRequestMultiError, or nil if none found.
func (m *ListCurrenciesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCurrenciesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if len(errors) > 0 {
		return ListCurrenciesRequestMultiError(errors)
	}

	return nil
}

// ListCurrenciesRequestMultiError is an error wrapping multiple validation
// errors returned by ListCurrenciesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCurrenciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCurrenciesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCurrenciesRequestMultiError) AllErrors() []error { return m }

// ListCurrenciesRequestValidationError is the validation error returned by
// ListCurrenciesRequest.Validate if the designated constraints aren't met.
type ListCurrenciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCurrenciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCurrenciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCurrenciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCurrenciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCurrenciesRequestValidationError) ErrorName() string {
	return "ListCurrenciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCurrenciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCurrenciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCurrenciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCurrenciesRequestValidationError{}

// Validate checks the field values on ListCurrenciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCurrenciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCurrenciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCurrenciesResponseMultiError, or nil if none found.
func (m *ListCurrenciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCurrenciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCurrencies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCurrenciesResponseValidationError{
						field:  fmt.Sprintf("Currencies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCurrenciesResponseValidationError{
					field:  fmt.Sprintf("Currencies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for TotalEnabled

	// no validation rules for TotalHidden

	if len(errors) > 0 {
		return ListCurrenciesResponseMultiError(errors)
	}

	return nil
}

// ListCurrenciesResponseMultiError is an error wrapping multiple validation
// errors returned by ListCurrenciesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListCurrenciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCurrenciesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCurrenciesResponseMultiError) AllErrors() []error { return m }

// ListCurrenciesResponseValidationError is the validation error returned by
// ListCurrenciesResponse.Validate if the designated constraints aren't met.
type ListCurrenciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCurrenciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCurrenciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCurrenciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCurrenciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCurrenciesResponseValidationError) ErrorName() string {
	return "ListCurrenciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCurrenciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCurrenciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCurrenciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCurrenciesResponseValidationError{}

// Validate checks the field values on UpdateOperatorCurrencyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOperatorCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorCurrencyRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateOperatorCurrencyRequestMultiError, or nil if none found.
func (m *UpdateOperatorCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OperatorId

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorCurrencyRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Symbol != nil {
		// no validation rules for Symbol
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.DecimalPlaces != nil {
		// no validation rules for DecimalPlaces
	}

	if len(errors) > 0 {
		return UpdateOperatorCurrencyRequestMultiError(errors)
	}

	return nil
}

// UpdateOperatorCurrencyRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateOperatorCurrencyRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateOperatorCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorCurrencyRequestMultiError) AllErrors() []error { return m }

// UpdateOperatorCurrencyRequestValidationError is the validation error
// returned by UpdateOperatorCurrencyRequest.Validate if the designated
// constraints aren't met.
type UpdateOperatorCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorCurrencyRequestValidationError) ErrorName() string {
	return "UpdateOperatorCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorCurrencyRequestValidationError{}

// Validate checks the field values on UpdateOperatorCurrencyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOperatorCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorCurrencyResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateOperatorCurrencyResponseMultiError, or nil if none found.
func (m *UpdateOperatorCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateOperatorCurrencyResponseMultiError(errors)
	}

	return nil
}

// UpdateOperatorCurrencyResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateOperatorCurrencyResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateOperatorCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorCurrencyResponseMultiError) AllErrors() []error { return m }

// UpdateOperatorCurrencyResponseValidationError is the validation error
// returned by UpdateOperatorCurrencyResponse.Validate if the designated
// constraints aren't met.
type UpdateOperatorCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorCurrencyResponseValidationError) ErrorName() string {
	return "UpdateOperatorCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorCurrencyResponseValidationError{}

// Validate checks the field values on UpdateUserCurrencyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserCurrencyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserCurrencyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserCurrencyRequestMultiError, or nil if none found.
func (m *UpdateUserCurrencyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserCurrencyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Currency

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserCurrencyRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserCurrencyRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserCurrencyRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserCurrencyRequestMultiError(errors)
	}

	return nil
}

// UpdateUserCurrencyRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateUserCurrencyRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateUserCurrencyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserCurrencyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserCurrencyRequestMultiError) AllErrors() []error { return m }

// UpdateUserCurrencyRequestValidationError is the validation error returned by
// UpdateUserCurrencyRequest.Validate if the designated constraints aren't met.
type UpdateUserCurrencyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserCurrencyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserCurrencyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserCurrencyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserCurrencyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserCurrencyRequestValidationError) ErrorName() string {
	return "UpdateUserCurrencyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserCurrencyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserCurrencyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserCurrencyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserCurrencyRequestValidationError{}

// Validate checks the field values on UpdateUserCurrencyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserCurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserCurrencyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserCurrencyResponseMultiError, or nil if none found.
func (m *UpdateUserCurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserCurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateUserCurrencyResponseMultiError(errors)
	}

	return nil
}

// UpdateUserCurrencyResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateUserCurrencyResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateUserCurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserCurrencyResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserCurrencyResponseMultiError) AllErrors() []error { return m }

// UpdateUserCurrencyResponseValidationError is the validation error returned
// by UpdateUserCurrencyResponse.Validate if the designated constraints aren't met.
type UpdateUserCurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserCurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserCurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserCurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserCurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserCurrencyResponseValidationError) ErrorName() string {
	return "UpdateUserCurrencyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserCurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserCurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserCurrencyResponseValidationError{}

// Validate checks the field values on ListBottomOperatorBalancesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListBottomOperatorBalancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBottomOperatorBalancesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListBottomOperatorBalancesRequestMultiError, or nil if none found.
func (m *ListBottomOperatorBalancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBottomOperatorBalancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListBottomOperatorBalancesRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListBottomOperatorBalancesRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListBottomOperatorBalancesRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListBottomOperatorBalancesRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListBottomOperatorBalancesRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListBottomOperatorBalancesRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListBottomOperatorBalancesRequestMultiError(errors)
	}

	return nil
}

// ListBottomOperatorBalancesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListBottomOperatorBalancesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListBottomOperatorBalancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBottomOperatorBalancesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBottomOperatorBalancesRequestMultiError) AllErrors() []error { return m }

// ListBottomOperatorBalancesRequestValidationError is the validation error
// returned by ListBottomOperatorBalancesRequest.Validate if the designated
// constraints aren't met.
type ListBottomOperatorBalancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBottomOperatorBalancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBottomOperatorBalancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBottomOperatorBalancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBottomOperatorBalancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBottomOperatorBalancesRequestValidationError) ErrorName() string {
	return "ListBottomOperatorBalancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBottomOperatorBalancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBottomOperatorBalancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBottomOperatorBalancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBottomOperatorBalancesRequestValidationError{}

// Validate checks the field values on OperatorBalance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorBalanceMultiError, or nil if none found.
func (m *OperatorBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RetailerOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for OperatorName

	// no validation rules for Currency

	// no validation rules for Protocol

	// no validation rules for Cash

	// no validation rules for CashUsd

	// no validation rules for CashReportingCurrency

	// no validation rules for Enabled

	if len(errors) > 0 {
		return OperatorBalanceMultiError(errors)
	}

	return nil
}

// OperatorBalanceMultiError is an error wrapping multiple validation errors
// returned by OperatorBalance.ValidateAll() if the designated constraints
// aren't met.
type OperatorBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceMultiError) AllErrors() []error { return m }

// OperatorBalanceValidationError is the validation error returned by
// OperatorBalance.Validate if the designated constraints aren't met.
type OperatorBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceValidationError) ErrorName() string { return "OperatorBalanceValidationError" }

// Error satisfies the builtin error interface
func (e OperatorBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceValidationError{}

// Validate checks the field values on ListBottomOperatorBalancesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListBottomOperatorBalancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBottomOperatorBalancesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListBottomOperatorBalancesResponseMultiError, or nil if none found.
func (m *ListBottomOperatorBalancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBottomOperatorBalancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOperatorBalances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBottomOperatorBalancesResponseValidationError{
						field:  fmt.Sprintf("OperatorBalances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBottomOperatorBalancesResponseValidationError{
						field:  fmt.Sprintf("OperatorBalances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBottomOperatorBalancesResponseValidationError{
					field:  fmt.Sprintf("OperatorBalances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCashUsd

	// no validation rules for TotalCashReportingCurrency

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListBottomOperatorBalancesResponseMultiError(errors)
	}

	return nil
}

// ListBottomOperatorBalancesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListBottomOperatorBalancesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBottomOperatorBalancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBottomOperatorBalancesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBottomOperatorBalancesResponseMultiError) AllErrors() []error { return m }

// ListBottomOperatorBalancesResponseValidationError is the validation error
// returned by ListBottomOperatorBalancesResponse.Validate if the designated
// constraints aren't met.
type ListBottomOperatorBalancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBottomOperatorBalancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBottomOperatorBalancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBottomOperatorBalancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBottomOperatorBalancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBottomOperatorBalancesResponseValidationError) ErrorName() string {
	return "ListBottomOperatorBalancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBottomOperatorBalancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBottomOperatorBalancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBottomOperatorBalancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBottomOperatorBalancesResponseValidationError{}

// Validate checks the field values on OperatorTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorTransferRequestMultiError, or nil if none found.
func (m *OperatorTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorTransferRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorTransferRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorTransferRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorTransferRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorTransferRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorTransferRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TargetCurrency

	// no validation rules for TargetReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for CashAmount

	if len(errors) > 0 {
		return OperatorTransferRequestMultiError(errors)
	}

	return nil
}

// OperatorTransferRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorTransferRequestMultiError) AllErrors() []error { return m }

// OperatorTransferRequestValidationError is the validation error returned by
// OperatorTransferRequest.Validate if the designated constraints aren't met.
type OperatorTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorTransferRequestValidationError) ErrorName() string {
	return "OperatorTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorTransferRequestValidationError{}

// Validate checks the field values on OperatorTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorTransferResponseMultiError, or nil if none found.
func (m *OperatorTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OperatorCash

	// no validation rules for OperatorBalanceCurrency

	// no validation rules for TargetOperatorCash

	// no validation rules for TargetOperatorBalanceCurrency

	if len(errors) > 0 {
		return OperatorTransferResponseMultiError(errors)
	}

	return nil
}

// OperatorTransferResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorTransferResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorTransferResponseMultiError) AllErrors() []error { return m }

// OperatorTransferResponseValidationError is the validation error returned by
// OperatorTransferResponse.Validate if the designated constraints aren't met.
type OperatorTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorTransferResponseValidationError) ErrorName() string {
	return "OperatorTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorTransferResponseValidationError{}

// Validate checks the field values on OperatorSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorSwapRequestMultiError, or nil if none found.
func (m *OperatorSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSwapRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSwapRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSwapRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TargetCurrency

	// no validation rules for TargetReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for CashAmount

	if len(errors) > 0 {
		return OperatorSwapRequestMultiError(errors)
	}

	return nil
}

// OperatorSwapRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSwapRequestMultiError) AllErrors() []error { return m }

// OperatorSwapRequestValidationError is the validation error returned by
// OperatorSwapRequest.Validate if the designated constraints aren't met.
type OperatorSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSwapRequestValidationError) ErrorName() string {
	return "OperatorSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSwapRequestValidationError{}

// Validate checks the field values on OperatorSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorSwapResponseMultiError, or nil if none found.
func (m *OperatorSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrencyBalanceCash

	// no validation rules for CurrencyBalanceCashUsd

	// no validation rules for CurrencyBalanceCashReportingCurrency

	// no validation rules for TargetCurrencyBalanceCash

	// no validation rules for TargetCurrencyBalanceCashUsd

	// no validation rules for TargetCurrencyBalanceCashReportingCurrency

	if len(errors) > 0 {
		return OperatorSwapResponseMultiError(errors)
	}

	return nil
}

// OperatorSwapResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSwapResponseMultiError) AllErrors() []error { return m }

// OperatorSwapResponseValidationError is the validation error returned by
// OperatorSwapResponse.Validate if the designated constraints aren't met.
type OperatorSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSwapResponseValidationError) ErrorName() string {
	return "OperatorSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSwapResponseValidationError{}

// Validate checks the field values on OperatorFreezeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorFreezeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorFreezeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorFreezeRequestMultiError, or nil if none found.
func (m *OperatorFreezeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorFreezeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorFreezeRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorFreezeRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorFreezeRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorFreezeRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorFreezeRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorFreezeRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for CashAmount

	// no validation rules for Memo

	if m.ExternalTransactionId != nil {
		// no validation rules for ExternalTransactionId
	}

	if len(errors) > 0 {
		return OperatorFreezeRequestMultiError(errors)
	}

	return nil
}

// OperatorFreezeRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorFreezeRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorFreezeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorFreezeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorFreezeRequestMultiError) AllErrors() []error { return m }

// OperatorFreezeRequestValidationError is the validation error returned by
// OperatorFreezeRequest.Validate if the designated constraints aren't met.
type OperatorFreezeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorFreezeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorFreezeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorFreezeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorFreezeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorFreezeRequestValidationError) ErrorName() string {
	return "OperatorFreezeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorFreezeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorFreezeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorFreezeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorFreezeRequestValidationError{}

// Validate checks the field values on OperatorFreezeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorFreezeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorFreezeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorFreezeResponseMultiError, or nil if none found.
func (m *OperatorFreezeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorFreezeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	if len(errors) > 0 {
		return OperatorFreezeResponseMultiError(errors)
	}

	return nil
}

// OperatorFreezeResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorFreezeResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorFreezeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorFreezeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorFreezeResponseMultiError) AllErrors() []error { return m }

// OperatorFreezeResponseValidationError is the validation error returned by
// OperatorFreezeResponse.Validate if the designated constraints aren't met.
type OperatorFreezeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorFreezeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorFreezeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorFreezeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorFreezeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorFreezeResponseValidationError) ErrorName() string {
	return "OperatorFreezeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorFreezeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorFreezeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorFreezeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorFreezeResponseValidationError{}

// Validate checks the field values on OperatorRollbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorRollbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorRollbackRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorRollbackRequestMultiError, or nil if none found.
func (m *OperatorRollbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorRollbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorRollbackRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorRollbackRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorRollbackRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorRollbackRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorRollbackRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorRollbackRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OriginalTransactionId

	// no validation rules for TransactionType

	// no validation rules for Memo

	if m.ExternalTransactionId != nil {
		// no validation rules for ExternalTransactionId
	}

	if len(errors) > 0 {
		return OperatorRollbackRequestMultiError(errors)
	}

	return nil
}

// OperatorRollbackRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorRollbackRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorRollbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorRollbackRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorRollbackRequestMultiError) AllErrors() []error { return m }

// OperatorRollbackRequestValidationError is the validation error returned by
// OperatorRollbackRequest.Validate if the designated constraints aren't met.
type OperatorRollbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorRollbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorRollbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorRollbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorRollbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorRollbackRequestValidationError) ErrorName() string {
	return "OperatorRollbackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorRollbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorRollbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorRollbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorRollbackRequestValidationError{}

// Validate checks the field values on OperatorRollbackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorRollbackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorRollbackResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorRollbackResponseMultiError, or nil if none found.
func (m *OperatorRollbackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorRollbackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	// no validation rules for CashAmount

	// no validation rules for CashAmountUsd

	// no validation rules for CashAmountReportingCurrency

	if len(errors) > 0 {
		return OperatorRollbackResponseMultiError(errors)
	}

	return nil
}

// OperatorRollbackResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorRollbackResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorRollbackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorRollbackResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorRollbackResponseMultiError) AllErrors() []error { return m }

// OperatorRollbackResponseValidationError is the validation error returned by
// OperatorRollbackResponse.Validate if the designated constraints aren't met.
type OperatorRollbackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorRollbackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorRollbackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorRollbackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorRollbackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorRollbackResponseValidationError) ErrorName() string {
	return "OperatorRollbackResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorRollbackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorRollbackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorRollbackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorRollbackResponseValidationError{}

// Validate checks the field values on OperatorSettleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSettleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSettleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorSettleRequestMultiError, or nil if none found.
func (m *OperatorSettleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSettleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSettleRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSettleRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSettleRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSettleRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSettleRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSettleRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for OriginalTransactionId

	// no validation rules for TransactionType

	// no validation rules for Memo

	if m.ExternalTransactionId != nil {
		// no validation rules for ExternalTransactionId
	}

	if len(errors) > 0 {
		return OperatorSettleRequestMultiError(errors)
	}

	return nil
}

// OperatorSettleRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorSettleRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorSettleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSettleRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSettleRequestMultiError) AllErrors() []error { return m }

// OperatorSettleRequestValidationError is the validation error returned by
// OperatorSettleRequest.Validate if the designated constraints aren't met.
type OperatorSettleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSettleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSettleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSettleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSettleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSettleRequestValidationError) ErrorName() string {
	return "OperatorSettleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSettleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSettleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSettleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSettleRequestValidationError{}

// Validate checks the field values on OperatorSettleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorSettleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorSettleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorSettleResponseMultiError, or nil if none found.
func (m *OperatorSettleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSettleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	// no validation rules for CashAmount

	// no validation rules for CashAmountUsd

	// no validation rules for CashAmountReportingCurrency

	if len(errors) > 0 {
		return OperatorSettleResponseMultiError(errors)
	}

	return nil
}

// OperatorSettleResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorSettleResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorSettleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSettleResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSettleResponseMultiError) AllErrors() []error { return m }

// OperatorSettleResponseValidationError is the validation error returned by
// OperatorSettleResponse.Validate if the designated constraints aren't met.
type OperatorSettleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSettleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSettleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSettleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSettleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSettleResponseValidationError) ErrorName() string {
	return "OperatorSettleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSettleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSettleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSettleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSettleResponseValidationError{}

// Validate checks the field values on GetOperatorBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperatorBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOperatorBalanceRequestMultiError, or nil if none found.
func (m *GetOperatorBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOperatorBalanceRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOperatorBalanceRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOperatorBalanceRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOperatorBalanceRequestMultiError(errors)
	}

	return nil
}

// GetOperatorBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by GetOperatorBalanceRequest.ValidateAll() if the
// designated constraints aren't met.
type GetOperatorBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorBalanceRequestMultiError) AllErrors() []error { return m }

// GetOperatorBalanceRequestValidationError is the validation error returned by
// GetOperatorBalanceRequest.Validate if the designated constraints aren't met.
type GetOperatorBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorBalanceRequestValidationError) ErrorName() string {
	return "GetOperatorBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorBalanceRequestValidationError{}

// Validate checks the field values on GetOperatorBalanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperatorBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorBalanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOperatorBalanceResponseMultiError, or nil if none found.
func (m *GetOperatorBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOperatorBalances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOperatorBalanceResponseValidationError{
						field:  fmt.Sprintf("OperatorBalances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOperatorBalanceResponseValidationError{
						field:  fmt.Sprintf("OperatorBalances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOperatorBalanceResponseValidationError{
					field:  fmt.Sprintf("OperatorBalances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCashUsd

	// no validation rules for TotalCashReportingCurrency

	if len(errors) > 0 {
		return GetOperatorBalanceResponseMultiError(errors)
	}

	return nil
}

// GetOperatorBalanceResponseMultiError is an error wrapping multiple
// validation errors returned by GetOperatorBalanceResponse.ValidateAll() if
// the designated constraints aren't met.
type GetOperatorBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorBalanceResponseMultiError) AllErrors() []error { return m }

// GetOperatorBalanceResponseValidationError is the validation error returned
// by GetOperatorBalanceResponse.Validate if the designated constraints aren't met.
type GetOperatorBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorBalanceResponseValidationError) ErrorName() string {
	return "GetOperatorBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorBalanceResponseValidationError{}

// Validate checks the field values on ListOperatorBalanceTransactionsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListOperatorBalanceTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListOperatorBalanceTransactionsRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListOperatorBalanceTransactionsRequestMultiError, or nil if none found.
func (m *ListOperatorBalanceTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorBalanceTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOperatorBalanceTransactionsRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOperatorBalanceTransactionsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TargetOperatorType

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorBalanceTransactionsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsRequestValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorBalanceTransactionsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListOperatorBalanceTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListOperatorBalanceTransactionsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListOperatorBalanceTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListOperatorBalanceTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorBalanceTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorBalanceTransactionsRequestMultiError) AllErrors() []error { return m }

// ListOperatorBalanceTransactionsRequestValidationError is the validation
// error returned by ListOperatorBalanceTransactionsRequest.Validate if the
// designated constraints aren't met.
type ListOperatorBalanceTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorBalanceTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorBalanceTransactionsRequestValidationError) ErrorName() string {
	return "ListOperatorBalanceTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorBalanceTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorBalanceTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorBalanceTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorBalanceTransactionsRequestValidationError{}

// Validate checks the field values on OperatorBalanceTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorBalanceTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorBalanceTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorBalanceTransactionMultiError, or nil if none found.
func (m *OperatorBalanceTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorBalanceTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for ExternalTransactionId

	// no validation rules for RelatedTransactionId

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceTransactionValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SystemOperatorName

	// no validation rules for RetailerOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for OperatorName

	// no validation rules for Currency

	// no validation rules for SettlementCurrency

	// no validation rules for ReportingCurrency

	// no validation rules for BeforeBalance

	// no validation rules for BeforeBalanceUsd

	// no validation rules for BeforeBalanceReportingCurrency

	// no validation rules for AfterBalance

	// no validation rules for AfterBalanceUsd

	// no validation rules for AfterBalanceReportingCurrency

	// no validation rules for CashAmount

	// no validation rules for CashAmountUsd

	// no validation rules for CashAmountReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for Status

	// no validation rules for Memo

	// no validation rules for FeeAmount

	// no validation rules for FeeAmountUsd

	// no validation rules for FeeAmountReportingCurrency

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorBalanceTransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorBalanceTransactionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperatorBalanceTransactionMultiError(errors)
	}

	return nil
}

// OperatorBalanceTransactionMultiError is an error wrapping multiple
// validation errors returned by OperatorBalanceTransaction.ValidateAll() if
// the designated constraints aren't met.
type OperatorBalanceTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorBalanceTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorBalanceTransactionMultiError) AllErrors() []error { return m }

// OperatorBalanceTransactionValidationError is the validation error returned
// by OperatorBalanceTransaction.Validate if the designated constraints aren't met.
type OperatorBalanceTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorBalanceTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorBalanceTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorBalanceTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorBalanceTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorBalanceTransactionValidationError) ErrorName() string {
	return "OperatorBalanceTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorBalanceTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorBalanceTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorBalanceTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorBalanceTransactionValidationError{}

// Validate checks the field values on ListOperatorBalanceTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListOperatorBalanceTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListOperatorBalanceTransactionsResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListOperatorBalanceTransactionsResponseMultiError, or nil if none found.
func (m *ListOperatorBalanceTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOperatorBalanceTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOperatorBalanceTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOperatorBalanceTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListOperatorBalanceTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListOperatorBalanceTransactionsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListOperatorBalanceTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListOperatorBalanceTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOperatorBalanceTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOperatorBalanceTransactionsResponseMultiError) AllErrors() []error { return m }

// ListOperatorBalanceTransactionsResponseValidationError is the validation
// error returned by ListOperatorBalanceTransactionsResponse.Validate if the
// designated constraints aren't met.
type ListOperatorBalanceTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOperatorBalanceTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOperatorBalanceTransactionsResponseValidationError) ErrorName() string {
	return "ListOperatorBalanceTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListOperatorBalanceTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOperatorBalanceTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOperatorBalanceTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOperatorBalanceTransactionsResponseValidationError{}

// Validate checks the field values on OperatorDebitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorDebitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorDebitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorDebitRequestMultiError, or nil if none found.
func (m *OperatorDebitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorDebitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorDebitRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorDebitRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorDebitRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for ReportingCurrency

	// no validation rules for TransactionType

	// no validation rules for CashAmount

	if m.ExternalTransactionId != nil {
		// no validation rules for ExternalTransactionId
	}

	if len(errors) > 0 {
		return OperatorDebitRequestMultiError(errors)
	}

	return nil
}

// OperatorDebitRequestMultiError is an error wrapping multiple validation
// errors returned by OperatorDebitRequest.ValidateAll() if the designated
// constraints aren't met.
type OperatorDebitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorDebitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorDebitRequestMultiError) AllErrors() []error { return m }

// OperatorDebitRequestValidationError is the validation error returned by
// OperatorDebitRequest.Validate if the designated constraints aren't met.
type OperatorDebitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorDebitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorDebitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorDebitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorDebitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorDebitRequestValidationError) ErrorName() string {
	return "OperatorDebitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorDebitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorDebitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorDebitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorDebitRequestValidationError{}

// Validate checks the field values on OperatorDebitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorDebitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorDebitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorDebitResponseMultiError, or nil if none found.
func (m *OperatorDebitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorDebitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Cash

	if len(errors) > 0 {
		return OperatorDebitResponseMultiError(errors)
	}

	return nil
}

// OperatorDebitResponseMultiError is an error wrapping multiple validation
// errors returned by OperatorDebitResponse.ValidateAll() if the designated
// constraints aren't met.
type OperatorDebitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorDebitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorDebitResponseMultiError) AllErrors() []error { return m }

// OperatorDebitResponseValidationError is the validation error returned by
// OperatorDebitResponse.Validate if the designated constraints aren't met.
type OperatorDebitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorDebitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorDebitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorDebitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorDebitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorDebitResponseValidationError) ErrorName() string {
	return "OperatorDebitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorDebitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorDebitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorDebitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorDebitResponseValidationError{}

// Validate checks the field values on UpdateOperatorBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOperatorBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOperatorBalanceRequestMultiError, or nil if none found.
func (m *UpdateOperatorBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitialOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorBalanceRequestValidationError{
					field:  "InitialOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorBalanceRequestValidationError{
					field:  "InitialOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorBalanceRequestValidationError{
				field:  "InitialOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorBalanceRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorBalanceRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorBalanceRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateOperatorBalanceRequestMultiError(errors)
	}

	return nil
}

// UpdateOperatorBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateOperatorBalanceRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateOperatorBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorBalanceRequestMultiError) AllErrors() []error { return m }

// UpdateOperatorBalanceRequestValidationError is the validation error returned
// by UpdateOperatorBalanceRequest.Validate if the designated constraints
// aren't met.
type UpdateOperatorBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorBalanceRequestValidationError) ErrorName() string {
	return "UpdateOperatorBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorBalanceRequestValidationError{}

// Validate checks the field values on UpdateOperatorBalanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateOperatorBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorBalanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateOperatorBalanceResponseMultiError, or nil if none found.
func (m *UpdateOperatorBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateOperatorBalanceResponseMultiError(errors)
	}

	return nil
}

// UpdateOperatorBalanceResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateOperatorBalanceResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateOperatorBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorBalanceResponseMultiError) AllErrors() []error { return m }

// UpdateOperatorBalanceResponseValidationError is the validation error
// returned by UpdateOperatorBalanceResponse.Validate if the designated
// constraints aren't met.
type UpdateOperatorBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorBalanceResponseValidationError) ErrorName() string {
	return "UpdateOperatorBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorBalanceResponseValidationError{}

// Validate checks the field values on GetOperatorTransactionSummaryRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetOperatorTransactionSummaryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorTransactionSummaryRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetOperatorTransactionSummaryRequestMultiError, or nil if none found.
func (m *GetOperatorTransactionSummaryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorTransactionSummaryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOperatorTransactionSummaryRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOperatorTransactionSummaryRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOperatorTransactionSummaryRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if m.StartTime != nil {
		// no validation rules for StartTime
	}

	if m.EndTime != nil {
		// no validation rules for EndTime
	}

	if len(errors) > 0 {
		return GetOperatorTransactionSummaryRequestMultiError(errors)
	}

	return nil
}

// GetOperatorTransactionSummaryRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetOperatorTransactionSummaryRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOperatorTransactionSummaryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorTransactionSummaryRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorTransactionSummaryRequestMultiError) AllErrors() []error { return m }

// GetOperatorTransactionSummaryRequestValidationError is the validation error
// returned by GetOperatorTransactionSummaryRequest.Validate if the designated
// constraints aren't met.
type GetOperatorTransactionSummaryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorTransactionSummaryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorTransactionSummaryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorTransactionSummaryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorTransactionSummaryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorTransactionSummaryRequestValidationError) ErrorName() string {
	return "GetOperatorTransactionSummaryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorTransactionSummaryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorTransactionSummaryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorTransactionSummaryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorTransactionSummaryRequestValidationError{}

// Validate checks the field values on GetOperatorTransactionSummaryResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetOperatorTransactionSummaryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperatorTransactionSummaryResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetOperatorTransactionSummaryResponseMultiError, or nil if none found.
func (m *GetOperatorTransactionSummaryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorTransactionSummaryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalWithdrawUsd

	// no validation rules for TotalDepositUsd

	// no validation rules for TotalTransferOutUsd

	// no validation rules for TotalTransferInUsd

	// no validation rules for TotalSwapOutUsd

	// no validation rules for TotalSwapInUsd

	// no validation rules for TotalFreezeUsd

	// no validation rules for TotalRollbackUsd

	// no validation rules for ReportingCurrency

	// no validation rules for TotalWithdrawReportingCurrency

	// no validation rules for TotalDepositReportingCurrency

	// no validation rules for TotalTransferOutReportingCurrency

	// no validation rules for TotalTransferInReportingCurrency

	// no validation rules for TotalSwapOutReportingCurrency

	// no validation rules for TotalSwapInReportingCurrency

	// no validation rules for TotalFreezeReportingCurrency

	// no validation rules for TotalRollbackReportingCurrency

	if len(errors) > 0 {
		return GetOperatorTransactionSummaryResponseMultiError(errors)
	}

	return nil
}

// GetOperatorTransactionSummaryResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetOperatorTransactionSummaryResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOperatorTransactionSummaryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorTransactionSummaryResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorTransactionSummaryResponseMultiError) AllErrors() []error { return m }

// GetOperatorTransactionSummaryResponseValidationError is the validation error
// returned by GetOperatorTransactionSummaryResponse.Validate if the
// designated constraints aren't met.
type GetOperatorTransactionSummaryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorTransactionSummaryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorTransactionSummaryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorTransactionSummaryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorTransactionSummaryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorTransactionSummaryResponseValidationError) ErrorName() string {
	return "GetOperatorTransactionSummaryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorTransactionSummaryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorTransactionSummaryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorTransactionSummaryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorTransactionSummaryResponseValidationError{}

// Validate checks the field values on
// GetOperatorBalanceTransactionsByIdsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOperatorBalanceTransactionsByIdsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOperatorBalanceTransactionsByIdsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetOperatorBalanceTransactionsByIdsRequestMultiError, or nil if none found.
func (m *GetOperatorBalanceTransactionsByIdsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorBalanceTransactionsByIdsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOperatorBalanceTransactionsByIdsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOperatorBalanceTransactionsByIdsRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOperatorBalanceTransactionsByIdsRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOperatorBalanceTransactionsByIdsRequestMultiError(errors)
	}

	return nil
}

// GetOperatorBalanceTransactionsByIdsRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetOperatorBalanceTransactionsByIdsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOperatorBalanceTransactionsByIdsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorBalanceTransactionsByIdsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorBalanceTransactionsByIdsRequestMultiError) AllErrors() []error { return m }

// GetOperatorBalanceTransactionsByIdsRequestValidationError is the validation
// error returned by GetOperatorBalanceTransactionsByIdsRequest.Validate if
// the designated constraints aren't met.
type GetOperatorBalanceTransactionsByIdsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorBalanceTransactionsByIdsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorBalanceTransactionsByIdsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorBalanceTransactionsByIdsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorBalanceTransactionsByIdsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorBalanceTransactionsByIdsRequestValidationError) ErrorName() string {
	return "GetOperatorBalanceTransactionsByIdsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorBalanceTransactionsByIdsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorBalanceTransactionsByIdsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorBalanceTransactionsByIdsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorBalanceTransactionsByIdsRequestValidationError{}

// Validate checks the field values on
// GetOperatorBalanceTransactionsByIdsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOperatorBalanceTransactionsByIdsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOperatorBalanceTransactionsByIdsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetOperatorBalanceTransactionsByIdsResponseMultiError, or nil if none found.
func (m *GetOperatorBalanceTransactionsByIdsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperatorBalanceTransactionsByIdsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOperatorBalanceTransactionsByIdsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOperatorBalanceTransactionsByIdsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOperatorBalanceTransactionsByIdsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetOperatorBalanceTransactionsByIdsResponseMultiError(errors)
	}

	return nil
}

// GetOperatorBalanceTransactionsByIdsResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetOperatorBalanceTransactionsByIdsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOperatorBalanceTransactionsByIdsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperatorBalanceTransactionsByIdsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperatorBalanceTransactionsByIdsResponseMultiError) AllErrors() []error { return m }

// GetOperatorBalanceTransactionsByIdsResponseValidationError is the validation
// error returned by GetOperatorBalanceTransactionsByIdsResponse.Validate if
// the designated constraints aren't met.
type GetOperatorBalanceTransactionsByIdsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperatorBalanceTransactionsByIdsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperatorBalanceTransactionsByIdsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperatorBalanceTransactionsByIdsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperatorBalanceTransactionsByIdsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperatorBalanceTransactionsByIdsResponseValidationError) ErrorName() string {
	return "GetOperatorBalanceTransactionsByIdsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperatorBalanceTransactionsByIdsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperatorBalanceTransactionsByIdsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperatorBalanceTransactionsByIdsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperatorBalanceTransactionsByIdsResponseValidationError{}

// Validate checks the field values on RewardSequence with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RewardSequence) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RewardSequence with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RewardSequenceMultiError,
// or nil if none found.
func (m *RewardSequence) ValidateAll() error {
	return m.validate(true)
}

func (m *RewardSequence) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SerialNumber

	// no validation rules for Name

	// no validation rules for Enabled

	// no validation rules for RewardType

	// no validation rules for WageringRequirement

	// no validation rules for RewardValidity

	for idx, item := range m.GetTierConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RewardSequenceValidationError{
						field:  fmt.Sprintf("TierConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RewardSequenceValidationError{
						field:  fmt.Sprintf("TierConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RewardSequenceValidationError{
					field:  fmt.Sprintf("TierConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RewardSequenceValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RewardSequenceValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RewardSequenceValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RewardSequenceValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RewardSequenceValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RewardSequenceValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RewardSequenceMultiError(errors)
	}

	return nil
}

// RewardSequenceMultiError is an error wrapping multiple validation errors
// returned by RewardSequence.ValidateAll() if the designated constraints
// aren't met.
type RewardSequenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RewardSequenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RewardSequenceMultiError) AllErrors() []error { return m }

// RewardSequenceValidationError is the validation error returned by
// RewardSequence.Validate if the designated constraints aren't met.
type RewardSequenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RewardSequenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RewardSequenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RewardSequenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RewardSequenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RewardSequenceValidationError) ErrorName() string { return "RewardSequenceValidationError" }

// Error satisfies the builtin error interface
func (e RewardSequenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRewardSequence.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RewardSequenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RewardSequenceValidationError{}

// Validate checks the field values on DepositRewardConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DepositRewardConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositRewardConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DepositRewardConfigMultiError, or nil if none found.
func (m *DepositRewardConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositRewardConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WelcomeRewardEnabled

	// no validation rules for DailyRewardEnabled

	for idx, item := range m.GetWelcomeRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DepositRewardConfigValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DepositRewardConfigValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DepositRewardConfigValidationError{
					field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDailyRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DepositRewardConfigValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DepositRewardConfigValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DepositRewardConfigValidationError{
					field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DepositRewardConfigValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DepositRewardConfigValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DepositRewardConfigValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DepositRewardConfigValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DepositRewardConfigValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DepositRewardConfigValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DepositRewardConfigMultiError(errors)
	}

	return nil
}

// DepositRewardConfigMultiError is an error wrapping multiple validation
// errors returned by DepositRewardConfig.ValidateAll() if the designated
// constraints aren't met.
type DepositRewardConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositRewardConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositRewardConfigMultiError) AllErrors() []error { return m }

// DepositRewardConfigValidationError is the validation error returned by
// DepositRewardConfig.Validate if the designated constraints aren't met.
type DepositRewardConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositRewardConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositRewardConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositRewardConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositRewardConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositRewardConfigValidationError) ErrorName() string {
	return "DepositRewardConfigValidationError"
}

// Error satisfies the builtin error interface
func (e DepositRewardConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositRewardConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositRewardConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositRewardConfigValidationError{}

// Validate checks the field values on SetDepositRewardSequencesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SetDepositRewardSequencesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDepositRewardSequencesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetDepositRewardSequencesRequestMultiError, or nil if none found.
func (m *SetDepositRewardSequencesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDepositRewardSequencesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitiatorOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDepositRewardSequencesRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDepositRewardSequencesRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitiatorOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDepositRewardSequencesRequestValidationError{
				field:  "InitiatorOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetDepositRewardSequencesRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for Currency

	for idx, item := range m.GetWelcomeRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetDepositRewardSequencesRequestValidationError{
					field:  fmt.Sprintf("WelcomeRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDailyRewardSequences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetDepositRewardSequencesRequestValidationError{
						field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetDepositRewardSequencesRequestValidationError{
					field:  fmt.Sprintf("DailyRewardSequences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FollowParent != nil {
		// no validation rules for FollowParent
	}

	if m.WelcomeRewardEnabled != nil {
		// no validation rules for WelcomeRewardEnabled
	}

	if m.DailyRewardEnabled != nil {
		// no validation rules for DailyRewardEnabled
	}

	if len(errors) > 0 {
		return SetDepositRewardSequencesRequestMultiError(errors)
	}

	return nil
}

// SetDepositRewardSequencesRequestMultiError is an error wrapping multiple
// validation errors returned by
// SetDepositRewardSequencesRequest.ValidateAll() if the designated
// constraints aren't met.
type SetDepositRewardSequencesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDepositRewardSequencesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDepositRewardSequencesRequestMultiError) AllErrors() []error { return m }

// SetDepositRewardSequencesRequestValidationError is the validation error
// returned by SetDepositRewardSequencesRequest.Validate if the designated
// constraints aren't met.
type SetDepositRewardSequencesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDepositRewardSequencesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDepositRewardSequencesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDepositRewardSequencesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDepositRewardSequencesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDepositRewardSequencesRequestValidationError) ErrorName() string {
	return "SetDepositRewardSequencesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetDepositRewardSequencesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDepositRewardSequencesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDepositRewardSequencesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDepositRewardSequencesRequestValidationError{}

// Validate checks the field values on SetDepositRewardSequencesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SetDepositRewardSequencesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDepositRewardSequencesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SetDepositRewardSequencesResponseMultiError, or nil if none found.
func (m *SetDepositRewardSequencesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDepositRewardSequencesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetDepositRewardSequencesResponseMultiError(errors)
	}

	return nil
}

// SetDepositRewardSequencesResponseMultiError is an error wrapping multiple
// validation errors returned by
// SetDepositRewardSequencesResponse.ValidateAll() if the designated
// constraints aren't met.
type SetDepositRewardSequencesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDepositRewardSequencesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDepositRewardSequencesResponseMultiError) AllErrors() []error { return m }

// SetDepositRewardSequencesResponseValidationError is the validation error
// returned by SetDepositRewardSequencesResponse.Validate if the designated
// constraints aren't met.
type SetDepositRewardSequencesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDepositRewardSequencesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDepositRewardSequencesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDepositRewardSequencesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDepositRewardSequencesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDepositRewardSequencesResponseValidationError) ErrorName() string {
	return "SetDepositRewardSequencesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetDepositRewardSequencesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDepositRewardSequencesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDepositRewardSequencesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDepositRewardSequencesResponseValidationError{}

// Validate checks the field values on DeleteDepositRewardSequencesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteDepositRewardSequencesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDepositRewardSequencesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteDepositRewardSequencesRequestMultiError, or nil if none found.
func (m *DeleteDepositRewardSequencesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDepositRewardSequencesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitiatorOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitiatorOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDepositRewardSequencesRequestValidationError{
				field:  "InitiatorOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDepositRewardSequencesRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDepositRewardSequencesRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for Currency

	if len(errors) > 0 {
		return DeleteDepositRewardSequencesRequestMultiError(errors)
	}

	return nil
}

// DeleteDepositRewardSequencesRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteDepositRewardSequencesRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDepositRewardSequencesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDepositRewardSequencesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDepositRewardSequencesRequestMultiError) AllErrors() []error { return m }

// DeleteDepositRewardSequencesRequestValidationError is the validation error
// returned by DeleteDepositRewardSequencesRequest.Validate if the designated
// constraints aren't met.
type DeleteDepositRewardSequencesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDepositRewardSequencesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDepositRewardSequencesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDepositRewardSequencesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDepositRewardSequencesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDepositRewardSequencesRequestValidationError) ErrorName() string {
	return "DeleteDepositRewardSequencesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDepositRewardSequencesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDepositRewardSequencesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDepositRewardSequencesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDepositRewardSequencesRequestValidationError{}

// Validate checks the field values on DeleteDepositRewardSequencesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DeleteDepositRewardSequencesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDepositRewardSequencesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteDepositRewardSequencesResponseMultiError, or nil if none found.
func (m *DeleteDepositRewardSequencesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDepositRewardSequencesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteDepositRewardSequencesResponseMultiError(errors)
	}

	return nil
}

// DeleteDepositRewardSequencesResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteDepositRewardSequencesResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteDepositRewardSequencesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDepositRewardSequencesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDepositRewardSequencesResponseMultiError) AllErrors() []error { return m }

// DeleteDepositRewardSequencesResponseValidationError is the validation error
// returned by DeleteDepositRewardSequencesResponse.Validate if the designated
// constraints aren't met.
type DeleteDepositRewardSequencesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDepositRewardSequencesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDepositRewardSequencesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDepositRewardSequencesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDepositRewardSequencesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDepositRewardSequencesResponseValidationError) ErrorName() string {
	return "DeleteDepositRewardSequencesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDepositRewardSequencesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDepositRewardSequencesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDepositRewardSequencesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDepositRewardSequencesResponseValidationError{}

// Validate checks the field values on GetDepositRewardConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDepositRewardConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepositRewardConfigRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDepositRewardConfigRequestMultiError, or nil if none found.
func (m *GetDepositRewardConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepositRewardConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitiatorOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitiatorOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigRequestValidationError{
				field:  "InitiatorOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	if len(errors) > 0 {
		return GetDepositRewardConfigRequestMultiError(errors)
	}

	return nil
}

// GetDepositRewardConfigRequestMultiError is an error wrapping multiple
// validation errors returned by GetDepositRewardConfigRequest.ValidateAll()
// if the designated constraints aren't met.
type GetDepositRewardConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepositRewardConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepositRewardConfigRequestMultiError) AllErrors() []error { return m }

// GetDepositRewardConfigRequestValidationError is the validation error
// returned by GetDepositRewardConfigRequest.Validate if the designated
// constraints aren't met.
type GetDepositRewardConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepositRewardConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepositRewardConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepositRewardConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepositRewardConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepositRewardConfigRequestValidationError) ErrorName() string {
	return "GetDepositRewardConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDepositRewardConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepositRewardConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepositRewardConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepositRewardConfigRequestValidationError{}

// Validate checks the field values on GetDepositRewardConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDepositRewardConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepositRewardConfigResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDepositRewardConfigResponseMultiError, or nil if none found.
func (m *GetDepositRewardConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepositRewardConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCustomOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "CustomOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "CustomOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigResponseValidationError{
				field:  "CustomOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetInheritedOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "InheritedOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "InheritedOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInheritedOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigResponseValidationError{
				field:  "InheritedOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InheritedFromOperatorName

	// no validation rules for FollowParent

	// no validation rules for WelcomeRewardSequencesMinCount

	// no validation rules for DailyRewardSequencesMinCount

	if all {
		switch v := interface{}(m.GetDefaultDepositRewardConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "DefaultDepositRewardConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "DefaultDepositRewardConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultDepositRewardConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigResponseValidationError{
				field:  "DefaultDepositRewardConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCustomDepositRewardConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "CustomDepositRewardConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepositRewardConfigResponseValidationError{
					field:  "CustomDepositRewardConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomDepositRewardConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepositRewardConfigResponseValidationError{
				field:  "CustomDepositRewardConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDepositRewardConfigResponseMultiError(errors)
	}

	return nil
}

// GetDepositRewardConfigResponseMultiError is an error wrapping multiple
// validation errors returned by GetDepositRewardConfigResponse.ValidateAll()
// if the designated constraints aren't met.
type GetDepositRewardConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepositRewardConfigResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepositRewardConfigResponseMultiError) AllErrors() []error { return m }

// GetDepositRewardConfigResponseValidationError is the validation error
// returned by GetDepositRewardConfigResponse.Validate if the designated
// constraints aren't met.
type GetDepositRewardConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepositRewardConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepositRewardConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepositRewardConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepositRewardConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepositRewardConfigResponseValidationError) ErrorName() string {
	return "GetDepositRewardConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDepositRewardConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepositRewardConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepositRewardConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepositRewardConfigResponseValidationError{}

// Validate checks the field values on GetUserDepositRewardSequenceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetUserDepositRewardSequenceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserDepositRewardSequenceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetUserDepositRewardSequenceRequestMultiError, or nil if none found.
func (m *GetUserDepositRewardSequenceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserDepositRewardSequenceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if len(errors) > 0 {
		return GetUserDepositRewardSequenceRequestMultiError(errors)
	}

	return nil
}

// GetUserDepositRewardSequenceRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetUserDepositRewardSequenceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserDepositRewardSequenceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserDepositRewardSequenceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserDepositRewardSequenceRequestMultiError) AllErrors() []error { return m }

// GetUserDepositRewardSequenceRequestValidationError is the validation error
// returned by GetUserDepositRewardSequenceRequest.Validate if the designated
// constraints aren't met.
type GetUserDepositRewardSequenceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserDepositRewardSequenceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserDepositRewardSequenceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserDepositRewardSequenceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserDepositRewardSequenceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserDepositRewardSequenceRequestValidationError) ErrorName() string {
	return "GetUserDepositRewardSequenceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserDepositRewardSequenceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserDepositRewardSequenceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserDepositRewardSequenceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserDepositRewardSequenceRequestValidationError{}

// Validate checks the field values on GetUserDepositRewardSequenceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetUserDepositRewardSequenceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserDepositRewardSequenceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetUserDepositRewardSequenceResponseMultiError, or nil if none found.
func (m *GetUserDepositRewardSequenceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserDepositRewardSequenceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrentSequenceType

	// no validation rules for WelcomeRewardCount

	// no validation rules for DailyRewardCount

	if all {
		switch v := interface{}(m.GetCurrentRewardSequence()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserDepositRewardSequenceResponseValidationError{
					field:  "CurrentRewardSequence",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserDepositRewardSequenceResponseValidationError{
					field:  "CurrentRewardSequence",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentRewardSequence()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserDepositRewardSequenceResponseValidationError{
				field:  "CurrentRewardSequence",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserDepositRewardSequenceResponseMultiError(errors)
	}

	return nil
}

// GetUserDepositRewardSequenceResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetUserDepositRewardSequenceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserDepositRewardSequenceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserDepositRewardSequenceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserDepositRewardSequenceResponseMultiError) AllErrors() []error { return m }

// GetUserDepositRewardSequenceResponseValidationError is the validation error
// returned by GetUserDepositRewardSequenceResponse.Validate if the designated
// constraints aren't met.
type GetUserDepositRewardSequenceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserDepositRewardSequenceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserDepositRewardSequenceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserDepositRewardSequenceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserDepositRewardSequenceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserDepositRewardSequenceResponseValidationError) ErrorName() string {
	return "GetUserDepositRewardSequenceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserDepositRewardSequenceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserDepositRewardSequenceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserDepositRewardSequenceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserDepositRewardSequenceResponseValidationError{}

// Validate checks the field values on GetGamificationCurrencyConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetGamificationCurrencyConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGamificationCurrencyConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetGamificationCurrencyConfigRequestMultiError, or nil if none found.
func (m *GetGamificationCurrencyConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGamificationCurrencyConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitiatorOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitiatorOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGamificationCurrencyConfigRequestValidationError{
				field:  "InitiatorOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGamificationCurrencyConfigRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetGamificationCurrencyConfigRequestMultiError(errors)
	}

	return nil
}

// GetGamificationCurrencyConfigRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetGamificationCurrencyConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type GetGamificationCurrencyConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGamificationCurrencyConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGamificationCurrencyConfigRequestMultiError) AllErrors() []error { return m }

// GetGamificationCurrencyConfigRequestValidationError is the validation error
// returned by GetGamificationCurrencyConfigRequest.Validate if the designated
// constraints aren't met.
type GetGamificationCurrencyConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGamificationCurrencyConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGamificationCurrencyConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGamificationCurrencyConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGamificationCurrencyConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGamificationCurrencyConfigRequestValidationError) ErrorName() string {
	return "GetGamificationCurrencyConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetGamificationCurrencyConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGamificationCurrencyConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGamificationCurrencyConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGamificationCurrencyConfigRequestValidationError{}

// Validate checks the field values on DeductionOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeductionOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeductionOrder with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeductionOrderMultiError,
// or nil if none found.
func (m *DeductionOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *DeductionOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeductionType

	if m.CashRatio != nil {
		// no validation rules for CashRatio
	}

	if m.BonusRatio != nil {
		// no validation rules for BonusRatio
	}

	if len(errors) > 0 {
		return DeductionOrderMultiError(errors)
	}

	return nil
}

// DeductionOrderMultiError is an error wrapping multiple validation errors
// returned by DeductionOrder.ValidateAll() if the designated constraints
// aren't met.
type DeductionOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeductionOrderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeductionOrderMultiError) AllErrors() []error { return m }

// DeductionOrderValidationError is the validation error returned by
// DeductionOrder.Validate if the designated constraints aren't met.
type DeductionOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeductionOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeductionOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeductionOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeductionOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeductionOrderValidationError) ErrorName() string { return "DeductionOrderValidationError" }

// Error satisfies the builtin error interface
func (e DeductionOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeductionOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeductionOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeductionOrderValidationError{}

// Validate checks the field values on OperatorCurrencyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperatorCurrencyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperatorCurrencyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperatorCurrencyConfigMultiError, or nil if none found.
func (m *OperatorCurrencyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorCurrencyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if m.CashWithdrawalWageringRequirement != nil {
		// no validation rules for CashWithdrawalWageringRequirement
	}

	if m.BonusEnabled != nil {
		// no validation rules for BonusEnabled
	}

	if m.MaximumBonusBetLimit != nil {
		// no validation rules for MaximumBonusBetLimit
	}

	if m.WageringUnlockPriority != nil {
		// no validation rules for WageringUnlockPriority
	}

	if len(errors) > 0 {
		return OperatorCurrencyConfigMultiError(errors)
	}

	return nil
}

// OperatorCurrencyConfigMultiError is an error wrapping multiple validation
// errors returned by OperatorCurrencyConfig.ValidateAll() if the designated
// constraints aren't met.
type OperatorCurrencyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorCurrencyConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorCurrencyConfigMultiError) AllErrors() []error { return m }

// OperatorCurrencyConfigValidationError is the validation error returned by
// OperatorCurrencyConfig.Validate if the designated constraints aren't met.
type OperatorCurrencyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorCurrencyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorCurrencyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorCurrencyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorCurrencyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorCurrencyConfigValidationError) ErrorName() string {
	return "OperatorCurrencyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorCurrencyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorCurrencyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorCurrencyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorCurrencyConfigValidationError{}

// Validate checks the field values on GetGamificationCurrencyConfigResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetGamificationCurrencyConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGamificationCurrencyConfigResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetGamificationCurrencyConfigResponseMultiError, or nil if none found.
func (m *GetGamificationCurrencyConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGamificationCurrencyConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeductionOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigResponseValidationError{
					field:  "DeductionOrder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGamificationCurrencyConfigResponseValidationError{
					field:  "DeductionOrder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeductionOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGamificationCurrencyConfigResponseValidationError{
				field:  "DeductionOrder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOperatorCurrencyConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetGamificationCurrencyConfigResponseValidationError{
						field:  fmt.Sprintf("OperatorCurrencyConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetGamificationCurrencyConfigResponseValidationError{
						field:  fmt.Sprintf("OperatorCurrencyConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetGamificationCurrencyConfigResponseValidationError{
					field:  fmt.Sprintf("OperatorCurrencyConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetGamificationCurrencyConfigResponseMultiError(errors)
	}

	return nil
}

// GetGamificationCurrencyConfigResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetGamificationCurrencyConfigResponse.ValidateAll() if the designated
// constraints aren't met.
type GetGamificationCurrencyConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGamificationCurrencyConfigResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGamificationCurrencyConfigResponseMultiError) AllErrors() []error { return m }

// GetGamificationCurrencyConfigResponseValidationError is the validation error
// returned by GetGamificationCurrencyConfigResponse.Validate if the
// designated constraints aren't met.
type GetGamificationCurrencyConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGamificationCurrencyConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGamificationCurrencyConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGamificationCurrencyConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGamificationCurrencyConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGamificationCurrencyConfigResponseValidationError) ErrorName() string {
	return "GetGamificationCurrencyConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetGamificationCurrencyConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGamificationCurrencyConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGamificationCurrencyConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGamificationCurrencyConfigResponseValidationError{}

// Validate checks the field values on UpdateOperatorCurrencyConfigRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateOperatorCurrencyConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorCurrencyConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateOperatorCurrencyConfigRequestMultiError, or nil if none found.
func (m *UpdateOperatorCurrencyConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorCurrencyConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitiatorOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitiatorOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorCurrencyConfigRequestValidationError{
				field:  "InitiatorOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorCurrencyConfigRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorCurrencyConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "OperatorCurrencyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOperatorCurrencyConfigRequestValidationError{
					field:  "OperatorCurrencyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorCurrencyConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOperatorCurrencyConfigRequestValidationError{
				field:  "OperatorCurrencyConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateOperatorCurrencyConfigRequestMultiError(errors)
	}

	return nil
}

// UpdateOperatorCurrencyConfigRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateOperatorCurrencyConfigRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateOperatorCurrencyConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorCurrencyConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorCurrencyConfigRequestMultiError) AllErrors() []error { return m }

// UpdateOperatorCurrencyConfigRequestValidationError is the validation error
// returned by UpdateOperatorCurrencyConfigRequest.Validate if the designated
// constraints aren't met.
type UpdateOperatorCurrencyConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorCurrencyConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorCurrencyConfigRequestValidationError) ErrorName() string {
	return "UpdateOperatorCurrencyConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorCurrencyConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorCurrencyConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorCurrencyConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorCurrencyConfigRequestValidationError{}

// Validate checks the field values on UpdateOperatorCurrencyConfigResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateOperatorCurrencyConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOperatorCurrencyConfigResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateOperatorCurrencyConfigResponseMultiError, or nil if none found.
func (m *UpdateOperatorCurrencyConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOperatorCurrencyConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateOperatorCurrencyConfigResponseMultiError(errors)
	}

	return nil
}

// UpdateOperatorCurrencyConfigResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateOperatorCurrencyConfigResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateOperatorCurrencyConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOperatorCurrencyConfigResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOperatorCurrencyConfigResponseMultiError) AllErrors() []error { return m }

// UpdateOperatorCurrencyConfigResponseValidationError is the validation error
// returned by UpdateOperatorCurrencyConfigResponse.Validate if the designated
// constraints aren't met.
type UpdateOperatorCurrencyConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOperatorCurrencyConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOperatorCurrencyConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOperatorCurrencyConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOperatorCurrencyConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOperatorCurrencyConfigResponseValidationError) ErrorName() string {
	return "UpdateOperatorCurrencyConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateOperatorCurrencyConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOperatorCurrencyConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOperatorCurrencyConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOperatorCurrencyConfigResponseValidationError{}

// Validate checks the field values on UpdateDeductionOrderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeductionOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeductionOrderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeductionOrderRequestMultiError, or nil if none found.
func (m *UpdateDeductionOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeductionOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitiatorOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "InitiatorOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitiatorOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeductionOrderRequestValidationError{
				field:  "InitiatorOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "TargetOperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeductionOrderRequestValidationError{
				field:  "TargetOperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeductionOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "DeductionOrder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDeductionOrderRequestValidationError{
					field:  "DeductionOrder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeductionOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDeductionOrderRequestValidationError{
				field:  "DeductionOrder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDeductionOrderRequestMultiError(errors)
	}

	return nil
}

// UpdateDeductionOrderRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDeductionOrderRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDeductionOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeductionOrderRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeductionOrderRequestMultiError) AllErrors() []error { return m }

// UpdateDeductionOrderRequestValidationError is the validation error returned
// by UpdateDeductionOrderRequest.Validate if the designated constraints
// aren't met.
type UpdateDeductionOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeductionOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeductionOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeductionOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeductionOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeductionOrderRequestValidationError) ErrorName() string {
	return "UpdateDeductionOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeductionOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeductionOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeductionOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeductionOrderRequestValidationError{}

// Validate checks the field values on UpdateDeductionOrderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDeductionOrderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDeductionOrderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDeductionOrderResponseMultiError, or nil if none found.
func (m *UpdateDeductionOrderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDeductionOrderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDeductionOrderResponseMultiError(errors)
	}

	return nil
}

// UpdateDeductionOrderResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDeductionOrderResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateDeductionOrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeductionOrderResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeductionOrderResponseMultiError) AllErrors() []error { return m }

// UpdateDeductionOrderResponseValidationError is the validation error returned
// by UpdateDeductionOrderResponse.Validate if the designated constraints
// aren't met.
type UpdateDeductionOrderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeductionOrderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeductionOrderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeductionOrderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeductionOrderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeductionOrderResponseValidationError) ErrorName() string {
	return "UpdateDeductionOrderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeductionOrderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeductionOrderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeductionOrderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeductionOrderResponseValidationError{}

// Validate checks the field values on BonusTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BonusTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BonusTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BonusTransferRequestMultiError, or nil if none found.
func (m *BonusTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BonusTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreditId

	// no validation rules for Currency

	// no validation rules for TransactionType

	if len(errors) > 0 {
		return BonusTransferRequestMultiError(errors)
	}

	return nil
}

// BonusTransferRequestMultiError is an error wrapping multiple validation
// errors returned by BonusTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type BonusTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BonusTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BonusTransferRequestMultiError) AllErrors() []error { return m }

// BonusTransferRequestValidationError is the validation error returned by
// BonusTransferRequest.Validate if the designated constraints aren't met.
type BonusTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BonusTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BonusTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BonusTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BonusTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BonusTransferRequestValidationError) ErrorName() string {
	return "BonusTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BonusTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBonusTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BonusTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BonusTransferRequestValidationError{}

// Validate checks the field values on BonusTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BonusTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BonusTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BonusTransferResponseMultiError, or nil if none found.
func (m *BonusTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BonusTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TransferredAmount

	// no validation rules for BalanceCash

	// no validation rules for BalanceBonus

	if len(errors) > 0 {
		return BonusTransferResponseMultiError(errors)
	}

	return nil
}

// BonusTransferResponseMultiError is an error wrapping multiple validation
// errors returned by BonusTransferResponse.ValidateAll() if the designated
// constraints aren't met.
type BonusTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BonusTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BonusTransferResponseMultiError) AllErrors() []error { return m }

// BonusTransferResponseValidationError is the validation error returned by
// BonusTransferResponse.Validate if the designated constraints aren't met.
type BonusTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BonusTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BonusTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BonusTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BonusTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BonusTransferResponseValidationError) ErrorName() string {
	return "BonusTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BonusTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBonusTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BonusTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BonusTransferResponseValidationError{}

// Validate checks the field values on GetUserBalancesResponse_Balance with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalancesResponse_Balance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalancesResponse_Balance with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetUserBalancesResponse_BalanceMultiError, or nil if none found.
func (m *GetUserBalancesResponse_Balance) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalancesResponse_Balance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Cash

	// no validation rules for OperatorBonus

	// no validation rules for ProviderBonus

	// no validation rules for WithdrawableCash

	// no validation rules for TransferableBonus

	if len(errors) > 0 {
		return GetUserBalancesResponse_BalanceMultiError(errors)
	}

	return nil
}

// GetUserBalancesResponse_BalanceMultiError is an error wrapping multiple
// validation errors returned by GetUserBalancesResponse_Balance.ValidateAll()
// if the designated constraints aren't met.
type GetUserBalancesResponse_BalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalancesResponse_BalanceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalancesResponse_BalanceMultiError) AllErrors() []error { return m }

// GetUserBalancesResponse_BalanceValidationError is the validation error
// returned by GetUserBalancesResponse_Balance.Validate if the designated
// constraints aren't met.
type GetUserBalancesResponse_BalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalancesResponse_BalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalancesResponse_BalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalancesResponse_BalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalancesResponse_BalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalancesResponse_BalanceValidationError) ErrorName() string {
	return "GetUserBalancesResponse_BalanceValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalancesResponse_BalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalancesResponse_Balance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalancesResponse_BalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalancesResponse_BalanceValidationError{}

// Validate checks the field values on CreditRequest_Ratio with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreditRequest_Ratio) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditRequest_Ratio with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreditRequest_RatioMultiError, or nil if none found.
func (m *CreditRequest_Ratio) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditRequest_Ratio) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cash

	// no validation rules for OperatorBonus

	if len(errors) > 0 {
		return CreditRequest_RatioMultiError(errors)
	}

	return nil
}

// CreditRequest_RatioMultiError is an error wrapping multiple validation
// errors returned by CreditRequest_Ratio.ValidateAll() if the designated
// constraints aren't met.
type CreditRequest_RatioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditRequest_RatioMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditRequest_RatioMultiError) AllErrors() []error { return m }

// CreditRequest_RatioValidationError is the validation error returned by
// CreditRequest_Ratio.Validate if the designated constraints aren't met.
type CreditRequest_RatioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditRequest_RatioValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditRequest_RatioValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditRequest_RatioValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditRequest_RatioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditRequest_RatioValidationError) ErrorName() string {
	return "CreditRequest_RatioValidationError"
}

// Error satisfies the builtin error interface
func (e CreditRequest_RatioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditRequest_Ratio.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditRequest_RatioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditRequest_RatioValidationError{}

// Validate checks the field values on GetWalletsResponse_TotalAssets with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletsResponse_TotalAssets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletsResponse_TotalAssets with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetWalletsResponse_TotalAssetsMultiError, or nil if none found.
func (m *GetWalletsResponse_TotalAssets) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletsResponse_TotalAssets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BalanceUsd

	// no validation rules for DepositUsd

	// no validation rules for WithdrawUsd

	// no validation rules for DepositMinusWithdrawUsd

	// no validation rules for ValidTurnoverUsd

	// no validation rules for BalanceReportingCurrency

	// no validation rules for DepositReportingCurrency

	// no validation rules for WithdrawReportingCurrency

	// no validation rules for DepositMinusWithdrawReportingCurrency

	// no validation rules for ValidTurnoverReportingCurrency

	if len(errors) > 0 {
		return GetWalletsResponse_TotalAssetsMultiError(errors)
	}

	return nil
}

// GetWalletsResponse_TotalAssetsMultiError is an error wrapping multiple
// validation errors returned by GetWalletsResponse_TotalAssets.ValidateAll()
// if the designated constraints aren't met.
type GetWalletsResponse_TotalAssetsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletsResponse_TotalAssetsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletsResponse_TotalAssetsMultiError) AllErrors() []error { return m }

// GetWalletsResponse_TotalAssetsValidationError is the validation error
// returned by GetWalletsResponse_TotalAssets.Validate if the designated
// constraints aren't met.
type GetWalletsResponse_TotalAssetsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletsResponse_TotalAssetsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletsResponse_TotalAssetsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletsResponse_TotalAssetsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletsResponse_TotalAssetsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletsResponse_TotalAssetsValidationError) ErrorName() string {
	return "GetWalletsResponse_TotalAssetsValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletsResponse_TotalAssetsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletsResponse_TotalAssets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletsResponse_TotalAssetsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletsResponse_TotalAssetsValidationError{}

// Validate checks the field values on GetWalletsResponse_Credit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletsResponse_Credit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletsResponse_Credit with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletsResponse_CreditMultiError, or nil if none found.
func (m *GetWalletsResponse_Credit) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletsResponse_Credit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletsResponse_CreditValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletsResponse_CreditValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletsResponse_CreditValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TransactionId

	// no validation rules for Cash

	// no validation rules for OriginalCash

	// no validation rules for Bonus

	// no validation rules for OriginalBonus

	// no validation rules for TurnoverThreshold

	// no validation rules for Turnover

	// no validation rules for CashTurnover

	// no validation rules for BonusTurnover

	// no validation rules for TurnoverMultiplier

	// no validation rules for CashTurnoverThreshold

	// no validation rules for BonusTurnoverThreshold

	if len(errors) > 0 {
		return GetWalletsResponse_CreditMultiError(errors)
	}

	return nil
}

// GetWalletsResponse_CreditMultiError is an error wrapping multiple validation
// errors returned by GetWalletsResponse_Credit.ValidateAll() if the
// designated constraints aren't met.
type GetWalletsResponse_CreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletsResponse_CreditMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletsResponse_CreditMultiError) AllErrors() []error { return m }

// GetWalletsResponse_CreditValidationError is the validation error returned by
// GetWalletsResponse_Credit.Validate if the designated constraints aren't met.
type GetWalletsResponse_CreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletsResponse_CreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletsResponse_CreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletsResponse_CreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletsResponse_CreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletsResponse_CreditValidationError) ErrorName() string {
	return "GetWalletsResponse_CreditValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletsResponse_CreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletsResponse_Credit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletsResponse_CreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletsResponse_CreditValidationError{}

// Validate checks the field values on GetWalletsResponse_Wallet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletsResponse_Wallet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletsResponse_Wallet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletsResponse_WalletMultiError, or nil if none found.
func (m *GetWalletsResponse_Wallet) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletsResponse_Wallet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	// no validation rules for Cash

	// no validation rules for OriginalCash

	// no validation rules for Bonus

	// no validation rules for OriginalBonus

	// no validation rules for TurnoverThreshold

	// no validation rules for Turnover

	// no validation rules for CashTurnover

	// no validation rules for BonusTurnover

	// no validation rules for TurnoverMultiplier

	for idx, item := range m.GetCredits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletsResponse_WalletValidationError{
						field:  fmt.Sprintf("Credits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletsResponse_WalletValidationError{
						field:  fmt.Sprintf("Credits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletsResponse_WalletValidationError{
					field:  fmt.Sprintf("Credits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CashTurnoverThreshold

	// no validation rules for BonusTurnoverThreshold

	// no validation rules for WithdrawableCash

	// no validation rules for TransferableBonus

	if len(errors) > 0 {
		return GetWalletsResponse_WalletMultiError(errors)
	}

	return nil
}

// GetWalletsResponse_WalletMultiError is an error wrapping multiple validation
// errors returned by GetWalletsResponse_Wallet.ValidateAll() if the
// designated constraints aren't met.
type GetWalletsResponse_WalletMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletsResponse_WalletMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletsResponse_WalletMultiError) AllErrors() []error { return m }

// GetWalletsResponse_WalletValidationError is the validation error returned by
// GetWalletsResponse_Wallet.Validate if the designated constraints aren't met.
type GetWalletsResponse_WalletValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletsResponse_WalletValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletsResponse_WalletValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletsResponse_WalletValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletsResponse_WalletValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletsResponse_WalletValidationError) ErrorName() string {
	return "GetWalletsResponse_WalletValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletsResponse_WalletValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletsResponse_Wallet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletsResponse_WalletValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletsResponse_WalletValidationError{}

// Validate checks the field values on
// ListWalletBalanceTransactionsResponse_BalanceTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletBalanceTransactionsResponse_BalanceTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListWalletBalanceTransactionsResponse_BalanceTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError, or nil
// if none found.
func (m *ListWalletBalanceTransactionsResponse_BalanceTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceTransactionsResponse_BalanceTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TransactionId

	// no validation rules for TransactionType

	// no validation rules for VipLevel

	// no validation rules for ChangeBalance

	// no validation rules for BeforeBalance

	// no validation rules for AfterBalance

	// no validation rules for Currency

	// no validation rules for RelatedTransactionId

	if len(errors) > 0 {
		return ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError(errors)
	}

	return nil
}

// ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError is an
// error wrapping multiple validation errors returned by
// ListWalletBalanceTransactionsResponse_BalanceTransaction.ValidateAll() if
// the designated constraints aren't met.
type ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceTransactionsResponse_BalanceTransactionMultiError) AllErrors() []error {
	return m
}

// ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError is
// the validation error returned by
// ListWalletBalanceTransactionsResponse_BalanceTransaction.Validate if the
// designated constraints aren't met.
type ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) ErrorName() string {
	return "ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceTransactionsResponse_BalanceTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceTransactionsResponse_BalanceTransactionValidationError{}

// Validate checks the field values on
// GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionMultiError, or
// nil if none found.
func (m *GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for SettlementCurrency

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for TransactionType

	// no validation rules for ExternalTransactionId

	// no validation rules for RelatedTransactionId

	// no validation rules for OriginalCash

	// no validation rules for OriginalCashUsd

	// no validation rules for OriginalCashReportingCurrency

	// no validation rules for Cash

	// no validation rules for CashUsd

	// no validation rules for CashReportingCurrency

	// no validation rules for CashAmount

	// no validation rules for CashAmountUsd

	// no validation rules for CashAmountReportingCurrency

	// no validation rules for OriginalOperatorBonus

	// no validation rules for OriginalOperatorBonusUsd

	// no validation rules for OriginalOperatorBonusReportingCurrency

	// no validation rules for OperatorBonus

	// no validation rules for OperatorBonusUsd

	// no validation rules for OperatorBonusReportingCurrency

	// no validation rules for OperatorBonusAmount

	// no validation rules for OperatorBonusAmountUsd

	// no validation rules for OperatorBonusAmountReportingCurrency

	// no validation rules for OriginalProviderBonus

	// no validation rules for OriginalProviderBonusUsd

	// no validation rules for OriginalProviderBonusReportingCurrency

	// no validation rules for ProviderBonus

	// no validation rules for ProviderBonusUsd

	// no validation rules for ProviderBonusReportingCurrency

	// no validation rules for ProviderBonusAmount

	// no validation rules for ProviderBonusAmountUsd

	// no validation rules for ProviderBonusAmountReportingCurrency

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionMultiError(errors)
	}

	return nil
}

// GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionMultiError is an
// error wrapping multiple validation errors returned by
// GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction.ValidateAll()
// if the designated constraints aren't met.
type GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionMultiError) AllErrors() []error {
	return m
}

// GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError
// is the validation error returned by
// GetWalletBalanceTransactionsByIdsResponse_BalanceTransaction.Validate if
// the designated constraints aren't met.
type GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError) ErrorName() string {
	return "GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletBalanceTransactionsByIdsResponse_BalanceTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletBalanceTransactionsByIdsResponse_BalanceTransactionValidationError{}

// Validate checks the field values on
// GetWalletCreditTransactionsResponse_CreditTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletCreditTransactionsResponse_CreditTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetWalletCreditTransactionsResponse_CreditTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletCreditTransactionsResponse_CreditTransactionMultiError, or nil if
// none found.
func (m *GetWalletCreditTransactionsResponse_CreditTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletCreditTransactionsResponse_CreditTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletCreditTransactionsResponse_CreditTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletCreditTransactionsResponse_CreditTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletCreditTransactionsResponse_CreditTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Cash

	// no validation rules for Bonus

	if len(errors) > 0 {
		return GetWalletCreditTransactionsResponse_CreditTransactionMultiError(errors)
	}

	return nil
}

// GetWalletCreditTransactionsResponse_CreditTransactionMultiError is an error
// wrapping multiple validation errors returned by
// GetWalletCreditTransactionsResponse_CreditTransaction.ValidateAll() if the
// designated constraints aren't met.
type GetWalletCreditTransactionsResponse_CreditTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletCreditTransactionsResponse_CreditTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletCreditTransactionsResponse_CreditTransactionMultiError) AllErrors() []error {
	return m
}

// GetWalletCreditTransactionsResponse_CreditTransactionValidationError is the
// validation error returned by
// GetWalletCreditTransactionsResponse_CreditTransaction.Validate if the
// designated constraints aren't met.
type GetWalletCreditTransactionsResponse_CreditTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) ErrorName() string {
	return "GetWalletCreditTransactionsResponse_CreditTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletCreditTransactionsResponse_CreditTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletCreditTransactionsResponse_CreditTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletCreditTransactionsResponse_CreditTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletCreditTransactionsResponse_CreditTransactionValidationError{}

// Validate checks the field values on
// GetOverviewDashboardFromWalletResponse_GGR with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOverviewDashboardFromWalletResponse_GGR) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOverviewDashboardFromWalletResponse_GGR with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetOverviewDashboardFromWalletResponse_GGRMultiError, or nil if none found.
func (m *GetOverviewDashboardFromWalletResponse_GGR) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletResponse_GGR) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TodayUsd

	// no validation rules for YesterdayUsd

	// no validation rules for TodayReportingCurrency

	// no validation rules for YesterdayReportingCurrency

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletResponse_GGRMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletResponse_GGRMultiError is an error wrapping
// multiple validation errors returned by
// GetOverviewDashboardFromWalletResponse_GGR.ValidateAll() if the designated
// constraints aren't met.
type GetOverviewDashboardFromWalletResponse_GGRMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletResponse_GGRMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletResponse_GGRMultiError) AllErrors() []error { return m }

// GetOverviewDashboardFromWalletResponse_GGRValidationError is the validation
// error returned by GetOverviewDashboardFromWalletResponse_GGR.Validate if
// the designated constraints aren't met.
type GetOverviewDashboardFromWalletResponse_GGRValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletResponse_GGRValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletResponse_GGRValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletResponse_GGRValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOverviewDashboardFromWalletResponse_GGRValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletResponse_GGRValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletResponse_GGRValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletResponse_GGRValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletResponse_GGR.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletResponse_GGRValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletResponse_GGRValidationError{}

// Validate checks the field values on
// GetOverviewDashboardFromWalletResponse_NGR with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOverviewDashboardFromWalletResponse_NGR) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOverviewDashboardFromWalletResponse_NGR with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetOverviewDashboardFromWalletResponse_NGRMultiError, or nil if none found.
func (m *GetOverviewDashboardFromWalletResponse_NGR) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletResponse_NGR) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TodayUsd

	// no validation rules for YesterdayUsd

	// no validation rules for TodayReportingCurrency

	// no validation rules for YesterdayReportingCurrency

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletResponse_NGRMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletResponse_NGRMultiError is an error wrapping
// multiple validation errors returned by
// GetOverviewDashboardFromWalletResponse_NGR.ValidateAll() if the designated
// constraints aren't met.
type GetOverviewDashboardFromWalletResponse_NGRMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletResponse_NGRMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletResponse_NGRMultiError) AllErrors() []error { return m }

// GetOverviewDashboardFromWalletResponse_NGRValidationError is the validation
// error returned by GetOverviewDashboardFromWalletResponse_NGR.Validate if
// the designated constraints aren't met.
type GetOverviewDashboardFromWalletResponse_NGRValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletResponse_NGRValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletResponse_NGRValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletResponse_NGRValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOverviewDashboardFromWalletResponse_NGRValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletResponse_NGRValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletResponse_NGRValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletResponse_NGRValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletResponse_NGR.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletResponse_NGRValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletResponse_NGRValidationError{}

// Validate checks the field values on
// GetOverviewDashboardFromWalletResponse_Deposit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOverviewDashboardFromWalletResponse_Deposit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOverviewDashboardFromWalletResponse_Deposit with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// GetOverviewDashboardFromWalletResponse_DepositMultiError, or nil if none found.
func (m *GetOverviewDashboardFromWalletResponse_Deposit) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletResponse_Deposit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TodayUsd

	// no validation rules for YesterdayUsd

	// no validation rules for TodayReportingCurrency

	// no validation rules for YesterdayReportingCurrency

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletResponse_DepositMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletResponse_DepositMultiError is an error
// wrapping multiple validation errors returned by
// GetOverviewDashboardFromWalletResponse_Deposit.ValidateAll() if the
// designated constraints aren't met.
type GetOverviewDashboardFromWalletResponse_DepositMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletResponse_DepositMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletResponse_DepositMultiError) AllErrors() []error { return m }

// GetOverviewDashboardFromWalletResponse_DepositValidationError is the
// validation error returned by
// GetOverviewDashboardFromWalletResponse_Deposit.Validate if the designated
// constraints aren't met.
type GetOverviewDashboardFromWalletResponse_DepositValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletResponse_DepositValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletResponse_DepositValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletResponse_DepositValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOverviewDashboardFromWalletResponse_DepositValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletResponse_DepositValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletResponse_DepositValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletResponse_DepositValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletResponse_Deposit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletResponse_DepositValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletResponse_DepositValidationError{}

// Validate checks the field values on
// GetOverviewDashboardFromWalletResponse_Withdraw with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOverviewDashboardFromWalletResponse_Withdraw) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOverviewDashboardFromWalletResponse_Withdraw with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// GetOverviewDashboardFromWalletResponse_WithdrawMultiError, or nil if none found.
func (m *GetOverviewDashboardFromWalletResponse_Withdraw) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletResponse_Withdraw) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TodayUsd

	// no validation rules for YesterdayUsd

	// no validation rules for TodayReportingCurrency

	// no validation rules for YesterdayReportingCurrency

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletResponse_WithdrawMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletResponse_WithdrawMultiError is an error
// wrapping multiple validation errors returned by
// GetOverviewDashboardFromWalletResponse_Withdraw.ValidateAll() if the
// designated constraints aren't met.
type GetOverviewDashboardFromWalletResponse_WithdrawMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletResponse_WithdrawMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletResponse_WithdrawMultiError) AllErrors() []error { return m }

// GetOverviewDashboardFromWalletResponse_WithdrawValidationError is the
// validation error returned by
// GetOverviewDashboardFromWalletResponse_Withdraw.Validate if the designated
// constraints aren't met.
type GetOverviewDashboardFromWalletResponse_WithdrawValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletResponse_WithdrawValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletResponse_WithdrawValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletResponse_WithdrawValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOverviewDashboardFromWalletResponse_WithdrawValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletResponse_WithdrawValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletResponse_WithdrawValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletResponse_WithdrawValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletResponse_Withdraw.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletResponse_WithdrawValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletResponse_WithdrawValidationError{}

// Validate checks the field values on
// GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawMultiError, or
// nil if none found.
func (m *GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TodayUsd

	// no validation rules for YesterdayUsd

	// no validation rules for TodayReportingCurrency

	// no validation rules for YesterdayReportingCurrency

	if len(errors) > 0 {
		return GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawMultiError(errors)
	}

	return nil
}

// GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawMultiError is an
// error wrapping multiple validation errors returned by
// GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw.ValidateAll()
// if the designated constraints aren't met.
type GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawMultiError) AllErrors() []error {
	return m
}

// GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError
// is the validation error returned by
// GetOverviewDashboardFromWalletResponse_DepositMinusWithdraw.Validate if the
// designated constraints aren't met.
type GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError) ErrorName() string {
	return "GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError"
}

// Error satisfies the builtin error interface
func (e GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOverviewDashboardFromWalletResponse_DepositMinusWithdraw.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOverviewDashboardFromWalletResponse_DepositMinusWithdrawValidationError{}

// Validate checks the field values on RewardSequence_TierConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RewardSequence_TierConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RewardSequence_TierConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RewardSequence_TierConfigMultiError, or nil if none found.
func (m *RewardSequence_TierConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RewardSequence_TierConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinDepositAmount

	// no validation rules for MaxDepositAmount

	// no validation rules for RewardPercentage

	// no validation rules for MaxRewardAmount

	// no validation rules for MaxWithdrawalAmount

	if len(errors) > 0 {
		return RewardSequence_TierConfigMultiError(errors)
	}

	return nil
}

// RewardSequence_TierConfigMultiError is an error wrapping multiple validation
// errors returned by RewardSequence_TierConfig.ValidateAll() if the
// designated constraints aren't met.
type RewardSequence_TierConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RewardSequence_TierConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RewardSequence_TierConfigMultiError) AllErrors() []error { return m }

// RewardSequence_TierConfigValidationError is the validation error returned by
// RewardSequence_TierConfig.Validate if the designated constraints aren't met.
type RewardSequence_TierConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RewardSequence_TierConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RewardSequence_TierConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RewardSequence_TierConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RewardSequence_TierConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RewardSequence_TierConfigValidationError) ErrorName() string {
	return "RewardSequence_TierConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RewardSequence_TierConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRewardSequence_TierConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RewardSequence_TierConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RewardSequence_TierConfigValidationError{}
