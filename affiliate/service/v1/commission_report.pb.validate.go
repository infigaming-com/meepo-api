// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: affiliate/service/v1/commission_report.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListReferralVTGReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReferralVTGReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralVTGReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListReferralVTGReportRequestMultiError, or nil if none found.
func (m *ListReferralVTGReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralVTGReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Period

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralVTGReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralVTGReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralVTGReportRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralVTGReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralVTGReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralVTGReportRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListReferralVTGReportRequestMultiError(errors)
	}

	return nil
}

// ListReferralVTGReportRequestMultiError is an error wrapping multiple
// validation errors returned by ListReferralVTGReportRequest.ValidateAll() if
// the designated constraints aren't met.
type ListReferralVTGReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralVTGReportRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralVTGReportRequestMultiError) AllErrors() []error { return m }

// ListReferralVTGReportRequestValidationError is the validation error returned
// by ListReferralVTGReportRequest.Validate if the designated constraints
// aren't met.
type ListReferralVTGReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralVTGReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralVTGReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralVTGReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralVTGReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralVTGReportRequestValidationError) ErrorName() string {
	return "ListReferralVTGReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralVTGReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralVTGReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralVTGReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralVTGReportRequestValidationError{}

// Validate checks the field values on VTGTierData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VTGTierData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VTGTierData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VTGTierDataMultiError, or
// nil if none found.
func (m *VTGTierData) ValidateAll() error {
	return m.validate(true)
}

func (m *VTGTierData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Tier

	// no validation rules for NewCount

	// no validation rules for FtdCount

	// no validation rules for QualifiedCount

	// no validation rules for FtdAmountUsd

	// no validation rules for DepositAmountUsd

	// no validation rules for WithdrawalAmountUsd

	// no validation rules for GgrUsd

	// no validation rules for NgrUsd

	// no validation rules for B2CUsd

	// no validation rules for BetCount

	// no validation rules for BetAmountUsd

	// no validation rules for AvgBetUsd

	// no validation rules for FtdAmountReportingCurrency

	// no validation rules for DepositAmountReportingCurrency

	// no validation rules for WithdrawalAmountReportingCurrency

	// no validation rules for GgrReportingCurrency

	// no validation rules for NgrReportingCurrency

	// no validation rules for B2CReportingCurrency

	// no validation rules for BetAmountReportingCurrency

	// no validation rules for AvgBetReportingCurrency

	// no validation rules for ReferralRewardUsd

	// no validation rules for DepositCashbackUsd

	// no validation rules for WageringCommissionUsd

	// no validation rules for LossRevenueShareUsd

	// no validation rules for TotalRewardUsd

	// no validation rules for ReferralRewardReportingCurrency

	// no validation rules for DepositCashbackReportingCurrency

	// no validation rules for WageringCommissionReportingCurrency

	// no validation rules for LossRevenueShareReportingCurrency

	// no validation rules for TotalRewardReportingCurrency

	if len(errors) > 0 {
		return VTGTierDataMultiError(errors)
	}

	return nil
}

// VTGTierDataMultiError is an error wrapping multiple validation errors
// returned by VTGTierData.ValidateAll() if the designated constraints aren't met.
type VTGTierDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VTGTierDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VTGTierDataMultiError) AllErrors() []error { return m }

// VTGTierDataValidationError is the validation error returned by
// VTGTierData.Validate if the designated constraints aren't met.
type VTGTierDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VTGTierDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VTGTierDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VTGTierDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VTGTierDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VTGTierDataValidationError) ErrorName() string { return "VTGTierDataValidationError" }

// Error satisfies the builtin error interface
func (e VTGTierDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVTGTierData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VTGTierDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VTGTierDataValidationError{}

// Validate checks the field values on VTGReportItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VTGReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VTGReportItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VTGReportItemMultiError, or
// nil if none found.
func (m *VTGReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *VTGReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for Uid

	// no validation rules for Currency

	// no validation rules for ReferralId

	// no validation rules for AffiliateId

	// no validation rules for OperatorId

	// no validation rules for SystemOperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for OperatorName

	// no validation rules for SystemOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for RetailerOperatorName

	for idx, item := range m.GetTiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VTGReportItemValidationError{
						field:  fmt.Sprintf("Tiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VTGReportItemValidationError{
						field:  fmt.Sprintf("Tiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VTGReportItemValidationError{
					field:  fmt.Sprintf("Tiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalRewardUsd

	// no validation rules for T1TotalRewardUsd

	// no validation rules for T1Roi

	// no validation rules for TotalRewardReportingCurrency

	// no validation rules for T1TotalRewardReportingCurrency

	if len(errors) > 0 {
		return VTGReportItemMultiError(errors)
	}

	return nil
}

// VTGReportItemMultiError is an error wrapping multiple validation errors
// returned by VTGReportItem.ValidateAll() if the designated constraints
// aren't met.
type VTGReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VTGReportItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VTGReportItemMultiError) AllErrors() []error { return m }

// VTGReportItemValidationError is the validation error returned by
// VTGReportItem.Validate if the designated constraints aren't met.
type VTGReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VTGReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VTGReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VTGReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VTGReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VTGReportItemValidationError) ErrorName() string { return "VTGReportItemValidationError" }

// Error satisfies the builtin error interface
func (e VTGReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVTGReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VTGReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VTGReportItemValidationError{}

// Validate checks the field values on ListReferralVTGReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListReferralVTGReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralVTGReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListReferralVTGReportResponseMultiError, or nil if none found.
func (m *ListReferralVTGReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralVTGReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReferralVTGReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReferralVTGReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReferralVTGReportResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListReferralVTGReportResponseMultiError(errors)
	}

	return nil
}

// ListReferralVTGReportResponseMultiError is an error wrapping multiple
// validation errors returned by ListReferralVTGReportResponse.ValidateAll()
// if the designated constraints aren't met.
type ListReferralVTGReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralVTGReportResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralVTGReportResponseMultiError) AllErrors() []error { return m }

// ListReferralVTGReportResponseValidationError is the validation error
// returned by ListReferralVTGReportResponse.Validate if the designated
// constraints aren't met.
type ListReferralVTGReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralVTGReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralVTGReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralVTGReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralVTGReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralVTGReportResponseValidationError) ErrorName() string {
	return "ListReferralVTGReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralVTGReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralVTGReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralVTGReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralVTGReportResponseValidationError{}

// Validate checks the field values on ListReferralSnapshotReportRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListReferralSnapshotReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralSnapshotReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListReferralSnapshotReportRequestMultiError, or nil if none found.
func (m *ListReferralSnapshotReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralSnapshotReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Period

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralSnapshotReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralSnapshotReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralSnapshotReportRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralSnapshotReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralSnapshotReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralSnapshotReportRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OnlyNegativeCarryover

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListReferralSnapshotReportRequestMultiError(errors)
	}

	return nil
}

// ListReferralSnapshotReportRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListReferralSnapshotReportRequest.ValidateAll() if the designated
// constraints aren't met.
type ListReferralSnapshotReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralSnapshotReportRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralSnapshotReportRequestMultiError) AllErrors() []error { return m }

// ListReferralSnapshotReportRequestValidationError is the validation error
// returned by ListReferralSnapshotReportRequest.Validate if the designated
// constraints aren't met.
type ListReferralSnapshotReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralSnapshotReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralSnapshotReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralSnapshotReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralSnapshotReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralSnapshotReportRequestValidationError) ErrorName() string {
	return "ListReferralSnapshotReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralSnapshotReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralSnapshotReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralSnapshotReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralSnapshotReportRequestValidationError{}

// Validate checks the field values on SnapshotTierData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SnapshotTierData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnapshotTierData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnapshotTierDataMultiError, or nil if none found.
func (m *SnapshotTierData) ValidateAll() error {
	return m.validate(true)
}

func (m *SnapshotTierData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Tier

	// no validation rules for TotalCount

	// no validation rules for QualifiedCount

	// no validation rules for ActiveCount

	// no validation rules for ReferralRewardUsd

	// no validation rules for DepositCashbackUsd

	// no validation rules for WageringCommissionUsd

	// no validation rules for LossRevenueShareUsd

	// no validation rules for TotalRewardUsd

	// no validation rules for ReferralRewardReportingCurrency

	// no validation rules for DepositCashbackReportingCurrency

	// no validation rules for WageringCommissionReportingCurrency

	// no validation rules for LossRevenueShareReportingCurrency

	// no validation rules for TotalRewardReportingCurrency

	if len(errors) > 0 {
		return SnapshotTierDataMultiError(errors)
	}

	return nil
}

// SnapshotTierDataMultiError is an error wrapping multiple validation errors
// returned by SnapshotTierData.ValidateAll() if the designated constraints
// aren't met.
type SnapshotTierDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnapshotTierDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnapshotTierDataMultiError) AllErrors() []error { return m }

// SnapshotTierDataValidationError is the validation error returned by
// SnapshotTierData.Validate if the designated constraints aren't met.
type SnapshotTierDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnapshotTierDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnapshotTierDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnapshotTierDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnapshotTierDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnapshotTierDataValidationError) ErrorName() string { return "SnapshotTierDataValidationError" }

// Error satisfies the builtin error interface
func (e SnapshotTierDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnapshotTierData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnapshotTierDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnapshotTierDataValidationError{}

// Validate checks the field values on T1GamingData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *T1GamingData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on T1GamingData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in T1GamingDataMultiError, or
// nil if none found.
func (m *T1GamingData) ValidateAll() error {
	return m.validate(true)
}

func (m *T1GamingData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GgrUsd

	// no validation rules for NgrUsd

	// no validation rules for B2CUsd

	// no validation rules for PaymentCostUsd

	// no validation rules for ProviderRoyaltiesUsd

	// no validation rules for GgrReportingCurrency

	// no validation rules for NgrReportingCurrency

	// no validation rules for B2CReportingCurrency

	// no validation rules for PaymentCostReportingCurrency

	// no validation rules for ProviderRoyaltiesReportingCurrency

	if len(errors) > 0 {
		return T1GamingDataMultiError(errors)
	}

	return nil
}

// T1GamingDataMultiError is an error wrapping multiple validation errors
// returned by T1GamingData.ValidateAll() if the designated constraints aren't met.
type T1GamingDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m T1GamingDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m T1GamingDataMultiError) AllErrors() []error { return m }

// T1GamingDataValidationError is the validation error returned by
// T1GamingData.Validate if the designated constraints aren't met.
type T1GamingDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e T1GamingDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e T1GamingDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e T1GamingDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e T1GamingDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e T1GamingDataValidationError) ErrorName() string { return "T1GamingDataValidationError" }

// Error satisfies the builtin error interface
func (e T1GamingDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sT1GamingData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = T1GamingDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = T1GamingDataValidationError{}

// Validate checks the field values on T1Carryover with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *T1Carryover) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on T1Carryover with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in T1CarryoverMultiError, or
// nil if none found.
func (m *T1Carryover) ValidateAll() error {
	return m.validate(true)
}

func (m *T1Carryover) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BasedOn

	// no validation rules for RevenueUsd

	// no validation rules for RevenueReportingCurrency

	// no validation rules for B2CUsd

	// no validation rules for B2CReportingCurrency

	if len(errors) > 0 {
		return T1CarryoverMultiError(errors)
	}

	return nil
}

// T1CarryoverMultiError is an error wrapping multiple validation errors
// returned by T1Carryover.ValidateAll() if the designated constraints aren't met.
type T1CarryoverMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m T1CarryoverMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m T1CarryoverMultiError) AllErrors() []error { return m }

// T1CarryoverValidationError is the validation error returned by
// T1Carryover.Validate if the designated constraints aren't met.
type T1CarryoverValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e T1CarryoverValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e T1CarryoverValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e T1CarryoverValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e T1CarryoverValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e T1CarryoverValidationError) ErrorName() string { return "T1CarryoverValidationError" }

// Error satisfies the builtin error interface
func (e T1CarryoverValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sT1Carryover.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = T1CarryoverValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = T1CarryoverValidationError{}

// Validate checks the field values on SnapshotReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SnapshotReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnapshotReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SnapshotReportItemMultiError, or nil if none found.
func (m *SnapshotReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *SnapshotReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for Uid

	// no validation rules for Currency

	// no validation rules for ReferralId

	// no validation rules for AffiliateId

	// no validation rules for OperatorId

	// no validation rules for SystemOperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for OperatorName

	// no validation rules for SystemOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for RetailerOperatorName

	for idx, item := range m.GetTiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SnapshotReportItemValidationError{
						field:  fmt.Sprintf("Tiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SnapshotReportItemValidationError{
						field:  fmt.Sprintf("Tiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SnapshotReportItemValidationError{
					field:  fmt.Sprintf("Tiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetT1Gaming()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SnapshotReportItemValidationError{
					field:  "T1Gaming",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SnapshotReportItemValidationError{
					field:  "T1Gaming",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetT1Gaming()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SnapshotReportItemValidationError{
				field:  "T1Gaming",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TotalReferralRewardUsd

	// no validation rules for TotalDepositCashbackUsd

	// no validation rules for TotalWageringCommissionUsd

	// no validation rules for TotalLossRevenueShareUsd

	// no validation rules for TotalReferralRewardReportingCurrency

	// no validation rules for TotalDepositCashbackReportingCurrency

	// no validation rules for TotalWageringCommissionReportingCurrency

	// no validation rules for TotalLossRevenueShareReportingCurrency

	// no validation rules for UnpaidWageringCommissionUsd

	// no validation rules for UnpaidLossCommissionUsd

	// no validation rules for UnpaidWageringCommissionReportingCurrency

	// no validation rules for UnpaidLossCommissionReportingCurrency

	// no validation rules for UnclaimedCommissionUsd

	// no validation rules for LifetimeClaimedUsd

	// no validation rules for WithdrawalAmountUsd

	// no validation rules for UnclaimedCommissionReportingCurrency

	// no validation rules for LifetimeClaimedReportingCurrency

	// no validation rules for WithdrawalAmountReportingCurrency

	if all {
		switch v := interface{}(m.GetT1Carryover()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SnapshotReportItemValidationError{
					field:  "T1Carryover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SnapshotReportItemValidationError{
					field:  "T1Carryover",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetT1Carryover()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SnapshotReportItemValidationError{
				field:  "T1Carryover",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SnapshotReportItemMultiError(errors)
	}

	return nil
}

// SnapshotReportItemMultiError is an error wrapping multiple validation errors
// returned by SnapshotReportItem.ValidateAll() if the designated constraints
// aren't met.
type SnapshotReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnapshotReportItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnapshotReportItemMultiError) AllErrors() []error { return m }

// SnapshotReportItemValidationError is the validation error returned by
// SnapshotReportItem.Validate if the designated constraints aren't met.
type SnapshotReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnapshotReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnapshotReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnapshotReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnapshotReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnapshotReportItemValidationError) ErrorName() string {
	return "SnapshotReportItemValidationError"
}

// Error satisfies the builtin error interface
func (e SnapshotReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnapshotReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnapshotReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnapshotReportItemValidationError{}

// Validate checks the field values on ListReferralSnapshotReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListReferralSnapshotReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralSnapshotReportResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListReferralSnapshotReportResponseMultiError, or nil if none found.
func (m *ListReferralSnapshotReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralSnapshotReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReferralSnapshotReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReferralSnapshotReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReferralSnapshotReportResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListReferralSnapshotReportResponseMultiError(errors)
	}

	return nil
}

// ListReferralSnapshotReportResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListReferralSnapshotReportResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReferralSnapshotReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralSnapshotReportResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralSnapshotReportResponseMultiError) AllErrors() []error { return m }

// ListReferralSnapshotReportResponseValidationError is the validation error
// returned by ListReferralSnapshotReportResponse.Validate if the designated
// constraints aren't met.
type ListReferralSnapshotReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralSnapshotReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralSnapshotReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralSnapshotReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralSnapshotReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralSnapshotReportResponseValidationError) ErrorName() string {
	return "ListReferralSnapshotReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralSnapshotReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralSnapshotReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralSnapshotReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralSnapshotReportResponseValidationError{}

// Validate checks the field values on ListReferralContributionReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListReferralContributionReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralContributionReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListReferralContributionReportRequestMultiError, or nil if none found.
func (m *ListReferralContributionReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralContributionReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Period

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralContributionReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralContributionReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralContributionReportRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralContributionReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralContributionReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralContributionReportRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.RootUserId != nil {
		// no validation rules for RootUserId
	}

	if m.IsQualified != nil {
		// no validation rules for IsQualified
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListReferralContributionReportRequestMultiError(errors)
	}

	return nil
}

// ListReferralContributionReportRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListReferralContributionReportRequest.ValidateAll() if the designated
// constraints aren't met.
type ListReferralContributionReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralContributionReportRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralContributionReportRequestMultiError) AllErrors() []error { return m }

// ListReferralContributionReportRequestValidationError is the validation error
// returned by ListReferralContributionReportRequest.Validate if the
// designated constraints aren't met.
type ListReferralContributionReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralContributionReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralContributionReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralContributionReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralContributionReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralContributionReportRequestValidationError) ErrorName() string {
	return "ListReferralContributionReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralContributionReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralContributionReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralContributionReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralContributionReportRequestValidationError{}

// Validate checks the field values on ContributionReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ContributionReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContributionReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContributionReportItemMultiError, or nil if none found.
func (m *ContributionReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ContributionReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for RootId

	// no validation rules for ParentId

	// no validation rules for SubUid

	// no validation rules for Tier

	// no validation rules for RegDate

	// no validation rules for FtdDate

	// no validation rules for IsQualified

	// no validation rules for OperatorId

	// no validation rules for SystemOperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for OperatorName

	// no validation rules for SystemOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for RetailerOperatorName

	// no validation rules for DepositUsd

	// no validation rules for WithdrawalUsd

	// no validation rules for TurnoverUsd

	// no validation rules for GgrUsd

	// no validation rules for NgrUsd

	// no validation rules for B2CUsd

	// no validation rules for PaymentCostUsd

	// no validation rules for ProviderRoyaltiesUsd

	// no validation rules for DepositReportingCurrency

	// no validation rules for WithdrawalReportingCurrency

	// no validation rules for TurnoverReportingCurrency

	// no validation rules for GgrReportingCurrency

	// no validation rules for NgrReportingCurrency

	// no validation rules for B2CReportingCurrency

	// no validation rules for PaymentCostReportingCurrency

	// no validation rules for ProviderRoyaltiesReportingCurrency

	// no validation rules for LastLoginTime

	// no validation rules for DeviceId

	// no validation rules for Ip

	if len(errors) > 0 {
		return ContributionReportItemMultiError(errors)
	}

	return nil
}

// ContributionReportItemMultiError is an error wrapping multiple validation
// errors returned by ContributionReportItem.ValidateAll() if the designated
// constraints aren't met.
type ContributionReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContributionReportItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContributionReportItemMultiError) AllErrors() []error { return m }

// ContributionReportItemValidationError is the validation error returned by
// ContributionReportItem.Validate if the designated constraints aren't met.
type ContributionReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContributionReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContributionReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContributionReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContributionReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContributionReportItemValidationError) ErrorName() string {
	return "ContributionReportItemValidationError"
}

// Error satisfies the builtin error interface
func (e ContributionReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContributionReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContributionReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContributionReportItemValidationError{}

// Validate checks the field values on ListReferralContributionReportResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListReferralContributionReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListReferralContributionReportResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListReferralContributionReportResponseMultiError, or nil if none found.
func (m *ListReferralContributionReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralContributionReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReferralContributionReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReferralContributionReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReferralContributionReportResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListReferralContributionReportResponseMultiError(errors)
	}

	return nil
}

// ListReferralContributionReportResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListReferralContributionReportResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReferralContributionReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralContributionReportResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralContributionReportResponseMultiError) AllErrors() []error { return m }

// ListReferralContributionReportResponseValidationError is the validation
// error returned by ListReferralContributionReportResponse.Validate if the
// designated constraints aren't met.
type ListReferralContributionReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralContributionReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralContributionReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralContributionReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralContributionReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralContributionReportResponseValidationError) ErrorName() string {
	return "ListReferralContributionReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralContributionReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralContributionReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralContributionReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralContributionReportResponseValidationError{}

// Validate checks the field values on ListReferralLifetimeReportRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListReferralLifetimeReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralLifetimeReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListReferralLifetimeReportRequestMultiError, or nil if none found.
func (m *ListReferralLifetimeReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralLifetimeReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralLifetimeReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralLifetimeReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralLifetimeReportRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListReferralLifetimeReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListReferralLifetimeReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListReferralLifetimeReportRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListReferralLifetimeReportRequestMultiError(errors)
	}

	return nil
}

// ListReferralLifetimeReportRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListReferralLifetimeReportRequest.ValidateAll() if the designated
// constraints aren't met.
type ListReferralLifetimeReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralLifetimeReportRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralLifetimeReportRequestMultiError) AllErrors() []error { return m }

// ListReferralLifetimeReportRequestValidationError is the validation error
// returned by ListReferralLifetimeReportRequest.Validate if the designated
// constraints aren't met.
type ListReferralLifetimeReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralLifetimeReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralLifetimeReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralLifetimeReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralLifetimeReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralLifetimeReportRequestValidationError) ErrorName() string {
	return "ListReferralLifetimeReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralLifetimeReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralLifetimeReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralLifetimeReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralLifetimeReportRequestValidationError{}

// Validate checks the field values on LifetimeReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LifetimeReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LifetimeReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LifetimeReportItemMultiError, or nil if none found.
func (m *LifetimeReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *LifetimeReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for OperatorId

	// no validation rules for SystemOperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for OperatorName

	// no validation rules for SystemOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for RetailerOperatorName

	// no validation rules for ConversionRewardUsd

	// no validation rules for DepositCashbackUsd

	// no validation rules for WageringCommissionUsd

	// no validation rules for LossRevenueShareUsd

	// no validation rules for TotalUsd

	// no validation rules for ConversionRewardReportingCurrency

	// no validation rules for DepositCashbackReportingCurrency

	// no validation rules for WageringCommissionReportingCurrency

	// no validation rules for LossRevenueShareReportingCurrency

	// no validation rules for TotalReportingCurrency

	if len(errors) > 0 {
		return LifetimeReportItemMultiError(errors)
	}

	return nil
}

// LifetimeReportItemMultiError is an error wrapping multiple validation errors
// returned by LifetimeReportItem.ValidateAll() if the designated constraints
// aren't met.
type LifetimeReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LifetimeReportItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LifetimeReportItemMultiError) AllErrors() []error { return m }

// LifetimeReportItemValidationError is the validation error returned by
// LifetimeReportItem.Validate if the designated constraints aren't met.
type LifetimeReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LifetimeReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LifetimeReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LifetimeReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LifetimeReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LifetimeReportItemValidationError) ErrorName() string {
	return "LifetimeReportItemValidationError"
}

// Error satisfies the builtin error interface
func (e LifetimeReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLifetimeReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LifetimeReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LifetimeReportItemValidationError{}

// Validate checks the field values on ListReferralLifetimeReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListReferralLifetimeReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReferralLifetimeReportResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListReferralLifetimeReportResponseMultiError, or nil if none found.
func (m *ListReferralLifetimeReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReferralLifetimeReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListReferralLifetimeReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListReferralLifetimeReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListReferralLifetimeReportResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListReferralLifetimeReportResponseMultiError(errors)
	}

	return nil
}

// ListReferralLifetimeReportResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListReferralLifetimeReportResponse.ValidateAll() if the designated
// constraints aren't met.
type ListReferralLifetimeReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReferralLifetimeReportResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReferralLifetimeReportResponseMultiError) AllErrors() []error { return m }

// ListReferralLifetimeReportResponseValidationError is the validation error
// returned by ListReferralLifetimeReportResponse.Validate if the designated
// constraints aren't met.
type ListReferralLifetimeReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReferralLifetimeReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReferralLifetimeReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReferralLifetimeReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReferralLifetimeReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReferralLifetimeReportResponseValidationError) ErrorName() string {
	return "ListReferralLifetimeReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListReferralLifetimeReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReferralLifetimeReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReferralLifetimeReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReferralLifetimeReportResponseValidationError{}

// Validate checks the field values on ListAffiliateVTGReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAffiliateVTGReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAffiliateVTGReportRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListAffiliateVTGReportRequestMultiError, or nil if none found.
func (m *ListAffiliateVTGReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAffiliateVTGReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Period

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAffiliateVTGReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAffiliateVTGReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAffiliateVTGReportRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAffiliateVTGReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAffiliateVTGReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAffiliateVTGReportRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Dimension

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListAffiliateVTGReportRequestMultiError(errors)
	}

	return nil
}

// ListAffiliateVTGReportRequestMultiError is an error wrapping multiple
// validation errors returned by ListAffiliateVTGReportRequest.ValidateAll()
// if the designated constraints aren't met.
type ListAffiliateVTGReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAffiliateVTGReportRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAffiliateVTGReportRequestMultiError) AllErrors() []error { return m }

// ListAffiliateVTGReportRequestValidationError is the validation error
// returned by ListAffiliateVTGReportRequest.Validate if the designated
// constraints aren't met.
type ListAffiliateVTGReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAffiliateVTGReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAffiliateVTGReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAffiliateVTGReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAffiliateVTGReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAffiliateVTGReportRequestValidationError) ErrorName() string {
	return "ListAffiliateVTGReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAffiliateVTGReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAffiliateVTGReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAffiliateVTGReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAffiliateVTGReportRequestValidationError{}

// Validate checks the field values on AffiliateVTGReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AffiliateVTGReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AffiliateVTGReportItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AffiliateVTGReportItemMultiError, or nil if none found.
func (m *AffiliateVTGReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *AffiliateVTGReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for AffiliateId

	// no validation rules for AffiliateName

	// no validation rules for CampaignId

	// no validation rules for CampaignName

	// no validation rules for SettlementCycle

	// no validation rules for OperatorId

	// no validation rules for SystemOperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for OperatorName

	// no validation rules for SystemOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for RetailerOperatorName

	// no validation rules for Registrations

	// no validation rules for FtdUsers

	// no validation rules for RepeatDepositors

	// no validation rules for CrRegToFtd

	// no validation rules for QftdUsers

	// no validation rules for CrRegToQftd

	// no validation rules for FtdAmountUsd

	// no validation rules for QftdAmountUsd

	// no validation rules for TotalDepositsUsd

	// no validation rules for BonusAmountUsd

	// no validation rules for TotalWithdrawalsUsd

	// no validation rules for NetDepositUsd

	// no validation rules for PendingWithdrawalsUsd

	// no validation rules for AccountsWithBalance

	// no validation rules for CashBalanceUsd

	// no validation rules for BonusBalanceUsd

	// no validation rules for TotalBalanceUsd

	// no validation rules for TurnoverUsd

	// no validation rules for ValidTurnoverUsd

	// no validation rules for Bets

	// no validation rules for BetsAmountUsd

	// no validation rules for Wins

	// no validation rules for WinsAmountUsd

	// no validation rules for AvgBetUsd

	// no validation rules for GgrUsd

	// no validation rules for NgrUsd

	// no validation rules for NetProfitUsd

	// no validation rules for CommissionCpaUsd

	// no validation rules for CommissionCplUsd

	// no validation rules for CommissionRsUsd

	// no validation rules for CommissionTotalUsd

	// no validation rules for PspFeeUsd

	// no validation rules for ContentFeeUsd

	// no validation rules for Roi

	// no validation rules for FtdAmountReportingCurrency

	// no validation rules for QftdAmountReportingCurrency

	// no validation rules for TotalDepositsReportingCurrency

	// no validation rules for BonusAmountReportingCurrency

	// no validation rules for TotalWithdrawalsReportingCurrency

	// no validation rules for NetDepositReportingCurrency

	// no validation rules for PendingWithdrawalsReportingCurrency

	// no validation rules for CashBalanceReportingCurrency

	// no validation rules for BonusBalanceReportingCurrency

	// no validation rules for TotalBalanceReportingCurrency

	// no validation rules for TurnoverReportingCurrency

	// no validation rules for ValidTurnoverReportingCurrency

	// no validation rules for BetsAmountReportingCurrency

	// no validation rules for WinsAmountReportingCurrency

	// no validation rules for AvgBetReportingCurrency

	// no validation rules for GgrReportingCurrency

	// no validation rules for NgrReportingCurrency

	// no validation rules for NetProfitReportingCurrency

	// no validation rules for CommissionCpaReportingCurrency

	// no validation rules for CommissionCplReportingCurrency

	// no validation rules for CommissionRsReportingCurrency

	// no validation rules for CommissionTotalReportingCurrency

	// no validation rules for PspFeeReportingCurrency

	// no validation rules for ContentFeeReportingCurrency

	// no validation rules for RakeUsd

	// no validation rules for TaxUsd

	// no validation rules for RakeReportingCurrency

	// no validation rules for TaxReportingCurrency

	if len(errors) > 0 {
		return AffiliateVTGReportItemMultiError(errors)
	}

	return nil
}

// AffiliateVTGReportItemMultiError is an error wrapping multiple validation
// errors returned by AffiliateVTGReportItem.ValidateAll() if the designated
// constraints aren't met.
type AffiliateVTGReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AffiliateVTGReportItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AffiliateVTGReportItemMultiError) AllErrors() []error { return m }

// AffiliateVTGReportItemValidationError is the validation error returned by
// AffiliateVTGReportItem.Validate if the designated constraints aren't met.
type AffiliateVTGReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AffiliateVTGReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AffiliateVTGReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AffiliateVTGReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AffiliateVTGReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AffiliateVTGReportItemValidationError) ErrorName() string {
	return "AffiliateVTGReportItemValidationError"
}

// Error satisfies the builtin error interface
func (e AffiliateVTGReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAffiliateVTGReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AffiliateVTGReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AffiliateVTGReportItemValidationError{}

// Validate checks the field values on ListAffiliateVTGReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAffiliateVTGReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAffiliateVTGReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListAffiliateVTGReportResponseMultiError, or nil if none found.
func (m *ListAffiliateVTGReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAffiliateVTGReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAffiliateVTGReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAffiliateVTGReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAffiliateVTGReportResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListAffiliateVTGReportResponseMultiError(errors)
	}

	return nil
}

// ListAffiliateVTGReportResponseMultiError is an error wrapping multiple
// validation errors returned by ListAffiliateVTGReportResponse.ValidateAll()
// if the designated constraints aren't met.
type ListAffiliateVTGReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAffiliateVTGReportResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAffiliateVTGReportResponseMultiError) AllErrors() []error { return m }

// ListAffiliateVTGReportResponseValidationError is the validation error
// returned by ListAffiliateVTGReportResponse.Validate if the designated
// constraints aren't met.
type ListAffiliateVTGReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAffiliateVTGReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAffiliateVTGReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAffiliateVTGReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAffiliateVTGReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAffiliateVTGReportResponseValidationError) ErrorName() string {
	return "ListAffiliateVTGReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAffiliateVTGReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAffiliateVTGReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAffiliateVTGReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAffiliateVTGReportResponseValidationError{}

// Validate checks the field values on ListAffiliateSnapshotReportRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListAffiliateSnapshotReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAffiliateSnapshotReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListAffiliateSnapshotReportRequestMultiError, or nil if none found.
func (m *ListAffiliateSnapshotReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAffiliateSnapshotReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Period

	if all {
		switch v := interface{}(m.GetOperatorContextFilters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAffiliateSnapshotReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAffiliateSnapshotReportRequestValidationError{
					field:  "OperatorContextFilters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContextFilters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAffiliateSnapshotReportRequestValidationError{
				field:  "OperatorContextFilters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOperatorContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAffiliateSnapshotReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAffiliateSnapshotReportRequestValidationError{
					field:  "OperatorContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOperatorContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAffiliateSnapshotReportRequestValidationError{
				field:  "OperatorContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Dimension

	// no validation rules for OnlyNegativeCarryover

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListAffiliateSnapshotReportRequestMultiError(errors)
	}

	return nil
}

// ListAffiliateSnapshotReportRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListAffiliateSnapshotReportRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAffiliateSnapshotReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAffiliateSnapshotReportRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAffiliateSnapshotReportRequestMultiError) AllErrors() []error { return m }

// ListAffiliateSnapshotReportRequestValidationError is the validation error
// returned by ListAffiliateSnapshotReportRequest.Validate if the designated
// constraints aren't met.
type ListAffiliateSnapshotReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAffiliateSnapshotReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAffiliateSnapshotReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAffiliateSnapshotReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAffiliateSnapshotReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAffiliateSnapshotReportRequestValidationError) ErrorName() string {
	return "ListAffiliateSnapshotReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAffiliateSnapshotReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAffiliateSnapshotReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAffiliateSnapshotReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAffiliateSnapshotReportRequestValidationError{}

// Validate checks the field values on AffiliateSnapshotReportItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AffiliateSnapshotReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AffiliateSnapshotReportItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AffiliateSnapshotReportItemMultiError, or nil if none found.
func (m *AffiliateSnapshotReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *AffiliateSnapshotReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for AffiliateId

	// no validation rules for AffiliateName

	// no validation rules for CampaignId

	// no validation rules for CampaignName

	// no validation rules for SettlementCycle

	// no validation rules for OperatorId

	// no validation rules for SystemOperatorId

	// no validation rules for CompanyOperatorId

	// no validation rules for RetailerOperatorId

	// no validation rules for OperatorName

	// no validation rules for SystemOperatorName

	// no validation rules for CompanyOperatorName

	// no validation rules for RetailerOperatorName

	// no validation rules for ImpressionQty

	// no validation rules for Click

	// no validation rules for Ctr

	// no validation rules for Registrations

	// no validation rules for CrReg

	// no validation rules for FtdUsers

	// no validation rules for CrClickToFtd

	// no validation rules for CrRegToFtd

	// no validation rules for FtdAmountUsd

	// no validation rules for QftdUsers

	// no validation rules for CrClickToQftd

	// no validation rules for CrRegToQftd

	// no validation rules for QftdAmountUsd

	// no validation rules for CommissionCpaUsd

	// no validation rules for CommissionCplUsd

	// no validation rules for CommissionRsUsd

	// no validation rules for FlatFeeUsd

	// no validation rules for CommissionTotalUsd

	// no validation rules for NegativeCarryoverUsd

	// no validation rules for UnpaidCommissionUsd

	// no validation rules for PaidCommissionUsd

	// no validation rules for EstimatedRsUsd

	// no validation rules for EstimatedRsReportingCurrency

	// no validation rules for TotalDepositors

	// no validation rules for TotalDepositsUsd

	// no validation rules for BonusAmountUsd

	// no validation rules for TotalWithdrawalUsers

	// no validation rules for TotalWithdrawalsUsd

	// no validation rules for NetDepositUsd

	// no validation rules for ChargebacksTotal

	// no validation rules for ChargebacksAmountUsd

	// no validation rules for AdjustmentsAmountUsd

	// no validation rules for TurnoverUsd

	// no validation rules for ValidTurnoverUsd

	// no validation rules for Bets

	// no validation rules for BetsAmountUsd

	// no validation rules for Wins

	// no validation rules for WinsAmountUsd

	// no validation rules for AvgBetUsd

	// no validation rules for GgrUsd

	// no validation rules for NgrUsd

	// no validation rules for NetProfitUsd

	// no validation rules for Roi

	// no validation rules for PspFeeUsd

	// no validation rules for ContentFeeUsd

	// no validation rules for FtdAmountReportingCurrency

	// no validation rules for QftdAmountReportingCurrency

	// no validation rules for CommissionCpaReportingCurrency

	// no validation rules for CommissionCplReportingCurrency

	// no validation rules for CommissionRsReportingCurrency

	// no validation rules for FlatFeeReportingCurrency

	// no validation rules for CommissionTotalReportingCurrency

	// no validation rules for NegativeCarryoverReportingCurrency

	// no validation rules for UnpaidCommissionReportingCurrency

	// no validation rules for PaidCommissionReportingCurrency

	// no validation rules for TotalDepositsReportingCurrency

	// no validation rules for BonusAmountReportingCurrency

	// no validation rules for TotalWithdrawalsReportingCurrency

	// no validation rules for NetDepositReportingCurrency

	// no validation rules for ChargebacksAmountReportingCurrency

	// no validation rules for AdjustmentsAmountReportingCurrency

	// no validation rules for TurnoverReportingCurrency

	// no validation rules for ValidTurnoverReportingCurrency

	// no validation rules for BetsAmountReportingCurrency

	// no validation rules for WinsAmountReportingCurrency

	// no validation rules for AvgBetReportingCurrency

	// no validation rules for GgrReportingCurrency

	// no validation rules for NgrReportingCurrency

	// no validation rules for NetProfitReportingCurrency

	// no validation rules for PspFeeReportingCurrency

	// no validation rules for ContentFeeReportingCurrency

	// no validation rules for RakeUsd

	// no validation rules for TaxUsd

	// no validation rules for RakeReportingCurrency

	// no validation rules for TaxReportingCurrency

	if len(errors) > 0 {
		return AffiliateSnapshotReportItemMultiError(errors)
	}

	return nil
}

// AffiliateSnapshotReportItemMultiError is an error wrapping multiple
// validation errors returned by AffiliateSnapshotReportItem.ValidateAll() if
// the designated constraints aren't met.
type AffiliateSnapshotReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AffiliateSnapshotReportItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AffiliateSnapshotReportItemMultiError) AllErrors() []error { return m }

// AffiliateSnapshotReportItemValidationError is the validation error returned
// by AffiliateSnapshotReportItem.Validate if the designated constraints
// aren't met.
type AffiliateSnapshotReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AffiliateSnapshotReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AffiliateSnapshotReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AffiliateSnapshotReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AffiliateSnapshotReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AffiliateSnapshotReportItemValidationError) ErrorName() string {
	return "AffiliateSnapshotReportItemValidationError"
}

// Error satisfies the builtin error interface
func (e AffiliateSnapshotReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAffiliateSnapshotReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AffiliateSnapshotReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AffiliateSnapshotReportItemValidationError{}

// Validate checks the field values on ListAffiliateSnapshotReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListAffiliateSnapshotReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAffiliateSnapshotReportResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListAffiliateSnapshotReportResponseMultiError, or nil if none found.
func (m *ListAffiliateSnapshotReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAffiliateSnapshotReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAffiliateSnapshotReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAffiliateSnapshotReportResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAffiliateSnapshotReportResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return ListAffiliateSnapshotReportResponseMultiError(errors)
	}

	return nil
}

// ListAffiliateSnapshotReportResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListAffiliateSnapshotReportResponse.ValidateAll() if the designated
// constraints aren't met.
type ListAffiliateSnapshotReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAffiliateSnapshotReportResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAffiliateSnapshotReportResponseMultiError) AllErrors() []error { return m }

// ListAffiliateSnapshotReportResponseValidationError is the validation error
// returned by ListAffiliateSnapshotReportResponse.Validate if the designated
// constraints aren't met.
type ListAffiliateSnapshotReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAffiliateSnapshotReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAffiliateSnapshotReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAffiliateSnapshotReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAffiliateSnapshotReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAffiliateSnapshotReportResponseValidationError) ErrorName() string {
	return "ListAffiliateSnapshotReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAffiliateSnapshotReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAffiliateSnapshotReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAffiliateSnapshotReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAffiliateSnapshotReportResponseValidationError{}
